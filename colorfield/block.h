/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __BLOCK_H#define __BLOCK_H#include "colorfield.h"#include "index.h"#include "coord.h"#include "range.h"#include <algorithm>#include <iostream>namespace colorfield {#pragma mark block_ttemplate<class RR, class CR> class block_t;template<class RR, class CR, class R, class C> class block_coord_traits {public:			typedef RR rr_t;			typedef CR cr_t;						typedef block_t<typename rr_t::template index_traits<R>::outset_t,							typename cr_t::template index_traits<C>::outset_t> outset_t;			typedef block_t<typename rr_t::template index_traits<R>::inset_t,							typename cr_t::template index_traits<C>::inset_t> inset_t;			typedef block_t<typename rr_t::template index_traits<R>::sum_t,							typename cr_t::template index_traits<C>::sum_t> sum_t;						typedef block_t<typename rr_t::template index_traits<R>::diff_t,							typename cr_t::template index_traits<C>::diff_t> diff_t;						typedef coord_t<typename rr_t::template index_traits<R>::map_out_t,							typename cr_t::template index_traits<C>::map_out_t> map_out_t;			typedef coord_t<typename rr_t::template index_traits<R>::map_in_t,							typename cr_t::template index_traits<C>::map_in_t> map_in_t;};				template<class RR, class CR, class S, class L> class block_range_traits {public:			typedef RR rr_t;			typedef CR cr_t;			typedef block_t<typename range_range_traits<typename rr_t::start_t,typename rr_t::length_t,S,L>::map_out_t,cr_t> row_t;			typedef block_t<rr_t,typename range_range_traits<typename cr_t::start_t,typename cr_t::length_t,S,L>::map_out_t> col_t;};template<class RR, class CR, class RR2, class CR2> class block_block_traits {public:			typedef RR rr_t;			typedef CR cr_t;						typedef typename RR2::this_t			rr2_t;			typedef typename CR2::this_t			cr2_t;						typedef block_t<range_t<typename index_traits<typename rr2_t::start_t,typename rr_t::start_t>::sum_t,typename rr2_t::length_t>,							range_t<typename index_traits<typename cr2_t::start_t,typename cr_t::start_t>::sum_t,typename cr2_t::length_t> > map_out_t;								 			typedef block_t<range_t<typename index_traits<typename rr2_t::start_t,typename rr_t::start_t>::diff_t,typename rr2_t::length_t>,							range_t<typename index_traits<typename cr2_t::start_t,typename cr_t::start_t>::diff_t,typename cr2_t::length_t> > map_in_t;			typedef block_t<range_t<typename index_traits<typename rr_t::start_t,typename rr2_t::start_t>::sum_t,typename rr_t::length_t>,							range_t<typename index_traits<typename cr_t::start_t,typename cr2_t::start_t>::sum_t,typename cr_t::length_t> > inv_map_out_t;								 			typedef block_t<range_t<typename index_traits<typename rr_t::start_t,typename rr2_t::start_t>::diff_t,typename rr_t::length_t>,							range_t<typename index_traits<typename cr_t::start_t,typename cr2_t::start_t>::diff_t,typename cr_t::length_t> > inv_map_in_t;};template<class RR, class CR, class N> class block_slice_traits {public:			typedef RR rr_t;			typedef CR cr_t;			typedef typename rr_t::start_t  					top_t;			typedef typename rr_t::length_t 					height_t;			typedef typename cr_t::start_t  					left_t;			typedef typename cr_t::length_t 					width_t;						typedef block_t<range_t<typename index_traits<top_t,N>::sum_t, cindex<1> >, cr_t >	row_t;			typedef block_t<rr_t, range_t<typename index_traits<left_t,N>::sum_t, cindex<1> > >	col_t;			};template<class RR, class CR> class prim_block_t {public:				typedef typename RR::this_t 					rr_t;				typedef typename CR::this_t					cr_t;				typedef prim_block_t<rr_t,cr_t>		this_t;				typedef prim_block_t<cr_t,rr_t>		transpose_t;										prim_block_t(const rr_t rr, const cr_t cr)	: rr_(rr), cr_(cr) {}										prim_block_t(const this_t &b)				: rr_(b.rr_), cr_(b.cr_) {}										prim_block_t(void)							{}		  const rr_t&					row_range(void) const						{ return rr_; }				rr_t&					row_range(void)								{ return rr_; }		  const cr_t&					column_range(void) const					{ return cr_; }				cr_t&					column_range(void)							{ return cr_; }				this_t&					operator= (const this_t &b)					{ rr_ = b.rr_; cr_ = b.cr_; return *this; }template<class RR2, class CR2>				this_t&					operator= (const prim_block_t<RR2,CR2> &b)	{ rr_ = b.row_range(); cr_ = b.column_range(); return *this; }				template<class RR2, class CR2>				bool					operator==(const prim_block_t<RR2,CR2> &b) const																					{ return (rr_ == b.row_range()) && (cr_ == b.column_range()); }template<class RR2, class CR2>				bool					operator!=(const prim_block_t<RR2,CR2> &b) const																					{ return (rr_ != b.row_range()) || (cr_ != b.column_range()); }															  const transpose_t				transpose(void) const						{ return transpose_t(cr_, rr_); }private:				rr_t					rr_;	// row-range: gives index of first row, number of rows				cr_t					cr_;	// column range: gives index of first column, number of columns};template<index_t RS, index_t RL, index_t CS, index_t CL> class prim_block_t<range_t<cindex<RS>,cindex<RL> >, range_t<cindex<CS>,cindex<CL> > > {public:				typedef range_t<cindex<RS>,cindex<RL> >	rr_t;				typedef range_t<cindex<CS>,cindex<CL> > cr_t;								typedef prim_block_t<rr_t,cr_t>		this_t;				typedef prim_block_t<cr_t,rr_t>		transpose_t;										prim_block_t(const rr_t, const cr_t)		{}										prim_block_t(const this_t &)				{}										prim_block_t(void)							{}		  const rr_t&					row_range(void) const						{ return rr_; }		  const cr_t&					column_range(void) const					{ return cr_; }				this_t&					operator= (const this_t &)					{ return *this; }				template<class RR2, class CR2>				bool					operator==(const prim_block_t<RR2,CR2> &b) const																					{ return (rr_ == b.row_range()) && (cr_ == b.column_range()); }template<class RR2, class CR2>				bool					operator!=(const prim_block_t<RR2,CR2> &b) const																					{ return (rr_ != b.row_range()) || (cr_ != b.column_range()); }															  const transpose_t				transpose(void) const						{ return transpose_t(cr_, rr_); }private:static	  const rr_t					rr_;	// row-range: gives index of first row, number of rowsstatic	  const cr_t					cr_;	// column range: gives index of first column, number of columns};template<index_t RS, index_t RL, index_t CS, index_t CL> const range_t<cindex<RS>,cindex<RL> > prim_block_t<range_t<cindex<RS>,cindex<RL> >, range_t<cindex<CS>,cindex<CL> > >::rr_ = range_t<cindex<RS>,cindex<RL> >(cindex<RS>(),cindex<RL>());template<index_t RS, index_t RL, index_t CS, index_t CL> const range_t<cindex<CS>,cindex<CL> > prim_block_t<range_t<cindex<RS>,cindex<RL> >, range_t<cindex<CS>,cindex<CL> > >::cr_ = range_t<cindex<CS>,cindex<CL> >(cindex<CS>(),cindex<CL>());template<index_t RS, index_t RL, class CR> class prim_block_t<range_t<cindex<RS>,cindex<RL> >, CR> {public:				typedef range_t<cindex<RS>,cindex<RL> > rr_t;				typedef typename CR::this_t					cr_t;				typedef prim_block_t<rr_t,cr_t>		this_t;				typedef prim_block_t<cr_t,rr_t>		transpose_t;										prim_block_t(const rr_t rr, const cr_t cr)	: cr_(cr) {}										prim_block_t(const this_t &b)				: cr_(b.cr_) {}										prim_block_t(void)							{}		  const rr_t&					row_range(void) const						{ return rr_; }		  const cr_t&					column_range(void) const					{ return cr_; }				cr_t&					column_range(void)							{ return cr_; }				this_t&					operator= (const this_t &b)					{ cr_ = b.cr_; return *this; }				template<class RR2, class CR2>				bool					operator==(const prim_block_t<RR2,CR2> &b) const																					{ return (rr_ == b.row_range()) && (cr_ == b.column_range()); }template<class RR2, class CR2>				bool					operator!=(const prim_block_t<RR2,CR2> &b) const																					{ return (rr_ != b.row_range()) || (cr_ != b.column_range()); }															  const transpose_t				transpose(void) const						{ return transpose_t(cr_, rr_); }private:static	  const rr_t					rr_;	// row-range: gives index of first row, number of rows				cr_t					cr_;	// column range: gives index of first column, number of columns};template<index_t RS, index_t RL, class CR> const range_t<cindex<RS>,cindex<RL> > prim_block_t<range_t<cindex<RS>,cindex<RL> >, CR>::rr_ = range_t<cindex<RS>,cindex<RL> >(cindex<RS>(),cindex<RL>());template<class RR, index_t CS, index_t CL> class prim_block_t<RR, range_t<cindex<CS>,cindex<CL> > > {public:				typedef typename RR::this_t 					rr_t;				typedef range_t<cindex<CS>,cindex<CL> >	cr_t;								typedef prim_block_t<rr_t,cr_t>		this_t;				typedef prim_block_t<cr_t,rr_t>		transpose_t;										prim_block_t(const rr_t rr, const cr_t cr)	: rr_(rr) {}										prim_block_t(const this_t &b)				: rr_(b.rr_) {}										prim_block_t(void)							{}		  const rr_t&					row_range(void) const						{ return rr_; }				rr_t&					row_range(void)								{ return rr_; }		  const cr_t&					column_range(void) const					{ return cr_; }				this_t&					operator= (const this_t &b)					{ rr_ = b.rr_;return *this; }				template<class RR2, class CR2>				bool					operator==(const prim_block_t<RR2,CR2> &b) const																					{ return (rr_ == b.row_range()) && (cr_ == b.column_range()); }template<class RR2, class CR2>				bool					operator!=(const prim_block_t<RR2,CR2> &b) const																					{ return (rr_ != b.row_range()) || (cr_ != b.column_range()); }															  const transpose_t				transpose(void) const						{ return transpose_t(cr_, rr_); }private:				rr_t					rr_;	// row-range: gives index of first row, number of rowsstatic	  const cr_t					cr_;	// column range: gives index of first column, number of columns};template<class RR, index_t CS, index_t CL> const range_t<cindex<CS>,cindex<CL> > prim_block_t<RR, range_t<cindex<CS>,cindex<CL> > >::cr_ = range_t<cindex<CS>,cindex<CL> >(cindex<CS>(),cindex<CL>());template<> class prim_block_t<range_t<>, range_t<> > {public:				typedef range_t<> 					rr_t;				typedef range_t<>					cr_t;								typedef prim_block_t<rr_t,cr_t>		this_t;				typedef prim_block_t<cr_t,rr_t>		transpose_t;										prim_block_t(const rr_t rr, const cr_t cr)	{ row_range() = rr; column_range() = cr; }										prim_block_t(const this_t &b)				{ *this = b; }										prim_block_t(void)							{}		  const rr_t&					row_range(void) const						{ return m_.rr_; }				rr_t&					row_range(void)								{ return m_.rr_; }		  const cr_t&					column_range(void) const					{ return m_.cr_; }				cr_t&					column_range(void)							{ return m_.cr_; }				this_t&					operator= (const this_t &b)					{ data_ = b.data_; return *this; }template<class RR2, class CR2>				this_t&					operator= (const prim_block_t<RR2,CR2> &b)	{ row_range() = b.row_range(); column_range() = b.column_range(); return *this; }								bool					operator==(const this_t &b) const			{ return data_ == b.data_; }template<class RR2, class CR2>				bool					operator==(const prim_block_t<RR2,CR2> &b) const																					{ return (row_range() == b.row_range()) && (column_range() == b.column_range()); }				bool					operator!=(const this_t &b) const			{ return data_ != b.data_; }template<class RR2, class CR2>				bool					operator!=(const prim_block_t<RR2,CR2> &b) const																					{ return (row_range() != b.row_range()) || (column_range() != b.column_range()); }															  const transpose_t				transpose(void) const						{ return transpose_t(column_range(), row_range()); }private:		union {				uint64_t				data_;			struct {				range_t<>				rr_;				range_t<>				cr_;			}							m_;		};};template<class RR = range_t<>, class CR = range_t<> > class block_t : public prim_block_t<RR,CR> {	//	// row-range is the range of legal row coordinates;	// column-range the range of legal column coords.	//			public:							// Types											typedef typename RR::this_t 						rr_t;				typedef typename CR::this_t						cr_t;								typedef block_t<rr_t,cr_t>				this_t;				typedef prim_block_t<rr_t,cr_t>			base_t;				typedef block_t<cr_t,rr_t>				transpose_t;				typedef block_t<>						general_t;								typedef typename rr_t::start_t  					top_t;				typedef typename rr_t::length_t 					height_t;				typedef typename cr_t::start_t  					left_t;				typedef typename cr_t::length_t 					width_t;				typedef typename rr_t::stop_t					bottom_t;				typedef typename cr_t::stop_t					right_t;								typedef coord_t<top_t,left_t>			top_left_t;				typedef coord_t<bottom_t,right_t>		bottom_right_t;				typedef coord_t<height_t,width_t>		extent_t;				typedef typename index_traits<height_t,width_t>::min_t diagonal_extent_t;																typedef block_t<range_t<zero_t,height_t>, range_t<zero_t,width_t> >	origin_t;							// Traits								template<class R = index_t, class C = index_t> class coord_traits : public block_coord_traits<rr_t,cr_t,R,C> {};				template<class RR2, class CR2> class block_traits : public block_block_traits<rr_t,cr_t,RR2,CR2> {};				template<class S = index_t, class L = index_t> class range_traits : public block_range_traits<rr_t,cr_t,S,L> {};				template<class N = index_t> class slice_traits : public block_slice_traits<rr_t,cr_t,N> {};							// Constructors										block_t(const rr_t rr, const cr_t cr)								: base_t(rr,cr) {}										block_t(const top_t &top, const height_t &height, const cr_t &cr)	: base_t(rr_t(top,height), cr) {}										block_t(const rr_t &rr, const left_t &left, const width_t &width)	: base_t(rr, cr_t(left,width)) {}										block_t(const top_t &top, const height_t &height, const left_t &left, const width_t &width)																												: base_t(rr_t(top,height), cr_t(left,width)) {}										block_t(const block_t<rr_t,cr_t> &bl)								: base_t(bl) {}										block_t(void)														{}										operator general_t(void) const			{ return general_t(row_range(),column_range()); }template<class RR2, class CR2>				this_t&					operator= (const block_t<RR2,CR2> &b)	{ this->base_t::operator=(b); return *this; }							// accessors    const rr_t&					row_range(void) const						{ return base_t::row_range(); }    rr_t&					row_range(void)								{ return base_t::row_range(); }    const cr_t&					column_range(void) const					{ return base_t::column_range(); }    cr_t&					column_range(void)							{ return base_t::column_range(); }        top_t					top(void) const							{ return row_range().start(); }//				top_t&					top(void)								{ return row_range().start(); }				left_t					left(void) const						{ return column_range().start(); }//				left_t&					left(void)								{ return column_range().start(); }						 		height_t				height(void) const						{ return row_range().length(); }//				height_t&				height(void)							{ return row_range().length(); }				width_t					width(void) const						{ return column_range().length(); }//				width_t&				width(void)								{ return column_range().length(); }				bottom_t				bottom(void) const						{ return row_range().stop(); }				right_t					right(void) const						{ return column_range().stop(); }				top_left_t				top_left(void) const					{ return top_left_t(top(), left()); }				bottom_right_t			bottom_right(void) const				{ return bottom_right_t(bottom(), right()); }				extent_t				extent(void) const						{ return extent_t(row_range().length(), column_range().length()); }    diagonal_extent_t		diagonal_extent(void) const				{ return std::min(row_range().length(), column_range().length()); }		  							// predicates											bool					is_square(void) const					{ return (width() == height()); }template<class R, class C>	 			bool 					contains(const coord_t<R,C> &c) const	{ return (row_range().contains(c.row()) && column_range().contains(c.column())); }							// operators															transpose_t				transpose(void) const					{ return transpose_t(column_range(), row_range()); }		 inline	typename slice_traits<index_t>::row_t												row(index_t n) const					{ 																				  index_t new_top = (index_t) (top() + n);																				  return slice_traits<index_t>::row_t(new_top, one, column_range()); 																				}template<index_t Rn> inline	typename slice_traits<cindex<Rn> >::row_t												row(cindex<Rn> n) const					{																				  typename index_traits<top_t,cindex<Rn> >::sum_t new_top = top() + n;																				  return typename slice_traits<cindex<Rn> >::row_t(new_top, one, column_range());																				}template<class S, class L>inline typename range_traits<S,L>::row_t										row(range_t<S,L> rr) const				{ return range_traits<S,L>::row_t(row_range().map_out(rr),column_range()); }inline typename slice_traits<index_t>::col_t												column(index_t n) const					{																				  index_t new_left = (index_t) (left() + n);																				  return slice_traits<index_t>::col_t(row_range(), new_left, one); 																				}template<index_t Rn>inline	typename slice_traits<cindex<Rn> >::col_t												column(cindex<Rn> n) const				{																				  typename index_traits<left_t,cindex<Rn> >::sum_t new_left = column_range().start() + n;																				  return typename slice_traits<cindex<Rn> >::col_t(row_range(), new_left, one);																				}template<class S, class L>inline typename range_traits<S,L>::col_t column(range_t<S,L> cr) const			{ return range_traits<S,L>::col_t(row_range(),column_range().map_out(cr)); }										template<class R, class C>inline typename coord_traits<R,C>::inset_t inset (coord_t<R,C> c) const 		{ return typename coord_traits<R,C>::inset_t (row_range().inset (c.row()), column_range().inset (c.column())); }template<class R, class C>    inline typename coord_traits<R,C>::outset_t outset(coord_t<R,C> c) const 		{ return typename coord_traits<R,C>::outset_t(row_range().outset(c.row()), column_range().outset(c.column())); }template<class R, class C>inline typename coord_traits<R,C>::sum_t operator+ (coord_t<R,C> c) const		{ return typename coord_traits<R,C>::sum_t (row_range() + c.row(), column_range() + c.column()); }template<class R, class C>inline typename coord_traits<R,C>::diff_t operator- (coord_t<R,C> c) const		{ return typename coord_traits<R,C>::diff_t(row_range() - c.row(), column_range() - c.column()); }template<class R, class C>inline typename coord_traits<R,C>::map_out_t												map_out(coord_t<R,C> c) const			{ return typename coord_traits<R,C>::map_out_t(c.row() + top(), c.column() + left()); }template<typename RR2, typename CR2>inline typename block_traits<RR2,CR2>::map_out_t												map_out(const block_t<RR2,CR2>& op) const { return typename block_traits<RR2,CR2>::map_out_t(row_range().map_out(op.row_range()),																															column_range().map_out(op.column_range())); }template<class R, class C> inline typename coord_traits<R,C>::map_in_t												map_in (coord_t<R,C> c) const			{ return typename coord_traits<R,C>::map_in_t (c.row() - top(), c.column() - left()); }template<typename RR2, typename CR2>inline typename block_traits<RR2,CR2>::map_in_t												map_in(const block_t<RR2,CR2>& op) const { return typename block_traits<RR2,CR2>::map_in_t(row_range().map_in(op.row_range()),																														  column_range().map_in(op.column_range())); }};template<class RR, class CR>inline block_t<RR,CR> block(const RR &rr, const CR &cr){	return block_t<RR,CR>(rr,cr);}template<index_t RN, index_t CN>class cblock_t : public block_t< range_t<zero_t, cindex<RN> >, range_t<zero_t, cindex<CN> > > {public:				typedef cblock_t<RN,CN>	this_t;				typedef range_t<zero_t, cindex<RN> > rr_t;				typedef range_t<zero_t, cindex<CN> > cr_t;								typedef block_t<rr_t,cr_t> base_t;																cblock_t(const cblock_t &bl)			: base_t(bl) {}										cblock_t(const base_t &bl)				: base_t(bl) {}										cblock_t(const rr_t rr, const cr_t cr)	: base_t(rr,cr) {}										cblock_t(const typename rr_t::length_t rl, const typename cr_t::length_t cl)	: base_t(rr_t(zero, rl), cr_t(zero, cl)) {}										cblock_t(void)							: base_t(rr_t(zero, cindex<RN>()), cr_t(zero, cindex<CN>())) {}                this_t					operator=(const this_t &b)				{ base_t::row_range() = b.row_range(); base_t::column_range() = b.column_range(); return *this; }};#pragma mark operator<<template<class rr_t, class cr_t>inline std::ostream &operator<<(std::ostream &os, const block_t<rr_t,cr_t> &bl){	os << "[" << bl.top() << "+" << bl.height() << ", " << bl.left() << "+" << bl.width() << "]";	return os;}} /* namespace colorfield */#endif /* __BLOCK_H */