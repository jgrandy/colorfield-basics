/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __GEO2D_H#define __GEO2D_H#include "colorfield.h"#include <boost/array.hpp>namespace cf_geo2d {/*1.					2.					3.*/// simple geometric classes// to do://// add MSL optimizations for short,short points// add 3x3 matrixtemplate<class Traits> class vector;template<class Traits> class point;template<class VTraits> class rectangle;template<class Traits> class line;template<class VTraits> class rectangle_traits_explicit;template<class VTraits> class rectangle_traits_implicit;template<class VTraits> class line_traits_explicit;template<class VTraits> class line_traits_implicit;template<typename Scalar> class vector_traits_topleft {public:			typedef Scalar								scalar_t;			typedef vector_traits_topleft				this_t;			typedef vector<this_t>						vector_t;			typedef point<this_t>						point_t;			typedef rectangle<rectangle_traits_explicit<this_t> > explicit_rectangle_t;			typedef rectangle<rectangle_traits_implicit<this_t> > implicit_rectangle_t;			typedef line<line_traits_explicit<this_t> >	explicit_line_t;			typedef line<line_traits_implicit<this_t> >	implicit_line_t;static		  const std::size_t			num_components_ = 2,										x_index_ = 1,										y_index_ = 0;};template<typename Scalar> class vector_traits_lefttop {public:			typedef Scalar				scalar_t;			typedef vector_traits_lefttop				this_t;			typedef vector<this_t>						vector_t;			typedef point<this_t>						point_t;			typedef rectangle<rectangle_traits_explicit<this_t> > explicit_rectangle_t;			typedef rectangle<rectangle_traits_implicit<this_t> > implicit_rectangle_t;			typedef line<line_traits_explicit<this_t> >	explicit_line_t;			typedef line<line_traits_implicit<this_t> >	implicit_line_t;static		  const std::size_t			num_components_ = 2,										x_index_ = 0,										y_index_ = 1;};template<class VTraits> class rectangle_traits_explicit {public:			typedef VTraits				vector_traits_t;			typedef typename VTraits::scalar_t	scalar_t;			typedef point<VTraits>		point_t;			typedef vector<VTraits>		vector_t;};template<class VTraits> class rectangle_traits_implicit {public:			typedef VTraits				vector_traits_t;			typedef typename VTraits::scalar_t	scalar_t;			typedef point<VTraits>		point_t;			typedef vector<VTraits>		vector_t;};template<class VTraits> class line_traits_explicit {public:			typedef VTraits						vector_traits_t;			typedef typename vector_traits_t::scalar_t	scalar_t;			typedef point<VTraits>		point_t;			typedef vector<VTraits>		vector_t;};template<class VTraits> class line_traits_implicit {public:			typedef VTraits						vector_traits_t;			typedef typename vector_traits_t::scalar_t	scalar_t;			typedef point<VTraits>		point_t;			typedef vector<VTraits>		vector_t;};template<class Traits> class vector : public boost::array<Traits::scalar_t, Traits::num_components_> {friend class point<Traits>;public:			typedef Traits								traits_t;			typedef typename traits_t::scalar_t			scalar_t;			typedef vector<traits_t>					this_t;			typedef boost::array<Traits::scalar_t, Traits::num_components_>		base_t;			typedef traits_t::point_t					point_t;static		  const this_t&				get(const scalar_t *data)					{ return *(colorfield::implicit_cast<const this_t*>(data)); }										vector(void)								{}										vector(const this_t& p)						{ x() = p.x(); y() = p.y(); }template<class T2>						vector(const vector<T2> &v)					{ x() = v.x(); y() = v.y(); }template<class T2> explicit				vector(const point<T2> &p)					{ x() = p.x(); y() = p.y(); }										vector(const scalar_t &xval, const scalar_t &yval)																					{ x() = xval; y() = yval; }					this_t&				operator= (const this_t &p)					{ x() = p.x(); y() = p.y(); return *this; }template<class T2>	this_t&				operator= (const vector<T2> &p)				{ x() = p.x(); y() = p.y(); return *this; }				template<class T2>	bool				operator==(const vector<T2> &p) const		{ return (x() == p.x()) && (y() == p.y()); }template<class T2>	bool				operator!=(const vector<T2> &p) const		{ return (x() != p.x()) || (y() != p.y()); }				 				 	bool				operator==(const scalar_t &n) const			{ return (x() == n) && (y() == n); }				 	bool				operator!=(const scalar_t &n) const			{ return (x() != n) || (y() != n); }				 					 	scalar_t&			x(void)										{ return elems[traits_t::x_index_]; }			  const scalar_t&			x(void) const								{ return elems[traits_t::x_index_]; }				 	scalar_t&			width(void)									{ return x(); }			  const scalar_t&			width(void) const							{ return x(); }			  				 	scalar_t&			y(void)										{ return elems[traits_t::y_index_]; }			  const scalar_t&			y(void) const								{ return elems[traits_t::y_index_]; }				 	scalar_t&			height(void)								{ return y(); }			  const scalar_t&			height(void) const							{ return y(); }			  										operator       scalar_t*(void)				{ return (      scalar_t*) this; }										operator const scalar_t*(void) const		{ return (const scalar_t*) this; }					scalar_t			length(void) const							{ return std::sqrt((x() * x()) + (y() * y())); }					this_t				operator()(void) const						{ return *this; }									this_t				operator- (void) const						{ return this_t(- x(), - y()); }					this_t				operator+ (void) const						{ return this_t(x(), y()); }					template<class T2>	this_t&				operator+=(const vector<T2> &p)				{ x() += p.x(); y() += p.y(); return *this; }template<class T2>	this_t&				operator-=(const vector<T2> &p)				{ x() -= p.x(); y() -= p.y(); return *this; }					template<class T2>	this_t				operator- (const vector<T2> &p) const		{ return this_t(x()-p.x(),y()-p.y()); }template<class T2>	this_t				operator+ (const vector<T2> &p) const		{ return this_t(x()+p.x(),y()+p.y()); }					this_t				operator+ (const scalar_t &k) const			{ return this_t(x()+k,y()+k); }					this_t				operator- (const scalar_t &k) const			{ return this_t(x()-k,y()-k); }									this_t				operator* (const float &k) const			{ return this_t(x()*k,y()*k); }					this_t				operator/ (const float &k) const			{ return this_t(x()/k,y()/k); }									this_t				normalized(void) const						{ return(*this / this->length()); }					scalar_t			angle(void) const							{ return std::fmod(std::atan2(height(),width()), (scalar_t) colorfield::twopi); }					this_t				cw_perpendicular(void) const				{ return this_t(height(), - width()); }					this_t				ccw_perpendicular(void) const				{ return this_t(- height(), width()); }friend				scalar_t			dot(const this_t &v1, const this_t &v2)		{ return ((v1.width() * v2.width()) + (v1.height() * v2.height())); }friend				scalar_t			dot(const this_t &v1, const point_t &p2)	{ return ((v1.width() * p2.x()) + (v1.height() * p2.y())); }};template<class Traits> class point : public vector<Traits> {public:				typedef Traits				traits_t;				typedef typename traits_t::scalar_t	scalar_t;				typedef point<traits_t>		this_t;				typedef vector<traits_t>	base_t;				typedef base_t				vector_t;static		  const this_t&				get(const scalar_t *data)					{ return *(colorfield::implicit_cast<const this_t*>(data)); }										point(void)									: base_t() {}										point(const this_t& p)						: base_t(p) {}										point(const base_t& v)						: base_t(v) {}template<class T2>						point(const point<T2> &p)					: base_t(p) {}										point(const scalar_t &xval, const scalar_t &yval)																					: base_t(xval,yval) {}					this_t&				operator= (const this_t &p)					{ x() = p.x(); y() = p.y(); return *this; }template<class T2>	this_t&				operator= (const point<T2> &p)				{ x() = p.x(); y() = p.y(); return *this; }					template<class T2>	this_t				operator- (const vector<T2> &p) const		{ return this_t(x()-p.x(),y()-p.y()); }template<class T2>	this_t				operator+ (const vector<T2> &p) const		{ return this_t(x()+p.x(),y()+p.y()); }template<class T2>	vector_t			operator- (const point<T2> &p) const		{ return vector_t(x()-p.x(),y()-p.y()); }template<class T2>	vector_t			operator+ (const point<T2> &p) const		{ return vector_t(x()+p.x(),y()+p.y()); }					this_t				operator+ (const scalar_t &k) const			{ return this_t(x()+k,y()+k); }					this_t				operator- (const scalar_t &k) const			{ return this_t(x()-k,y()-k); }									this_t				operator* (const float &k) const			{ return this_t(x()*k,y()*k); }					this_t				operator/ (const float &k) const			{ return this_t(x()/k,y()/k); }template<class T2>	this_t				pinned_by(const rectangle<T2> &r) const		{																						this_t p = *this;																						if (p.x() < r.left())			p.x() = r.left();																						else if (p.x() > r.right())		p.x() = r.right();																						if (p.y() < r.top())			p.y() = r.top();																						else if (p.y() > r.bottom())	p.y() = r.bottom();																						return p;																					}template<class T2>	this_t				pinned_by(const point<T2> &e) const			{																						this_t p = *this;																						if (p.x() < 0)		p.x() = 0;																						else if (p.x() > e.x())	p.x() = e.x();																						if (p.y() < 0)		p.y() = 0;																						else if (p.y() > e.y())	p.y() = e.y();																						return p;																					}			};template<class VTraits> class rectangle<rectangle_traits_explicit<VTraits> > {public:				typedef rectangle_traits_explicit<VTraits> traits_t;				typedef traits_t::scalar_t					scalar_t;				typedef rectangle<traits_t>					this_t;				typedef traits_t::point_t					point_t;				typedef traits_t::vector_t					vector_t;														rectangle(void)								: left_top_(), right_bottom_() {}										rectangle(const this_t &r)					: left_top_(r.left_top_), right_bottom_(r.right_bottom_) {}template<class T2>						rectangle(const rectangle<T2> &r)			: left_top_(r.left_top()), right_bottom_(r.right_bottom()) {}template<class T2, class T3>			rectangle(const point<T2> &p1, const point<T3> &p2)																					: left_top_(p1), right_bottom_(p2) {}template<class T2, class T3>			rectangle(const point<T2> &p, const vector<T3> &v)																					: left_top_(p), right_bottom_(p+v) {}template<class T3>						rectangle(const vector<T3> &v)				: left_top_(0,0), right_bottom_(v) {}													this_t&				operator= (const this_t &r)					{ left_top_ = r.left_top_; right_bottom_ = r.right_bottom_; return *this; }template<class T2>	this_t&				operator= (const rectangle<T2> &r)			{ left_top_ = r.left_top(); right_bottom_ = r.right_bottom(); return *this; }									bool				operator==(const this_t &r) const			{ return (left_top_ == r.left_top_) && (right_bottom_ == r.right_bottom_); }					bool				operator!=(const this_t &r) const			{ return (left_top_ != r.left_top_) || (right_bottom_ != r.right_bottom_); }template<class T2>	bool				operator==(const rectangle<T2> &r) const	{ return (left_top_ == r.left_top()) && (right_bottom_ == r.right_bottom()); }template<class T2>	bool				operator!=(const rectangle<T2> &r) const	{ return (left_top_ != r.left_top()) || (right_bottom_ != r.right_bottom()); }					bool				is_empty(void) const						{ return (left_top_ == right_bottom_); }template<class T2>	bool				contains(const point<T2> &p) const			{ return (colorfield::between(p.x(), left(), right()) && colorfield::between(p.y(), top(), bottom())); }template<class T2>	bool				intersects(const rectangle<T2> &r) const	{																					  using colorfield::between;																					  return ((between(left(), r.left(), r.right()) || between(right() , r.left(), r.right())) &&																						      (between(top() , r.top(), r.bottom()) || between(bottom(), r.top(), r.bottom()))) ||																						     ((between(r.left(), left(), right()) || between(r.right() , left(), right())) &&																						      (between(r.top() , top(), bottom()) || between(r.bottom(), top(), bottom())));																					}														operator       scalar_t*(void)				{ return (      scalar_t*) this; }										operator const scalar_t*(void) const		{ return (const scalar_t*) this; }										operator       point_t*(void)				{ return (      point_t*) this; }										operator const point_t*(void) const			{ return (const point_t*) this; }					scalar_t&			left(void)									{ return left_top_.x(); }			  const scalar_t&			left(void) const							{ return left_top_.x(); }					scalar_t&			right(void)									{ return right_bottom_.x(); }			  const scalar_t&			right(void) const							{ return right_bottom_.x(); }					scalar_t&			top(void)									{ return left_top_.y(); }			  const scalar_t&			top(void) const								{ return left_top_.y(); }					scalar_t&			bottom(void)								{ return right_bottom_.y(); }			  const scalar_t&			bottom(void) const							{ return right_bottom_.y(); }			  			  		point_t&			origin(void)								{ return left_top_; }			  const point_t&			origin(void) const							{ return left_top_; } 					vector_t			extent(void) const							{ return vector_t(right()-left(),bottom()-top()); }					scalar_t			width(void) const							{ return right() - left(); }					scalar_t			height(void) const							{ return bottom() - top(); }					point_t&			left_top(void)								{ return left_top_; }			  const point_t&			left_top(void) const						{ return left_top_; }					point_t&			right_bottom(void)							{ return right_bottom_; }			  const point_t&			right_bottom(void) const					{ return right_bottom_; }					point_t				right_top(void) const						{ return point_t(right(), top()); }					point_t				left_bottom(void) const						{ return point_t(left(), bottom()); }template<class T2>	this_t&				move_to(const point<T2> &p)					{ const point_t e = extent(); left_top() = p; right_bottom() = p + e; return *this; }					this_t&				move_to_origin(void)						{ const point_t e = left_top(); *this -= e; return *this; }template<class T2>	this_t&				move_by(const vector<T2> &v)				{ left_top() += v; right_bottom() += v; return *this; }template<class T2>	this_t&				resize(const vector<T2> &new_extent)		{ right_bottom() = left_top() + new_extent; return *this; }					this_t&				set_empty(void)								{ left() = top() = right() = bottom() = 0; return *this; }									this_t				inset(scalar_t k) const						{ return this_t(left_top_ + k, right_bottom_ - k); }					this_t				outset(scalar_t k) const					{ return this_t(left_top_ - k, right_bottom_ + k); }template<class T2>	this_t				inset(const vector<T2> &p) const			{ return this_t(left_top_ + p, right_bottom_ - p); }template<class T2>	this_t				outset(const vector<T2> &p) const			{ return this_t(left_top_ - p, right_bottom_ + p); }					this_t				operator* (scalar_t k) const				{ return this_t(left_top_ * k, right_bottom_ * k); }					this_t				operator/ (scalar_t k) const				{ return this_t(left_top_ * k, right_bottom_ * k); }				template<class T2>	this_t				operator+ (const vector<T2> &p) const		{ return this_t(left_top_ + p, right_bottom_ + p); }template<class T2>	this_t				operator- (const vector<T2> &p) const		{ return this_t(left_top_ - p, right_bottom_ - p); }template<class T2>	this_t				operator| (const rectangle<T2> &r) const	{ return this_t(std::min(left(),r.left()), std::min(top(),r.top()),																									std::max(right(),r.right()), std::max(bottom(),r.bottom())); }template<class T2>	this_t				operator& (const rectangle<T2> &r) const	{																						rectangle overlap(point_t(std::max(left(),r.left()), std::max(top(),r.top())), 																										  point_t(std::min(right(),r.right()), std::min(bottom(),r.bottom())));																						if (overlap.left() > overlap.right())																							overlap.left() = overlap.right();																						if (overlap.top() > overlap.bottom())																							overlap.top() = overlap.bottom();																						return overlap;																					}template<class T2>	this_t&				operator+=(const vector<T2> &p)				{ left_top_ += p; right_bottom_ += p; return *this; }template<class T2>	this_t&				operator-=(const vector<T2> &p)				{ left_top_ -= p; right_bottom_ -= p; return *this; }template<class T2>	this_t&				operator|=(const rectangle<T2> &r)			{ left() = std::min(left(),r.left()); top() = std::min(top(),r.top()); 																					  right() = std::max(right(),r.right()); bottom() = std::max(bottom(),r.bottom()); 																					  return *this; }template<class T2>	this_t&				operator&=(const rectangle<T2> &r)			{																					  const rectangle<T2> ri = (*this) & r;																					  *this = ri;																					}				template<class T2>	this_t&				pin_by(const rectangle<T2> &r)				{																						vector_t delta(0,0);																						if (this->width() <= r.width()) {																							if (left() < r.left()) {																								delta.x() = r.left() - left();																							} else if (right() > r.right()) {																								delta.x() = r.right() - right();																							}																						}																						if (this->height() <= r.height()) {																							if (top() < r.top()) {																								delta.y() = r.top() - top();																							} else if (bottom() > r.bottom()) {																								delta.y() = r.bottom() - bottom();																							}																						}																						*this += delta;																						return *this;																  																					}template<class T2>	this_t&				scale_to(const rectangle<T2> &r)			{																						const vector_t ref_extent = r.extent();																						this->move_to_origin();																						if (right() < bottom()) {																							const float aspect = right() / bottom();																							right() = aspect * r.height();																							bottom() = r.height();																							*this += vector_t(r.left() + ((r.width() - right()) / 2), r.top());																						} else {																							const float aspect = bottom() / bottom();																							bottom() = aspect * r.width();																							right() = r.width();																							*this += vector_t(r.left(), r.top() + ((r.height() - bottom()) / 2));																						}																						return *this;																					}template<class T2>	this_t				scaled_to(const rectangle<T2> &r) const		{ this_t rs = *this; rs.scale_to(r); return rs; }protected:					point_t				left_top_, right_bottom_;};template<class VTraits> class rectangle<rectangle_traits_implicit<VTraits> > {public:				typedef rectangle_traits_implicit<VTraits>	traits_t;				typedef traits_t::scalar_t					scalar_t;				typedef rectangle<traits_t>					this_t;				typedef traits_t::point_t					point_t;				typedef traits_t::vector_t					vector_t;														rectangle(void)								: origin_(), extent_() {}										rectangle(const this_t &r)					: origin_(r.origin_), extent_(r.extent_) {}template<class T2>						rectangle(const rectangle<T2> &r)			: origin_(r.left_top()), extent_(r.extent()) {}template<class T2, class T3>			rectangle(const point<T2> &p1, const point<T3> &p2)																					: origin_(p1), extent_(p2-p1) {}template<class T2, class T3>			rectangle(const point<T2> &p, const vector<T3> &v)																					: origin_(p), extent_(v) {}template<class T3>						rectangle(const vector<T3> &v)				: origin_(0,0), extent_(v) {}													this_t&				operator= (const this_t &r)					{ origin_ = r.origin_; extent_ = r.extent_; return *this; }template<class T2>	this_t&				operator= (const rectangle<T2> &r)			{ origin_ = r.left_top(); extent_ = r.extent(); return *this; }									bool				operator==(const this_t &r) const			{ return (origin_ == r.origin_) && (extent_ == r.extent_); }					bool				operator!=(const this_t &r) const			{ return (origin_ != r.origin_) || (extent_ != r.extent_); }template<class T2>	bool				operator==(const rectangle<T2> &r) const	{ return (origin_ == r.left_top()) && (extent_ == r.extent()); }template<class T2>	bool				operator!=(const rectangle<T2> &r) const	{ return (origin_ != r.left_top()) || (extent_ != r.extent()); }					bool				is_empty(void) const						{ return (height() == 0 || width() == 0); }template<class T2>	bool				contains(const point<T2> &p) const			{ return (colorfield::between(p.x(), left(), right()) && colorfield::between(p.y(), top(), bottom())); }template<class T2>	bool				intersects(const rectangle<T2> &r) const	{																					  using colorfield::between;																					  return ((between(left(), r.left(), r.right()) || between(right() , r.left(), r.right())) &&																						      (between(top() , r.top(), r.bottom()) || between(bottom(), r.top(), r.bottom()))) ||																						     ((between(r.left(), left(), right()) || between(r.right() , left(), right())) &&																						      (between(r.top() , top(), bottom()) || between(r.bottom(), top(), bottom())));																					}														operator       scalar_t*(void)				{ return (      scalar_t*) this; }										operator const scalar_t*(void) const		{ return (const scalar_t*) this; }										operator       point_t*(void)				{ return (      point_t*) this; }										operator const point_t*(void) const			{ return (const point_t*) this; }					scalar_t&			left(void)									{ return origin_.x(); }			  const scalar_t&			left(void) const							{ return origin_.x(); }			  const scalar_t			right(void) const							{ return origin_.x() + extent_.x(); }					scalar_t&			top(void)									{ return origin_.y(); }			  const scalar_t&			top(void) const								{ return origin_.y(); }			  const scalar_t			bottom(void) const							{ return origin_.y() + extent_.y(); }			  			  		point_t&			origin(void)								{ return origin_; }			  const point_t&			origin(void) const							{ return origin_; }					vector_t&			extent(void) 								{ return extent_; }			  const vector_t&			extent(void) const							{ return extent_; }					scalar_t&			width(void) 								{ return extent_.x(); }			  const scalar_t&			width(void) const							{ return extent_.x(); }					scalar_t&			height(void) 								{ return extent_.y(); }			  const scalar_t&			height(void) const							{ return extent_.y(); }					point_t&			left_top(void)								{ return origin_; }			  const point_t&			left_top(void) const						{ return origin_; }			  const point_t				right_bottom(void) const					{ return origin_ + extent_; }					point_t				right_top(void) const						{ return point_t(right(), top()); }					point_t				left_bottom(void) const						{ return point_t(left(), bottom()); }template<class T2>	this_t&				move_to(const point<T2> &p)					{ origin_ = p; return *this; }					this_t&				move_to_origin(void)						{ origin_ = 0; return *this; }template<class T2>	this_t&				move_by(const vector<T2> &delta)			{ origin_ += delta; return *this; }template<class T2>	this_t&				resize(const vector<T2> &new_extent)		{ extent_ = new_extent; return *this; }					this_t&				set_empty(void)								{ extent_ = 0; return *this; }									this_t				inset(scalar_t k) const						{ return this_t(origin_ + k, extent_ - (2 * k)); }					this_t				outset(scalar_t k) const					{ return this_t(origin_ - k, extent_ + (2 * k)); }template<class T2>	this_t				inset(const vector<T2> &p) const			{ return this_t(origin_ + p, extent_ - (2 * p)); }template<class T2>	this_t				outset(const vector<T2> &p) const			{ return this_t(origin_ - p, extent_ + (2 * p)); }					this_t				operator* (scalar_t k) const				{ return this_t(origin_ * k, extent_ * k); }					this_t				operator/ (scalar_t k) const				{ return this_t(origin_ / k, extent_ / k); }				template<class T2>	this_t				operator+ (const vector<T2> &p) const		{ return this_t(origin_ + p, extent_); }template<class T2>	this_t				operator- (const vector<T2> &p) const		{ return this_t(origin_ - p, extent_); }template<class T2>	this_t				operator| (const rectangle<T2> &r) const	{ return this_t(min(left(),r.left()), min(top(),r.top()), max(right(),r.right()), max(bottom(),r.bottom())); }template<class T2>	this_t				operator& (const rectangle<T2> &r) const	{																						rectangle overlap(std::max(left(),r.left()), std::max(top(),r.top()), 																										  std::min(right(),r.right()), std::min(bottom(),r.bottom()));																						if (overlap.left() > overlap.right())																							overlap.left() = overlap.right();																						if (overlap.top() > overlap.bottom())																							overlap.top() = overlap.bottom();																						return overlap;																					}template<class T2>	this_t&				operator+=(const vector<T2> &p)				{ origin_ += p; return *this; }template<class T2>	this_t&				operator-=(const vector<T2> &p)				{ origin_ -= p; return *this; }template<class T2>	this_t&				operator|=(const rectangle<T2> &r)			{ left() = min(left(),r.left()); top() = min(top(),r.top()); right() = max(right(),r.right()); bottom() = max(bottom(),r.bottom()); return *this; }template<class T2>	this_t&				operator&=(const rectangle<T2> &r)			{																					  const rectangle<T1> ri = (*this) & r;																					  *this = ri;																					}				template<class T2>	this_t&				pin_by(const rectangle<T2> &r)				{																						vector_t delta(0,0);																						if (this->width() <= r.width()) {																							if (left() < r.left()) {																								delta.x() = r.left() - left();																							} else if (right() > r.right()) {																								delta.x() = r.right() - right();																							}																						}																						if (this->height() <= r.height()) {																							if (top() < r.top()) {																								delta.y() = r.top() - top();																							} else if (bottom() > r.bottom()) {																								delta.y() = r.bottom() - bottom();																							}																						}																						*this += delta;																						return *this;																  																					}protected:					point_t				origin_;					vector_t			extent_;};template<class VTraits> class line<line_traits_explicit<VTraits> > {public:			typedef line_traits_explicit<VTraits>			traits_t;			typedef line<traits_t>							this_t;			typedef vector<VTraits>							vector_t;			typedef vector_t::scalar_t						scalar_t;			typedef vector_t::point_t						point_t;			typedef line<line_traits_implicit<VTraits> >	implicit_t;										line(void)					{}										line(const point_t &pt, const vector_t &v)																			: origin_(pt), tangent_(v) {}										line(const point_t &pt1, const point_t &pt2)																			: origin_(pt1), tangent_(vector_t(pt2-pt1).normalized()) {}explicit								line(const implicit_t &ln)	: origin_(ln.origin()), tangent_(ln.tangent()) {}										line(const this_t &ln)		: origin_(ln.origin_), tangent_(ln.tangent_) {}										this_t&				operator= (const this_t &ln)																			{ origin_ = ln.origin_; tangent_ = ln.tangent_; return *this; }					this_t&				operator= (const implicit_t &ln)																			{ origin_ = ln.origin(); tangent_ = ln.tangent(); return *this; }										bool				operator==(const this_t &ln) const																			{ return ((origin_ == ln.origin_) && (tangent_ == ln.tangent_)); }					bool				operator==(const implicit_t &ln) const																			{ return ((origin_ == ln.origin()) && (tangent_ == ln.tangent())); }					bool				operator!=(const this_t &ln) const																			{ return ((origin_ != ln.origin_) || (tangent_ != ln.tangent_)); }					bool				operator!=(const implicit_t &ln) const																			{ return ((origin_ != ln.origin()) || (tangent_ != ln.tangent())); }										point_t				operator()(const scalar_t &u) const																			{ return origin_ + (tangent_ * u); }					this_t				operator+ (const vector_t &v) const																			{ return this_t(origin_ + v, tangent_); }					this_t				operator- (const vector_t &v) const																			{ return this_t(origin_ - v, tangent_); }					this_t&				operator+=(const vector_t &v)																			{ origin_ += v; return *this; }					this_t&				operator-=(const vector_t &v)																			{ origin_ -= v; return *this; }										point_t				origin(void) const			{ return origin_; }					vector_t			tangent(void) const			{ return tangent_; }					vector_t			normal(void) const			{ return tangent_.ccw_perpendicular(); }					scalar_t			distance(void) const		 { return origin_.length(); }					scalar_t			angle(void) const		 	{ return tangent_.angle(); }friend			std::ostream&			operator<<(std::ostream &os, const this_t &ln)			{ return (os << '[' << ln.origin() << ' ' << ln.tangent() << ']'); }protected:					point_t				origin_;					vector_t			tangent_;};template<class VTraits> class line<line_traits_implicit<VTraits> > {public:			typedef line_traits_implicit<VTraits>	traits_t;			typedef line<traits_t>					this_t;			typedef vector<VTraits>					vector_t;			typedef vector_t::scalar_t				scalar_t;			typedef vector_t::point_t				point_t;			typedef line<line_traits_explicit<VTraits> >	explicit_t;										line(void)					{}										line(const point_t &p1, const point_t &p2)																			: normal_(vector_t(p2-p1).normalized().cw_perpendicular()), 																	  distance_(dot(normal_,p1)) {}										line(const point_t &p, const vector_t &t)																			: normal_(t.ccw_perpendicular()), distance_(p.length()) {}										line(const vector_t &n, const scalar_t &d)																			: normal_(n), distance_(d) {}explicit								line(const explicit_t &ln)	: normal_(ln.normal()), distance_(ln.distance()) {}										line(const this_t &ln)		: normal_(ln.normal_), distance_(ln.distance_) {}					this_t&				operator= (const this_t &ln)																			{ normal_ = ln.normal_; distance_ = ln.distance_; return *this; }					this_t&				operator= (const explicit_t &ln)																			{ normal_ = ln.normal(); distance_ = ln.distance(); return *this; }										bool				operator==(const this_t &ln) const																			{ return ((normal_ == ln.normal_) && (distance_ == ln.distance_)); }					bool				operator==(const explicit_t &ln) const																			{ return ((normal_ == ln.normal()) && (distance_ == ln.distance())); }					bool				operator!=(const this_t &ln) const																			{ return ((normal_ != ln.normal_) || (distance_ != ln.distance_)); }					bool				operator!=(const explicit_t &ln) const																			{ return ((normal_ != ln.normal()) || (distance_ != ln.distance())); }										point_t				origin(void) const			{ return point_t(normal_ * distance_); }					vector_t			tangent(void) const			{ return normal_.cw_perpendicular(); }					vector_t			normal(void) const			{ return normal_; }					scalar_t			distance(void) const		{ return distance_; }friend 				point_t				operator&&(const this_t &ln1, const explicit_t &ln2)																	{																		const double_t n = dot(ln1.normal(), ln2.origin()) - ln1.distance(),																					   d = dot(ln1.normal(), ln2.tangent()),																					   t = n / d;																		return ln2.origin() - (ln2.tangent() * static_cast<scalar_t>(t));																	}friend			std::ostream&			operator<<(std::ostream &os, const this_t &ln)			{ return (os << '[' << ln.normal() << ' ' << ln.distance() << ']'); }protected:					vector_t			normal_;					scalar_t			distance_;};template<class VTraits>std::ostream& operator<<(std::ostream& s, const rectangle<VTraits>& r){	return s << '[' << r.left() << ", " << r.top() << ", " << r.right() << ", " << r.bottom() << ']';}template<class VTraits>std::ostream& operator<<(std::ostream& s, const vector<VTraits>& v){	return s << '[' << v.x() << ", " << v.y() << ']';}#if DEBUGnamespace {	// compile-time testing		template class vector<vector_traits_topleft<float> >;	template class vector<vector_traits_lefttop<float> >;	template class point<vector_traits_topleft<float> >;	template class point<vector_traits_lefttop<float> >;#if 0	template class detail::base_rect<rectangle_traits_explicit<vector_traits_topleft<float> > >;	template class detail::base_rect<rectangle_traits_explicit<vector_traits_lefttop<float> > >;#endif	template class rectangle<rectangle_traits_explicit<vector_traits_topleft<float> > >;	template class rectangle<rectangle_traits_explicit<vector_traits_lefttop<float> > >;	template class line<line_traits_explicit<vector_traits_lefttop<float> > >;	template class line<line_traits_explicit<vector_traits_topleft<float> > >;} // anonymous#endif /* DEBUG */} // namespace cf_geo2d#endif /* __GEO2D_H */