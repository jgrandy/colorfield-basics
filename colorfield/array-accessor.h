/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#include "colorfield.h"#include "index.h"namespace colorfield {// *** templatize operator() args (index_t or cindex<>)template<typename Scalar = float, typename X1 = index_t, typename X2 = index_t>class array2 {public:			typedef Scalar scalar_t;			typedef X1 x1_t;			typedef X2 x2_t;									array2(      scalar_t *store, x1_t x1n, x2_t x2n)							: store_(store), x1n_(x1n), x2n_(x2n) {}						array2(const scalar_t *store, x1_t x1n, x2_t x2n)							: store_(const_cast<scalar_t*>(store)), x1n_(x1n), x2n_(x2n) {}						operator       scalar_t*(void)				{ return store_; }						operator const scalar_t*(void) const		{ return store_; }									scalar_t&	operator()(index_t x1i, index_t x2i)										{ return *(store_ + x2n_ * x1i + x2i); }template<typename T1, typename T2>			scalar_t&	operator()(T1 x1i, T2 x2i)							{ return *(store_ + x2n_ * x1i + x2i); }	  const scalar_t &	operator()(index_t x1i, index_t x2i) const		  						{ return *(store_  + x2n_ * x1i + x2i); }template<typename T1, typename T2>	  const scalar_t&	operator()(T1 x1i, T2 x2i) const							{ return *(store_ + x2n_ * x1i + x2i); }			scalar_t*	store_;			x1_t		x1n_;			x2_t		x2n_;};template<typename Scalar = float, typename X1 = index_t, typename X2 = index_t, typename X3 = index_t>class array3 {public:			typedef Scalar scalar_t;			typedef X1 x1_t;			typedef X2 x2_t;			typedef X3 x3_t;									array3(      scalar_t *store, x1_t x1n, x2_t x2n, x3_t x3n)							: store_(store), x1n_(x1n), x2n_(x2n), x3n_(x3n) {}						array3(const scalar_t *store, x1_t x1n, x2_t x2n, x3_t x3n)							: store_(const_cast<scalar_t*>(store)), x1n_(x1n), x2n_(x2n), x3n_(x3n) {}													operator       scalar_t*(void)				{ return store_; }						operator const scalar_t*(void) const		{ return store_; }									scalar_t&	operator()(index_t x1i, index_t x2i, index_t x3i)										{ return *(store_ + x3n_ * (x2n_ * x1i + x2i) + x3i); }	  const scalar_t &	operator()(index_t x1i, index_t x2i, index_t x3i) const			  						{ return *(store_ + x3n_ * (x2n_ * x1i + x2i) + x3i); }			scalar_t*	store_;			x1_t		x1n_;			x2_t		x2n_;			x3_t		x3n_;};template<typename Scalar = float, typename X1 = index_t, typename X2 = index_t, typename X3 = index_t, typename X4 = index_t>class array4 {public:			typedef Scalar scalar_t;			typedef X1 x1_t;			typedef X2 x2_t;			typedef X3 x3_t;			typedef X4 x4_t;									array4(      scalar_t *store, x1_t x1n, x2_t x2n, x3_t x3n, x4_t x4n)							: store_(store), x1n_(x1n), x2n_(x2n), x3n_(x3n), x4n_(x4n) {}						array4(const scalar_t *store, x1_t x1n, x2_t x2n, x3_t x3n, x4_t x4n)							: store_(const_cast<scalar_t*>(store)), x1n_(x1n), x2n_(x2n), x3n_(x3n), x4n_(x4n) {}													operator       scalar_t*(void)				{ return store_; }						operator const scalar_t*(void) const		{ return store_; }									scalar_t&	operator()(index_t x1i, index_t x2i, index_t x3i, index_t x4i)										{ return *(store_ + x4n_ * (x3n_ * (x2n_ * x1i + x2i) + x3i) + x4i); }	  const scalar_t &	operator()(index_t x1i, index_t x2i, index_t x3i, index_t x4i) const		  						{ return *(store_ + x4n_ * (x3n_ * (x2n_ * x1i + x2i) + x3i) + x4i); }template<typename T1, typename T2, typename T3, typename T4>			scalar_t&	operator()(T1 x1i, T2 x2i, T3 x3i, T4 x4i)							{ return *(store_ + x4n_ * (x3n_ * (x2n_ * x1i + x2i) + x3i) + x4i); }template<typename T1, typename T2, typename T3, typename T4>	  const scalar_t&	operator()(T1 x1i, T2 x2i, T3 x3i, T4 x4i) const							{ return *(store_ + x4n_ * (x3n_ * (x2n_ * x1i + x2i) + x3i) + x4i); }			scalar_t*	store_;			x1_t		x1n_;			x2_t		x2n_;			x3_t		x3n_;			x4_t		x4n_;};template<typename Scalar = float, typename X1 = index_t, typename X2 = index_t, typename X3 = index_t, typename X4 = index_t>class array4f {public:			typedef Scalar scalar_t;			typedef X1 x1_t;			typedef X2 x2_t;			typedef X3 x3_t;			typedef X4 x4_t;									array4f(      scalar_t *store, x1_t x1n, x2_t x2n, x3_t x3n, x4_t x4n)							: store_(store), x1n_(x1n), x2n_(x2n), x3n_(x3n), x4n_(x4n) {}						array4f(const scalar_t *store, x1_t x1n, x2_t x2n, x3_t x3n, x4_t x4n)							: store_(const_cast<scalar_t*>(store)), x1n_(x1n), x2n_(x2n), x3n_(x3n), x4n_(x4n) {}													operator       scalar_t*(void)				{ return store_; }						operator const scalar_t*(void) const		{ return store_; }									scalar_t&	operator()(index_t x1i, index_t x2i, index_t x3i, index_t x4i)							{ return store_[x1i + (x2i + (x3i + x4i * x3n_) * x2n_) * x1n_]; }	  const scalar_t &	operator()(index_t x1i, index_t x2i, index_t x3i, index_t x4i) const								{ return store_[x1i + (x2i + (x3i + x4i * x3n_) * x2n_) * x1n_]; }	template<typename T1, typename T2, typename T3, typename T4>			scalar_t&	operator()(T1 &x1i, T2 &x2i, T3 &x3i, T4 &x4i)							{ return store_[x1i + (x2i + (x3i + x4i * x3n_) * x2n_) * x1n_]; }	template<typename T1, typename T2, typename T3, typename T4>	  const scalar_t&	operator()(T1 &x1i, T2 &x2i, T3 &x3i, T4 &x4i) const							{ return store_[x1i + (x2i + (x3i + x4i * x3n_) * x2n_) * x1n_]; }				scalar_t*	store_;			x1_t		x1n_;			x2_t		x2n_;			x3_t		x3n_;			x4_t		x4n_;};template<typename Scalar = float, typename X1 = index_t, typename X2 = index_t, typename X3 = index_t, typename X4 = index_t, typename X5 = index_t>class array5 {public:			typedef Scalar scalar_t;			typedef X1 x1_t;			typedef X2 x2_t;			typedef X3 x3_t;			typedef X4 x4_t;			typedef X5 x5_t;									array5(      scalar_t *store, x1_t x1n, x2_t x2n, x3_t x3n, x4_t x4n, x5_t x5n)							: store_(store), x1n_(x1n), x2n_(x2n), x3n_(x3n), x4n_(x4n), x5n_(x5n) {}						array5(const scalar_t *store, x1_t x1n, x2_t x2n, x3_t x3n, x4_t x4n, x5_t x5n)							: store_(const_cast<scalar_t*>(store)), x1n_(x1n), x2n_(x2n), x3n_(x3n), x4n_(x4n), x5n_(x5n) {}													operator       scalar_t*(void)				{ return store_; }						operator const scalar_t*(void) const		{ return store_; }									scalar_t&	operator()(index_t x1i, index_t x2i, index_t x3i, index_t x4i, index_t x5i)										{ return *(store_ + x5n_ * (x4n_ * (x3n_ * (x2n_ * x1i + x2i) + x3i) + x4i) + x5i); }	  const scalar_t &	operator()(index_t x1i, index_t x2i, index_t x3i, index_t x4i, index_t x5i) const		  						{ return *(store_ + x5n_ * (x4n_ * (x3n_ * (x2n_ * x1i + x2i) + x3i) + x4i) + x5i); }template<typename T1, typename T2, typename T3, typename T4, typename T5>			scalar_t&	operator()(T1 x1i, T2 x2i, T3 x3i, T4 x4i, T5 x5i)							{ return *(store_ + x5n_ * (x4n_ * (x3n_ * (x2n_ * x1i + x2i) + x3i) + x4i) + x5i); }template<typename T1, typename T2, typename T3, typename T4, typename T5>	  const scalar_t&	operator()(T1 x1i, T2 x2i, T3 x3i, T4 x4i, T5 x5i) const							{ return *(store_ + x5n_ * (x4n_ * (x3n_ * (x2n_ * x1i + x2i) + x3i) + x4i) + x5i); }			scalar_t*	store_;			x1_t		x1n_;			x2_t		x2n_;			x3_t		x3n_;			x4_t		x4n_;			x5_t		x5n_;};template<typename Scalar = float, typename X1 = index_t, typename X2 = index_t, typename X3 = index_t, typename X4 = index_t, typename X5 = index_t, typename X6 = index_t>class array6 {public:			typedef Scalar scalar_t;			typedef X1 x1_t;			typedef X2 x2_t;			typedef X3 x3_t;			typedef X4 x4_t;			typedef X5 x5_t;			typedef X6 x6_t;									array6(      scalar_t *store, x1_t x1n, x2_t x2n, x3_t x3n, x4_t x4n, x5_t x5n, x6_t x6n)							: store_(store), x1n_(x1n), x2n_(x2n), x3n_(x3n), x4n_(x4n), x5n_(x5n), x6n_(x6n) {}						array6(const scalar_t *store, x1_t x1n, x2_t x2n, x3_t x3n, x4_t x4n, x5_t x5n, x6_t x6n)							: store_(const_cast<scalar_t*>(store)), x1n_(x1n), x2n_(x2n), x3n_(x3n), x4n_(x4n), x5n_(x5n), x6n_(x6n) {}													operator       scalar_t*(void)				{ return store_; }						operator const scalar_t*(void) const		{ return store_; }									scalar_t&	operator()(index_t x1i, index_t x2i, index_t x3i, index_t x4i, index_t x5i, index_t x6i)										{ return *(store_ + x6n_ * (x5n_ * (x4n_ * (x3n_ * (x2n_ * x1i + x2i) + x3i) + x4i) + x5i) + x6i); }	  const scalar_t &	operator()(index_t x1i, index_t x2i, index_t x3i, index_t x4i, index_t x5i, index_t x6i) const		  						{ return *(store_ + x6n_ * (x5n_ * (x4n_ * (x3n_ * (x2n_ * x1i + x2i) + x3i) + x4i) + x5i) + x6i); }			scalar_t*	store_;			x1_t		x1n_;			x2_t		x2n_;			x3_t		x3n_;			x4_t		x4n_;			x5_t		x5n_;			x6_t		x6n_;};} // namespace colorfield