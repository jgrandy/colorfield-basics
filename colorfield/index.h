/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __CINDEX_H#define __CINDEX_H#include "colorfield.h"#include <iostream>namespace colorfield {#if ! CF_HAS_MEMBER_TEMPLATES#error "cindex requires member templates"#endif#if ! CF_HAS_CLASS_TEMPLATE_PARTIAL_SPECIALIZATION#error "cindex requires partial template specialization"#endiftypedef std::uint16_t index_t;/*1.					2.					3.*/template<index_t M> class cindex {	// Implementation notes:	//	// In CWPro3+, the compiler generates default copy constructors which cause spurious	// stack manipulations to be generated (and not optimized out). The copy constructors	// here, doing nothing, are therefore critical for good performance.public:			typedef cindex<M>				this_t;	  		typedef cindex<(index_t)(M-1)>	dec_t;	  		typedef cindex<(index_t)(M+1)>	inc_t;										cindex(void)								{}										cindex(const this_t &)						{}													  const this_t&				operator= (const this_t&) const				{ return *this; }										operator index_t(void) const				{ return M; }};template<> class cindex<0> {	// specialization w/o a typedef for dec_t, since cindex isn't supposed to go negativepublic:			typedef cindex<0>			this_t;	  		typedef cindex<1>			inc_t;										cindex(void)								{}										cindex(const this_t &)						{}													  const this_t&				operator= (const this_t&) const				{ return *this; }										operator index_t(void) const				{ return 0; }};typedef cindex<0>	zero_t;		const zero_t zero;typedef cindex<1>	one_t;		const one_t one;typedef cindex<2>	two_t;		const two_t two;typedef cindex<3>	three_t;	const three_t three;typedef cindex<4>	four_t;		const four_t four;typedef cindex<5>	five_t;		const five_t five;	typedef cindex<6>	six_t;		const six_t six;	typedef cindex<7>	seven_t;	const seven_t seven;	typedef cindex<8>	eight_t;	const eight_t eight;	typedef cindex<9>	nine_t;		const nine_t nine;	// don't bother with mixed index_t/cindex versions of the operators below,// since they would be the same as coercing the cindex parameter and calling the// default operators already defined over index_t.template<index_t M, index_t N> inline bool			operator==(const cindex<M>, const cindex<N>)	{ return (M == N); }template<index_t M, index_t N> inline bool			operator!=(const cindex<M>, const cindex<N>)	{ return (M != N); }template<index_t M, index_t N> inline bool			operator< (const cindex<M>, const cindex<N>)	{ return (M <  N); }template<index_t M, index_t N> inline bool			operator<=(const cindex<M>, const cindex<N>)	{ return (M <= N); }template<index_t M, index_t N> inline bool			operator> (const cindex<M>, const cindex<N>)	{ return (M >  N); }template<index_t M, index_t N> inline bool			operator>=(const cindex<M>, const cindex<N>)	{ return (M >= N); }    // TODO: add max & min (if possible)    template<index_t M, index_t N> inline cindex<M+N>	operator+ (const cindex<M>, const cindex<N>)	{ return cindex<M+N>(); }template<index_t M, index_t N> inline cindex<M-N>	operator- (const cindex<M>, const cindex<N>)	{ return cindex<M-N>(); }template<index_t M, index_t N> inline cindex<M*N>	operator* (const cindex<M>, const cindex<N>)	{ return cindex<M*N>(); }template<index_t M, index_t N> inline cindex<M/N>	operator/ (const cindex<M>, const cindex<N>)	{ return cindex<M/N>(); }template<index_t M, index_t N> inline cindex<M%N>	operator% (const cindex<M>, const cindex<N>)	{ return cindex<M%N>(); }#pragma mark operator<<template<index_t N>inline std::ostream &operator<<(std::ostream &os, const cindex<N> &){	os << "[" << N << "]";	return os;}  		#pragma mark traitstemplate<class T1, class T2> class index_traits {};template<> class index_traits<index_t, index_t> {public:			typedef index_t				sum_t;																				typedef index_t				diff_t;																				typedef std::uint32_t		prod_t;																				typedef index_t				max_t;																				typedef index_t				min_t;};template<> class index_traits<std::uint32_t, std::uint32_t> {public:			typedef std::uint32_t		sum_t;																				typedef std::uint32_t		diff_t;																				typedef std::uint32_t		prod_t;																				typedef std::uint32_t		max_t;																				typedef std::uint32_t		min_t;};template<> class index_traits<index_t, std::uint32_t> {public:			typedef std::uint32_t		sum_t;																				typedef std::uint32_t		diff_t;																				typedef std::uint32_t		prod_t;																				typedef std::uint32_t		max_t;																				typedef std::uint32_t		min_t;};template<> class index_traits<std::uint32_t, index_t> {public:			typedef std::uint32_t		sum_t;																				typedef std::uint32_t		diff_t;																				typedef std::uint32_t		prod_t;																				typedef std::uint32_t		max_t;																				typedef std::uint32_t		min_t;};template<index_t M, index_t N> class index_traits<cindex<M>, cindex<N> > {public:																	typedef cindex<(index_t)(M+N)>	sum_t;			typedef cindex<(index_t)(M-N)>	diff_t;			typedef cindex<(index_t)(M*N)>	prod_t;			typedef cindex<(M<N)?M:N>		min_t;			typedef cindex<(N<M)?M:N>		max_t;friend inline		min_t				min(const cindex<M>, const cindex<N>)			{ return min_t(); }friend inline		max_t				max(const cindex<M>, const cindex<N>)			{ return max_t(); }};template<index_t M> class index_traits<cindex<M>, index_t> {public:				typedef index_t				sum_t;			typedef index_t				diff_t;			typedef std::uint32_t		prod_t;			typedef index_t				max_t;			typedef index_t				min_t;};template<index_t N> class index_traits<index_t, cindex<N> > {public:				typedef index_t				sum_t;			typedef index_t				diff_t;			typedef std::uint32_t		prod_t;			typedef index_t				max_t;			typedef index_t				min_t;};template<index_t N,		 index_t I0=0, index_t I1=1, index_t I2=2, index_t I3=3, 		 index_t I4=4, index_t I5=5, index_t I6=6, index_t I7=7>struct reordering {				// compile-time access to reordering				#if 0			template<index_t I> struct mapping {};			template<> struct mapping<0> { enum { dest = I0 }; };			template<> struct mapping<1> { enum { dest = I1 }; };			template<> struct mapping<2> { enum { dest = I2 }; };			template<> struct mapping<3> { enum { dest = I3 }; };			template<> struct mapping<4> { enum { dest = I4 }; };			template<> struct mapping<5> { enum { dest = I5 }; };			template<> struct mapping<6> { enum { dest = I6 }; };			template<> struct mapping<7> { enum { dest = I7 }; };			template<typename R2> struct binary_reordering_traits {						typedef reordering<N,										   mapping<R2::mapping<0>::dest>::dest,										   mapping<R2::mapping<1>::dest>::dest,										   mapping<R2::mapping<2>::dest>::dest,										   mapping<R2::mapping<3>::dest>::dest,										   mapping<R2::mapping<4>::dest>::dest,										   mapping<R2::mapping<5>::dest>::dest,										   mapping<R2::mapping<6>::dest>::dest,										   mapping<R2::mapping<7>::dest>::dest> collapsed;			};#endif				// run-time access to reordering							typedef cindex<I0>			index0;			typedef cindex<I1>			index1;			typedef cindex<I2>			index2;			typedef cindex<I3>			index3;			typedef cindex<I4>			index4;			typedef cindex<I5>			index5;			typedef cindex<I6>			index6;			typedef cindex<I7>			index7;static		  const index_t				coords_ = N;			static				index0				reorder(zero_t )			{ return index0(); }static				index1				reorder(one_t  )			{ return index1(); }static				index2				reorder(two_t  )			{ return index2(); }static				index3				reorder(three_t)			{ return index3(); }static				index4				reorder(four_t )			{ return index4(); }static				index5				reorder(five_t )			{ return index5(); }static				index6				reorder(six_t  )			{ return index6(); }static				index7				reorder(seven_t)			{ return index7(); }static				index_t				reorder(index_t i)			{ static const index_t sw[8] = { I0, I1, I2, I3, I4, I5, I6, I7 }; return sw[i]; }};} /* namespace colorfield */#endif /* __CINDEX_H */