/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 2000 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef STATIC_VECTOR_FUNCTION_H#define STATIC_VECTOR_FUNCTION_H#include "colorfield.h"namespace static_vf {typedef std::uint16_t index_t;/*1.				2.				3.*/template<typename DT, index_t DN, typename RT, index_t RN> class svf_traits;template<typename DT, typename RT> class svf_traits<DT,3,RT,3>{public:		typedef DT				domain_t;		typedef RT				range_t;		 enum { domain_arity = 3, range_arity = 3 };		typedef void (*signature_t)(const domain_t &u, const domain_t &v, const domain_t &w,										   range_t &x,        range_t &y,        range_t &z);};template<typename DT, index_t DN, typename RT,  index_t RN>  class pf_vf;template<typename DT, index_t DN, typename RT,  index_t RN>  class identity_vf;template<typename DT, index_t DN, typename MT, typename RT,  index_t RN>  class linear_transform_vf;template<typename DT, index_t DN, typename G, typename IT,  index_t IN, typename F, typename RT,  index_t> class composite_vf;template<typename DT, index_t DN, typename F, typename RT,  index_t RN>  class vf_wrapper;template<typename DT, typename RT> class pf_vf<DT,3,RT,3> {public:		typedef pf_vf<DT,3,RT,3>	this_t;		typedef svf_traits<DT,3,RT,3>	traits_t;		typedef DT				domain_t;		typedef RT				range_t;		 enum { domain_arity = 3, range_arity = 3 };		typedef void 			(*pf_t)(const domain_t &u, const domain_t &v, const domain_t &w,											  range_t &x,        range_t &y,        range_t &z);								pf_vf(pf_t pf)	: pf_(pf) {}																operator pf_t(void) const		{ return pf_; }				void			operator()(const domain_t &u, const domain_t &v, const domain_t &w,												  range_t &x,        range_t &y,        range_t &z) const								{									(*pf_)(u,v,w, x,y,z);								}template<typename DT2, index_t DN2, class G>composite_vf<DT2,DN2,G,domain_t,domain_arity,this_t,range_t,range_arity>									operator+ (const vf_wrapper<DT2,DN2,G,domain_t,domain_arity> &g) const								{ return composite_vf<DT2,DN2,G,domain_t,domain_arity,this_t,range_t,range_arity>(reinterpret_cast<const G&>(g), *this); }template<typename DT2, index_t DN2>composite_vf<DT2,DN2,pf_vf<DT2,DN2,domain_t,domain_arity>,domain_t,domain_arity,this_t,range_t,range_arity>									operator+ (const pf_vf<DT2,DN2,domain_t,domain_arity> &g) const								{ return composite_vf<DT2,DN2,pf_vf<DT2,DN2,domain_t,domain_arity>,domain_t,domain_arity,this_t,range_t,range_arity>(g, *this); }private:				pf_t			pf_;};template<typename DT, typename RT> class identity_vf<DT,3,RT,3> {public:		typedef DT				domain_t;		typedef RT				range_t;		 enum { domain_arity = 3, range_arity = 3 };								identity_vf(void)	{}												void			operator()(const domain_t &u, const domain_t &v, const domain_t &w,												  range_t &x,        range_t &y,        range_t &z) const								{									x = u; y = v; z = w;								}};template<typename DT, typename MT, typename RT> class linear_transform_vf<DT,3,MT,RT,3> {public:		typedef DT				domain_t;		typedef MT				scalar_t;		typedef RT				range_t;		 enum { domain_arity = 3, range_arity = 3 };								linear_transform_vf(const scalar_t *mat) : mat_(mat) {}												void			operator()(const domain_t &u, const domain_t &v, const domain_t &w,												  range_t &x,        range_t &y,        range_t &z) const								{									x = mat_[0] * u + mat_[1] * v + mat_[2] * w;									y = mat_[3] * u + mat_[4] * v + mat_[5] * w;									z = mat_[6] * u + mat_[7] * v + mat_[8] * w;								}private:		  const scalar_t*		mat_;};template<typename DT, typename MT, typename RT>inline void linear_transform(const DT &u, const DT &v, const DT &w,							 const MT *mat,							       RT &x,       RT &y,       RT &z){	linear_transform_vf<DT,3,MT,RT,3> xform(mat);	xform(u,v,w, x,y,z);}template inline void linear_transform<float,double,float>(const float &, const float &, const float &, const double*, float&, float&, float&);template<typename DT, typename F, typename IT, typename G, typename RT> class composite_vf<DT,3,F,IT,3,G,RT,3> {public:		typedef composite_vf<DT,3,F,IT,3,G,RT,3>	this_t;		typedef DT				domain_t;		typedef IT				temp_t;		typedef RT				range_t;		 enum { domain_arity = 3, range_arity = 3 };								composite_vf(F f, G g)  : f_(f), g_(g) {}				void			operator()(const domain_t &u, const domain_t &v, const domain_t &w,												  range_t &x,        range_t &y,        range_t &z) const								{									temp_t a, b, c;									f_(u,v,w, a,b,c);									g_(a,b,c, x,y,z);								}template<typename DT2, index_t DN2, class G>composite_vf<DT2,DN2,G,domain_t,domain_arity,this_t,range_t,range_arity>									operator+ (const vf_wrapper<DT2,DN2,G,domain_t,domain_arity> &g) const								{ return composite_vf<DT2,DN2,G,domain_t,domain_arity,this_t,range_t,range_arity>(reinterpret_cast<const G&>(g), *this); }template<typename DT2, index_t DN2> composite_vf<DT2,DN2,void(*)(const DT2&,const DT2&, const DT2&, domain_t&,domain_t&,domain_t&),domain_t,domain_arity,this_t,range_t,range_arity>								operator+ (const pf_vf<DT2,DN2,domain_t,domain_arity> &g) const								{ return composite_vf<DT2,DN2,void(*)(const DT2&,const DT2&, const DT2&, domain_t&,domain_t&,domain_t&),domain_t,domain_arity,this_t,range_t,range_arity>(g, *this); }private:				F				f_;				G				g_;};template<typename DT, class F, typename RT> class vf_wrapper<DT,3,F,RT,3> {public:		typedef vf_wrapper<DT,3,F,RT,3>	this_t;		typedef DT				domain_t;		typedef RT				range_t;		 enum { domain_arity = 3, range_arity = 3 };								 								vf_wrapper(const F &f)	: f_(f) {}								operator const F&(void) const		{ return f_; }												void			operator()(const domain_t &u, const domain_t &v, const domain_t &w,												  range_t &x,        range_t &y,        range_t &z)								{ f_(u,v,w,x,y,z); }template<typename DT2, index_t DN2, class G> composite_vf<DT2,DN2,G,domain_t,domain_arity,F,range_t,range_arity>								operator+ (const vf_wrapper<DT2,DN2,G,domain_t,domain_arity> &g) const								{ return composite_vf<DT2,DN2,G,domain_t,domain_arity,F,range_t,range_arity>(reinterpret_cast<const G&>(g), f_); }template<typename DT2, index_t DN2> composite_vf<DT2,DN2,void(*)(const DT2&,const DT2&, const DT2&, domain_t&,domain_t&,domain_t&),domain_t,domain_arity,F,range_t,range_arity>								operator+ (const pf_vf<DT2,DN2,domain_t,domain_arity> &g) const								{ return composite_vf<DT2,DN2,void(*)(const DT2&,const DT2&, const DT2&, domain_t&,domain_t&,domain_t&),domain_t,domain_arity,F,range_t,range_arity>(g, f_); }private:				F				f_;};template<typename DT, index_t DN, typename RT, index_t RN, class F>inline vf_wrapper<DT,DN,F,RT,RN> adapt(const F &f){ return vf_wrapper<DT,DN,F,RT,RN>(f); }template<typename DT, typename RT>inline pf_vf<DT,3,RT,3> adapt(const void (*f)(const DT&, const DT&, const DT&, RT&, RT&, RT&)){ return pf_vf<DT,3,RT,3>(f); }#ifdef DEBUGnamespace {	// TESTING		typedef void (*xformif)(const std::uint8_t &x, const std::uint8_t &y, const std::uint8_t &z, float &xp , float &yp, float &zp);	typedef void (*xformff)(const float &x, const float &y, const float &z, float &xp , float &yp, float &zp);	typedef void (*xformfi)(const float &x, const float &y, const float &z, std::uint8_t &xp , std::uint8_t &yp, std::uint8_t &zp);		template class pf_vf<float,3,float,3>;	template class composite_vf<float,3,xformff,float,3,xformff,float,3>;	template class composite_vf<std::uint8_t,3,xformif,float,3,xformff,float,3>;	template class composite_vf<std::uint8_t,3,xformif,float,3,xformfi,std::uint8_t,3>;	template class composite_vf<float,3,xformff,float,3,xformfi,std::uint8_t,3>;	template class vf_wrapper<float,3,xformff,float,3>;	template class vf_wrapper<std::uint8_t,3,xformif,float,3>;	template class vf_wrapper<float,3,xformfi,std::uint8_t,3>;	}#endif} // namespace static_vf#endif /* STATIC_VECTOR_FUNCTION_H */