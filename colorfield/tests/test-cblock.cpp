/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#pragma warn_notinlined on#include "block.h"#include "cf-debug.h"using namespace colorfield;using std::clog;using std::endl;#define CCOORD(R,C) coord_t<cindex<R>, cindex<C> >(cindex<R>(),cindex<C>())#define CRANGE(S,L) range_t<cindex<S>, cindex<L> >(cindex<S>(), cindex<L>())#define CBLOCK_T(RN,CN) block_t< range_t<zero_t, cindex<RN> >, range_t<zero_t, cindex<CN> > >#define CBLOCK(RN,CN) CBLOCK_T(RN,CN)(CRANGE(0,RN),CRANGE(0,CN))void test_cblock(void);namespace {typedef range_t<zero_t,one_t> range01_t;typedef range_t<index_t,one_t> rangen1_t;typedef range_t<zero_t,index_t> range0n_t;typedef range_t<zero_t,two_t> range02_t;typedef range_t<zero_t,three_t> range03_t;const range01_t one_range(zero,one);const range02_t two_range(zero,two);const range03_t three_range(zero,three);typedef block_t<range03_t,range02_t> block32_t;typedef block_t<range02_t,range03_t> block23_t;typedef block_t<range01_t,range02_t> block12_t;typedef block_t<range03_t,range01_t> block31_t;void test_cblock_basics(void){	block32_t block32(three_range,two_range);	const block23_t block23(two_range,three_range);	block32 = block23.transpose();}void test_cblock_attrs(void){	const block32_t block32(three_range,two_range);	const block12_t block12(one_range,two_range);	const block31_t block31(three_range,one_range);			FAILFALSE(block32.top()    == 0)	FAILFALSE(block32.left()   == 0)	FAILFALSE(block32.bottom() == 2)	FAILFALSE(block32.right()  == 1)	FAILFALSE(block32.height() == 3)	FAILFALSE(block32.width()  == 2)	FAILFALSE(block32.extent() == (coord_t<three_t,two_t>(three,two)))		FAILFALSE(block12.width()  == 2)	FAILFALSE(block12.height() == 1)	FAILFALSE(block31.width()  == 1)	FAILFALSE(block31.height() == 3)		FAILFALSE(block32 == block32)	FAILTRUE (block32 != block32)		FAILFALSE(block32 != block12)	FAILTRUE (block32 == block12)	}void test_cblock_preds(void){	const block32_t block32(three_range,two_range);	const block12_t block12(one_range,two_range);	const block31_t block31(three_range,one_range);			FAILFALSE(block32.contains(CCOORD(0,0)))	FAILFALSE(block32.contains(CCOORD(0,1)))	FAILFALSE(block32.contains(CCOORD(1,1)))	FAILFALSE(block32.contains(CCOORD(2,1)))		FAILTRUE (block32.row_range().contains(three_t()))	FAILTRUE (block32.column_range().contains(two_t()))		FAILTRUE (block32.contains(CCOORD(0,2)))	FAILTRUE (block32.contains(CCOORD(3,0)))		FAILFALSE(block12.contains(CCOORD(0,0)))	FAILFALSE(block12.contains(CCOORD(0,1)))	FAILTRUE (block12.contains(CCOORD(1,0)))	FAILTRUE (block12.contains(CCOORD(0,2)))	FAILFALSE(block31.contains(CCOORD(0,0)))	FAILFALSE(block31.contains(CCOORD(2,0)))	FAILTRUE (block31.contains(CCOORD(0,1)))	FAILTRUE (block31.contains(CCOORD(3,0)))}void test_cblock_ops(void){	const block32_t block32(three_range,two_range);	const block12_t block12(one_range,two_range);	const block31_t block31(three_range,one_range);        typedef block_t<range_t<one_t,three_t>, range_t<two_t,two_t> > offset_block32_t;    offset_block32_t offset_block32;	    typedef coord_t<cindex<1>, cindex<2> > coord12_t;    coord12_t coord12;    	// row column		FAILFALSE(block12 == block32.row(zero))	FAILFALSE(block31 == block32.column(zero))	FAILFALSE(block32.row   (one).width()  == block12.width())	FAILFALSE(block32.column(one).height() == block31.height())        FAILFALSE(CBLOCK(3,2).row(one).width() == two);    FAILFALSE(CBLOCK(3,2).row(one).height() == one);    FAILFALSE(CBLOCK(3,2).column(one).width() == one);    FAILFALSE(CBLOCK(3,2).column(one).height() == three);	// operator+ operator-	FAILFALSE((block32 + coord12) == offset_block32)	FAILFALSE((offset_block32 - coord12) == block32)	// map_in map_out		FAILFALSE(offset_block32.map_out(CCOORD(2,1)) == (CCOORD(3,3)))	FAILFALSE(offset_block32.map_in (CCOORD(3,3)) == (CCOORD(2,1)))#if 0	FAILFALSE(block12.map_out(block32).top() == 0)	FAILFALSE(block12.map_out(block32).left() == 0)	FAILFALSE(block12.map_out(block32).height() == block32.height())	FAILFALSE(block12.map_out(block32).width() == block32.width())	FAILFALSE(block12.map_out(block32) == block32)	FAILFALSE(block12.map_in (block32) == block32)#endif}#pragma warn_notinlined offvoid report_cblock_sizes(void){#define REPORT_RANGE_SIZE(S,L) clog << "sizeof(range_t<" << #S << "," << #L << ">) = " << sizeof(range_t<S,L>) << endl	REPORT_RANGE_SIZE(index_t,index_t);	REPORT_RANGE_SIZE(index_t,one_t);	REPORT_RANGE_SIZE(one_t,index_t);	REPORT_RANGE_SIZE(one_t,one_t);#define REPORT_BLOCK_SIZE(S1,L1,S2,L2) clog << "sizeof(block_t<range_t<" << #S1 << "," << #L1 << ">,range_t<" << #S2 << "," << #L2 << "> >) = " << sizeof(block_t<range_t<S1,L1>,range_t<S2,L2> >) << endl	REPORT_BLOCK_SIZE(index_t,index_t,index_t,index_t);		REPORT_BLOCK_SIZE(one_t,index_t,index_t,index_t);		REPORT_BLOCK_SIZE(index_t,one_t,index_t,index_t);		REPORT_BLOCK_SIZE(index_t,index_t,one_t,index_t);		REPORT_BLOCK_SIZE(index_t,index_t,index_t,one_t);		REPORT_BLOCK_SIZE(one_t,one_t,index_t,index_t);		REPORT_BLOCK_SIZE(one_t,index_t,one_t,index_t);		REPORT_BLOCK_SIZE(one_t,index_t,index_t,one_t);		REPORT_BLOCK_SIZE(one_t,one_t,one_t,index_t);		REPORT_BLOCK_SIZE(one_t,one_t,index_t,one_t);		REPORT_BLOCK_SIZE(one_t,one_t,one_t,one_t);	}} // namespace anonymousvoid test_cblock(void){	report_cblock_sizes();	test_cblock_basics();	test_cblock_attrs();	test_cblock_preds();	test_cblock_ops();}