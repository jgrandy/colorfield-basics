/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __COORD_H#define __COORD_H#include "colorfield.h"#include "index.h"#include <algorithm>#include <iostream>namespace colorfield {	/*		coord_t is a matrix coordinate, r_ indicating the row and c_ indicating the column of a matrix cell.		Note that we use row-major order in deference to C convention. Coordinates are also zero-based.				The class is templatized so that one or both of row & column may be specified using a cindex<>. This		allows significant constant folding optimizations when one or both coordinate dimensions are known		at compile time.				coord_t is also sometimes used as an indicator of extent, in which r_ is the number of rows and c_ is		the number of columns. (For example, coord_t(2,3) is at the bottom right of the matrix with extent coord_t(3,4).)		By defining the meat of the class' implementation in private, "prim" classes, we can use partial		specialization over those classes to optimize various things without having to copy the public interface		over all the partial specializations.	*//*1.					2.					3.*/template<class Row = index_t, class Col = index_t> class prim_coord_t;template<index_t Row> class prim_coord_t<cindex<Row>, index_t> {public:			typedef cindex<Row>				row_t;			typedef index_t						col_t;			typedef prim_coord_t<row_t,col_t>	this_t;			typedef prim_coord_t<col_t,row_t>	transpose_t;static	  			row_t				row_;					col_t				col_;										prim_coord_t(const row_t, const col_t c) 		: col_(c) {}										prim_coord_t(const this_t &c)					: col_(c.col_) {}										prim_coord_t(void)								{}									this_t&				operator= (const this_t &c)						{ col_ = c.col_; return *this; }template<index_t C2> this_t&			operator= (const prim_coord_t<row_t,cindex<C2> > &c)																						{ col_ = C2; return *this; }template<class R2, class C2> this_t&	operator= (const prim_coord_t<R2,C2> &c)		{ assert(row_ == c.row()); col_ = c.column(); return *this; }																																							row_t&				row(void)										{ return row_; }					row_t				row(void) const									{ return row_; }									col_t&				column(void)									{ return col_; }					col_t				column(void) const								{ return col_; }									bool				operator==(const this_t &c)	const				{ return col_ == c.col_; }template<index_t C2> bool				operator==(const prim_coord_t<row_t,cindex<C2> > &c)																						{ return col_ == C2; }																			template<class R2, class C2> bool		operator==(const prim_coord_t<R2,C2> &c) const	{ return (row_ == c.row()) && (col_ == c.column()); }					bool				operator!=(const this_t &c) const				{ return col_ != c.col_; }template<index_t C2> bool				operator!=(const prim_coord_t<row_t,cindex<C2> > &c)																						{ return col_ != C2; }template<class R2, class C2> bool		operator!=(const prim_coord_t<R2,C2> &c) const	{ return (row_ != c.row()) || (col_ != c.column()); }													transpose_t			transpose(void) const							{ return transpose_t(col_, row_); }};template<index_t Row> cindex<Row> prim_coord_t<cindex<Row>, index_t>::row_;template<index_t Col> class prim_coord_t<index_t, cindex<Col> > {public:			typedef index_t						row_t;			typedef cindex<Col>				col_t;			typedef prim_coord_t<row_t,col_t>	this_t;			typedef prim_coord_t<col_t,row_t>	transpose_t;					row_t				row_;static				col_t				col_;										prim_coord_t(const row_t r, const col_t) 		: row_(r) {}										prim_coord_t(const this_t &c)					: row_(c.row_) {}										prim_coord_t(void)								{}									this_t&				operator= (const this_t &c)						{ row_ = c.row_; return *this; }template<index_t R2> this_t&				operator= (const prim_coord_t<cindex<R2>, col_t> &c)																						{ row_ = R2; return *this; }template<class R2, class C2>					this_t&				operator= (const prim_coord_t<R2,C2> &c)		{ assert(column() == c.column()); row() = c.row(); return *this; }									row_t&				row(void)										{ return row_; }					row_t				row(void) const									{ return row_; }									col_t&				column(void)									{ return col_; }					col_t				column(void) const								{ return col_; }									bool				operator==(const this_t &c) const				{ return row_ == c.row_; }template<index_t R2> bool				operator==(const prim_coord_t<cindex<R2>, col_t> &c)																						{ return row_ == R2; }template<class R2, class C2>					bool				operator==(const prim_coord_t<R2,C2> &c) const	{ return (row() == c.row()) && (column() == c.column()); }					bool				operator!=(const this_t &c) const				{ return row_ != c.row_; }template<index_t R2> bool				operator!=(const prim_coord_t<cindex<R2>, col_t> &c)																						{ return row_ != R2; }				template<class R2, class C2>					bool				operator!=(const prim_coord_t<R2,C2> &c) const	{ return (row() != c.row()) || (column() != c.column()); }													transpose_t			transpose(void) const							{ return transpose_t(col_, row_); }};template<index_t Col> cindex<Col> prim_coord_t<index_t, cindex<Col> >::col_;template<index_t Row, index_t Col> class prim_coord_t<cindex<Row>, cindex<Col> > {public:			typedef cindex<Row>				row_t;			typedef cindex<Col>				col_t;			typedef prim_coord_t<row_t,col_t>	this_t;			typedef prim_coord_t<col_t,row_t>	transpose_t;static				row_t				row_;static				col_t				col_;										prim_coord_t(const row_t, const col_t)			{}										prim_coord_t(const this_t &)					{}										prim_coord_t(void)								{}									this_t&				operator= (const this_t &)						{ return *this; }template<class R2, class C2>					this_t&				operator= (const prim_coord_t<R2,C2> &c)		{ assert(row() == c.row()); assert(column() == c.column()); return *this; }										row_t&				row(void)										{ return row_; }					row_t				row(void) const									{ return row_; }									col_t&				column(void)									{ return col_; }					col_t				column(void) const								{ return col_; }									bool				operator==(const this_t &) const				{ return true; }					bool				operator!=(const this_t &) const				{ return false; }				template<class R2, class C2>					bool				operator==(const prim_coord_t<R2,C2> &c) const	{ return (row() == c.row()) && (column() == c.column()); }template<class R2, class C2>					bool				operator!=(const prim_coord_t<R2,C2> &c) const	{ return (row() != c.row()) || (column() != c.column()); }													transpose_t			transpose(void) const							{ return transpose_t(col_, row_); }				};template<index_t Row, index_t Col> cindex<Row> prim_coord_t<cindex<Row>, cindex<Col> >::row_;template<index_t Row, index_t Col> cindex<Col> prim_coord_t<cindex<Row>, cindex<Col> >::col_;template<> class prim_coord_t<index_t, index_t> {public:			typedef index_t						row_t;			typedef index_t						col_t;			typedef prim_coord_t<row_t,col_t>	this_t;			typedef prim_coord_t<col_t,row_t>	transpose_t;                                        prim_coord_t(const row_t r, const col_t c) 		: row_(r), col_(c) {}										prim_coord_t(const this_t &c)					: row_(c.row_), col_(c.col_) {}										prim_coord_t(void)								{}				                    this_t&				operator= (const this_t &c)						{ row_ = c.row_; col_ = c.col_; return *this; }									row_t&				row(void)										{ return row_; }					row_t				row(void) const									{ return row_; }									col_t&				column(void)									{ return col_; }					col_t				column(void) const								{ return col_; }									bool				operator==(const this_t &c) const				{ return row_ == c.row_ && col_ == c.col_; }					bool				operator!=(const this_t &c) const				{ return row_ != c.row_ || col_ != c.col_; }				template<class R2, class C2>					this_t&				operator= (const prim_coord_t<R2,C2> &c)		{ row() = c.row(); column() = c.column(); return *this; }template<class R2, class C2>					bool				operator==(const prim_coord_t<R2,C2> &c) const	{ return (row() == c.row()) && (column() == c.column()); }template<class R2, class C2>					bool				operator!=(const prim_coord_t<R2,C2> &c) const	{ return (row() != c.row()) || (column() != c.column()); }													transpose_t			transpose(void) const							{ return transpose_t(column(), row()); }private:    					row_t               row_;                    col_t               col_;};template<class R, class C> class coord_t;template<class R, class C, class N> class coord_index_traits {public:			typedef coord_t<typename index_traits<R,N>::sum_t, typename index_traits<C,N>::sum_t> sum_t;			typedef coord_t<typename index_traits<R,N>::diff_t, typename index_traits<C,N>::diff_t> diff_t;};template<class R, class C, class R2, class C2> class coord_coord_traits {public:			typedef coord_t<typename index_traits<R,R2>::sum_t, typename index_traits<C,C2>::sum_t> sum_t;			typedef coord_t<typename index_traits<R,R2>::diff_t, typename index_traits<C,C2>::diff_t> diff_t;};template<class Row = index_t, class Col = index_t> class coord_t : public prim_coord_t<Row,Col> {public:							// Types										typedef Row 						row_t;			typedef Col 						col_t;			typedef coord_t<row_t,col_t>		this_t;			typedef prim_coord_t<row_t,col_t>	base_t;			typedef coord_t<col_t,row_t>		transpose_t;						typedef Row 						height_t;			typedef Col 						width_t;						typedef typename index_traits<row_t,col_t>::prod_t	area_t;			typedef typename index_traits<row_t,col_t>::min_t	diag_t;														// Traits		template<class N> class index_traits : public coord_index_traits<row_t, col_t, N> {};		template<class R2, class C2> class coord_traits : public coord_coord_traits<row_t, col_t, R2, C2> {};public:											// Constructors																	coord_t(row_t r, col_t c) 						: base_t(r,c) {}										coord_t(const this_t &cd)						: base_t(cd) {}										coord_t(void)									{}template<class R2, class C2>															this_t&				operator=(const coord_t<R2,C2> &cd)				{ this->base_t::operator=(cd); return *this; }											// Predicates					bool				is_square(void) const							{ return row() == column(); }							// Coercion/Conversion																								transpose_t			transpose (void) const 							{ return transpose_t(column(),row()); }														operator coord_t<index_t,index_t>(void) const	{ return coord_t<index_t,index_t>(row(),column()); }							// Accessors                        row_t&				row(void)										{ return base_t::row(); }                    row_t				row(void) const									{ return base_t::row(); }                                        col_t&				column(void)									{ return base_t::column(); }                    col_t				column(void) const								{ return base_t::column(); }					area_t				area(void) const								{ return (area_t) (row() * column()); }					diag_t				diagonal(void) const							{ return min(row(), column()); }		  					row_t				height(void) const								{ return row(); }					row_t&				height(void)									{ return row(); }					col_t				width(void) const								{ return column(); }					col_t&				width(void)										{ return column(); }				};template<class R, class C, index_t N>inline typename coord_index_traits<R,C,cindex<N> >::sum_t operator+ (const coord_t<R,C> &c, const cindex<N>& n){	typedef typename coord_index_traits<R,C,cindex<N> >::sum_t sum_t;		return sum_t(c.row() + n, c.column() + n);}template<class R, class C>inline typename coord_index_traits<R,C,index_t>::sum_t operator+ (const coord_t<R,C> &c, const index_t& n){	typedef typename coord_index_traits<R,C,index_t>::sum_t sum_t;		return sum_t(c.row() + n, c.column() + n);}template<class R1, class C1, class R2, class C2>inline typename coord_coord_traits<R1,C1,R2,C2>::sum_t  operator+ (const coord_t<R1,C1> &c1, const coord_t<R2,C2> &c2){	typedef typename coord_coord_traits<R1,C1,R2,C2>::sum_t sum_t;	return sum_t(c1.row()    + c2.row(),				 c1.column() + c2.column());}template<class R, class C, index_t N>inline typename coord_index_traits<R,C,cindex<N> >::diff_t operator- (const coord_t<R,C> &c, const cindex<N>& n){	typedef typename coord_index_traits<R,C,cindex<N> >::diff_t diff_t;		return diff_t(c.row() - n, c.column() - n);}template<class R, class C>inline typename coord_index_traits<R,C,index_t>::diff_t operator- (const coord_t<R,C> &c, const index_t& n){	typedef typename coord_index_traits<R,C,index_t>::diff_t diff_t;		return diff_t(c.row() - n, c.column() - n);}template<class R1, class C1, class R2, class C2>inline typename coord_coord_traits<R1,C1,R2,C2>::diff_t operator- (const coord_t<R1,C1> &c1, const coord_t<R2,C2> &c2){	typedef typename coord_coord_traits<R1,C1,R2,C2>::diff_t diff_t;	return diff_t(c1.row()    - c2.row(),				  c1.column() - c2.column());}template<class row_t, class col_t>inline std::ostream &operator<<(std::ostream &os, const coord_t<row_t,col_t> &pos){	os << "coord(" << pos.row() << ", " << pos.column() << ")";	return os;}inline coord_t<> coord(const index_t r, const index_t c){ return coord_t<>(r,c); }template<index_t R, index_t C> inline coord_t<cindex<R>,cindex<C> > coord(const cindex<R> r, const cindex<C> c){ return coord_t<cindex<R>,cindex<C> >(r,c); }template<index_t R           > inline coord_t<cindex<R>,index_t     > coord(const cindex<R> r, const index_t c    ){ return coord_t<cindex<R>,index_t>(r,c); }template<           index_t C> inline coord_t<index_t    ,cindex<C> > coord(const index_t r    , const cindex<C> c){ return coord_t<index_t,cindex<C> >(r,c); }} // namespace colorfield#endif /* __COORD_H */