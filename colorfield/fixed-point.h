/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __FIXED_POINT_H#define __FIXED_POINT_H#include "colorfield.h"#include <boost/integer.hpp>#include <boost/integer_traits.hpp>namespace colorfield {/*1.					2.					3.				4.*/template<std::size_t IntegerBits, std::size_t FractionBits>class fixed {	// a signed fixed-point valuepublic:			typedef fixed<IntegerBits,FractionBits>		this_t;static		  const std::size_t			N = IntegerBits + FractionBits;			typedef boost::int_t<N>::least				value_t;			typedef boost::int_t<IntegerBits>::least	integer_value_t;			typedef boost::uint_t<FractionBits>::least	fraction_value_t;			typedef boost::uint_t<IntegerBits>::least	integer_store_t;static		  const std::size_t			IntegerSlop = boost::integer_traits<integer_store_t>::digits - IntegerBits,										FractionSlop = boost::integer_traits<fraction_value_t>::digits - FractionBits;										private:					value_t				val_;static		  const fraction_value_t	max_fraction = boost::integer_traits<fraction_value_t>::const_max;static		  const value_t				integer_mask = value_t((boost::integer_traits<integer_store_t>::const_max << IntegerSlop) >> IntegerSlop) << FractionBits,										fraction_mask = (boost::integer_traits<fraction_value_t>::const_max << FractionSlop) >> FractionSlop;static		  const value_t				one = 1 << FractionBits,										one_half = 1 << (FractionBits - 1),										epsilon = 1;public:										fixed(void)								: val_() {}										fixed(const this_t &f)					: val_(f.val_) {}										fixed(double f)							: val_(f * one) {}					this_t&				operator= (const this_t &f)				{ val_ = f.val_; return *this; }										bool				operator==(const this_t &f) const		{ return (val_ == f.val_); }					bool				operator!=(const this_t &f) const		{ return (val_ != f.val_); }															operator double(void) const				{ return val_ / double(one); }															void				set_value(value_t i)					{ val_ = i; }			  const value_t&			get_value(void) const					{ return val_; }					value_t&			get_value(void)							{ return val_; }public:					integer_value_t		round(void) const						{ return integer_value_t((val_ + one_half) >> FractionBits); }					this_t				floor(void) const						{																				  return (val_ < 0) ? this_t(value_t(- ((- val_ + (one - epsilon)) & integer_mask)))																									: this_t(value_t(val_ & integer_mask));																				}					this_t				ceiling(void) const						{																				  return (val_ < 0) ? this_t(value_t(- ((- val_) & integer_mask)))																									: this_t(value_t((val_ + (one - epsilon)) & integer_mask));																				}										this_t				operator+ (const this_t &f) const		{ this_t f2; f2.set_value(val_ + f.val_); return f2; }					this_t				operator- (const this_t &f) const		{ this_t f2; f2.set_value(val_ - f.val_); return f2; }					this_t				operator* (const this_t &f) const;					this_t				operator/ (const this_t &f) const;};typedef fixed<8,8> fixed8;typedef fixed<16,16> fixed16;} // namespacenamespace std {// Specialization for bitint typestemplate<std::size_t IntegerBits, std::size_t FractionBits>class numeric_limits< ::colorfield::fixed<IntegerBits, FractionBits> >;} // namespace std#endif /* __FIXED_POINT_H */