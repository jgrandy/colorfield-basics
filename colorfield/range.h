/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __RANGE_H#define __RANGE_H#include "colorfield.h"#include "index.h"#include <iostream>#if ! AC_HAS_MEMBER_TEMPLATES#error "range_t requires member templates"#endif#if ! AC_HAS_CLASS_TEMPLATE_PARTIAL_SPECIALIZATION#error "range_t requires partial template specialization"#endifnamespace colorfield {template<class Start = index_t, class Length = index_t> class prim_range_t;template<index_t Start> class prim_range_t<cindex<Start>, index_t> {public:				typedef cindex<Start>	start_t;				typedef index_t			length_t;				typedef prim_range_t<start_t,length_t> this_t;				static			start_t					start_;				length_t                length_;										prim_range_t(const start_t, const length_t n)	: length_(n) {}										prim_range_t(const this_t &r)					: length_(r.length_) {}										prim_range_t(void)								{}														start_t&                start(void)										{ return start_; }				start_t					start(void) const								{ return start_; }				length_t&				length(void)									{ return length_; }				length_t                length(void) const								{ return length_; }				this_t&					operator= (const this_t &r2)					{ length_ = r2.length_; return *this; }template<class S2, class L2>								this_t&					operator= (const prim_range_t<S2,L2> &r2)		{ assert(start() == r2.start()); length() = r2.length(); return *this; }  				bool					operator==(const this_t &r2) const				{ return length_ == r2.length_; }template<class S2, class L2>				bool					operator==(const prim_range_t<S2,L2> &r2) const	{ return (start() == r2.start()) && (length() == r2.length()); }								bool					operator!=(const this_t &r2) const				{ return length_ != r2.length_; }template<class S2, class L2>				bool					operator!=(const prim_range_t<S2,L2> &r2) const	{ return (start() != r2.start()) || (length() != r2.length()); }};template<index_t Start> cindex<Start> prim_range_t<cindex<Start>, index_t>::start_;template<index_t Length> class prim_range_t<index_t,cindex<Length> > {public:				typedef index_t			start_t;				typedef cindex<Length>	length_t;				typedef prim_range_t<start_t,length_t> this_t;								start_t					start_;static			length_t				length_;										prim_range_t(const start_t s, const length_t)	: start_(s) {}										prim_range_t(const this_t &r)					: start_(r.start_) {}										prim_range_t(void)								{}														start_t&				start(void)										{ return start_; }				start_t					start(void) const								{ return start_; }				length_t&				length(void)									{ return length_; }				length_t				length(void) const								{ return length_; }				this_t&					operator= (const this_t &r2)					{ start_ = r2.start_; return *this; }template<class S2, class L2>								this_t&					operator= (const prim_range_t<S2,L2> &r2)		{ start() = r2.start(); assert(length() == r2.length()); return *this; }  				bool					operator==(const this_t &r2) const				{ return start_ == r2.start_; }template<class S2, class L2>				bool					operator==(const prim_range_t<S2,L2> &r2) const	{ return (start() == r2.start()) && (length() == r2.length()); }								bool					operator!=(const this_t &r2) const				{ return start_ != r2.start_; }template<class S2, class L2>				bool					operator!=(const prim_range_t<S2,L2> &r2) const	{ return (start() != r2.start()) || (length() != r2.length()); }};template<index_t Length> cindex<Length> prim_range_t<index_t, cindex<Length> >::length_;template<index_t Start, index_t Length> class prim_range_t<cindex<Start>, cindex<Length> > {public:				typedef cindex<Start>	start_t;				typedef cindex<Length>	length_t;				typedef prim_range_t<start_t,length_t> this_t;				static			start_t					start_;static			length_t				length_;										prim_range_t(const start_t, const length_t)		{}										prim_range_t(const this_t &)					{}										prim_range_t(void)								{}														start_t&				start(void)										{ return start_; }				start_t					start(void) const								{ return start_; }				length_t&				length(void)									{ return length_; }				length_t				length(void) const								{ return length_; }				this_t&					operator= (const this_t &)						{ return *this; }template<class S2, class L2>								this_t&					operator= (const prim_range_t<S2,L2> &r2)		{ assert(start() == r2.start()); assert(length() == r2.length()); return *this; }  				bool					operator==(const this_t &) const				{ return true; }template<class S2, class L2>				bool					operator==(const prim_range_t<S2,L2> &r2) const	{ return (start() == r2.start()) && (length() == r2.length()); }								bool					operator!=(const this_t &) const				{ return false; }template<class S2, class L2>				bool					operator!=(const prim_range_t<S2,L2> &r2) const	{ return (start() != r2.start()) || (length() != r2.length()); }};template<index_t Start, index_t Length> cindex<Start > prim_range_t<cindex<Start>, cindex<Length> >::start_;template<index_t Start, index_t Length> cindex<Length> prim_range_t<cindex<Start>, cindex<Length> >::length_;template<> class prim_range_t<index_t,index_t> {public:		typedef index_t			start_t;		typedef index_t			length_t;		typedef prim_range_t<start_t,length_t> this_t;														prim_range_t(const start_t s, const length_t n)	: start_(s), length_(n) {}										prim_range_t(const this_t &r)					: start_(r.start_), length_(r.length_) {}										prim_range_t(void)								{}										                start_t					start(void) const								{ return start_; }				start_t&				start(void)										{ return start_; }                length_t				length(void) const								{ return length_; }                length_t&				length(void)									{ return length_; }                this_t&					operator= (const this_t &r2)					{ start_ = r2.start_; length_ = r2.length_; return *this; }template<class S2, class L2>								this_t&					operator= (const prim_range_t<S2,L2> &r2)		{ start() = r2.start(); length() = r2.length(); return *this; }  				bool					operator==(const this_t &r2) const				{ return start_ == r2.start_ && length_ == r2.length_; }template<class S2, class L2>				bool					operator==(const prim_range_t<S2,L2> &r2) const	{ return (start() == r2.start()) && (length() == r2.length()); }								bool					operator!=(const this_t &r2) const				{ return start_ != r2.start_ || length_ != r2.length_; }template<class S2, class L2>				bool					operator!=(const prim_range_t<S2,L2> &r2) const	{ return (start() != r2.start()) || (length() != r2.length()); }private:				index_t             start_;                index_t             length_;};template<class S, class L> class range_t;template<class S,class L,class N> class range_index_traits {public:				typedef range_t<typename index_traits<S,N>::sum_t,  L> sum_t;				typedef range_t<typename index_traits<S,N>::diff_t, L> diff_t;				typedef typename index_traits<N, S>::sum_t map_out_t;				typedef typename index_traits<N, S>::diff_t map_in_t;				typedef range_t<typename index_traits<S,N>::sum_t,								typename index_traits<L,typename index_traits<N,N>::sum_t>::diff_t> inset_t;				typedef range_t<typename index_traits<S,N>::diff_t,								typename index_traits<L,typename index_traits<N,N>::sum_t>::sum_t> outset_t;};template<class S, class L, class S2, class L2> class range_range_traits {public:				typedef range_t<typename index_traits<S2,S>::sum_t,L2> map_out_t;				typedef range_t<typename index_traits<S2,S>::diff_t,L2> map_in_t;};template<class Start = index_t, class Length = index_t> class range_t : public prim_range_t<Start,Length> {public:							// Types											typedef Start	  		start_t;				typedef Length	 		length_t;				typedef range_t<start_t,length_t> 		this_t;				typedef prim_range_t<start_t,length_t>	base_t;				typedef typename index_traits<typename index_traits<start_t,length_t>::sum_t, cindex<1> >::diff_t stop_t;							// Traits				template<class N> class index_traits : public range_index_traits<start_t,length_t,N> {};				template<class S2, class L2> class range_traits : public range_range_traits<start_t, length_t, S2, L2> {};												// Constructors																	range_t(const start_t s, const length_t n)		: base_t(s,n) {}										range_t(const this_t &r)						: base_t(r) {}										range_t(void)									{}										template<class S2, class L2>								this_t&					operator=(const range_t<S2,L2> &r2)				{ this->base_t::operator=(r2); return *this; }  							// Accessors				                length_t                length(void) const								{ return base_t::length(); }                start_t                 start(void) const                               { return base_t::start(); }				stop_t					stop(void) const								{ return (stop_t) (start() + length() - one); }										operator range_t<>(void) const					{ return range_t<>(start(),length()); }																	// Predicates				bool					empty(void) const								{ return length() == zero; }															// these don't necessarily reflect the semantics of the class,											// but are necessary for using ranges as keys in std::map.template<class S2, class L2>				bool					operator< (const range_t<S2,L2> &r) const		{ return (start() < r.start()) && (length() < r.length()); }template<class S2, class L2>				bool					operator> (const range_t<S2,L2> &r) const		{ return (start() > r.start()) && (length() > r.length()); }							// Operatorstemplate<class N> inline			bool					contains(const N &n) const						{ return (n >= start()) && (n < (start() + length())); }template<class N>inline	typename range_index_traits<start_t,length_t,N>::map_out_t	map_out(const N& n) const																						{ return n + start(); }template<class N>inline	typename range_index_traits<start_t,length_t,N>::map_in_t	map_in(const N& n) const																						{ return n - start(); }template<class S2, class L2> inline	typename range_range_traits<start_t,length_t,S2,L2>::map_out_t map_out(const range_t<S2,L2>& r) const																						{																							typedef typename range_range_traits<start_t,length_t,S2,L2>::map_out_t result_t;																							return result_t(r.start() + start(), r.length());																						}template<class S2, class L2> inline	typename range_range_traits<start_t,length_t,S2,L2>::map_in_t map_in(const range_t<S2,L2>& r) const																						{																							typedef typename range_range_traits<start_t,length_t,S2,L2>::map_in_t result_t;																							return result_t(r.start() - start(), r.length());																						}template<class N> inline	typename range_index_traits<start_t,length_t,N>::inset_t	inset(const N& n) const {																							typedef typename range_index_traits<start_t,length_t,N>::inset_t result_t;																							return result_t(start() + n, length() - (n + n));																						}																						template<class N> inline	typename range_index_traits<start_t,length_t,N>::outset_t	outset(const N& n) const																						{																							typedef typename range_index_traits<start_t,length_t,N>::outset_t result_t;																								return result_t(start() - n, length() + (n + n));																						}};inline range_t<> range(const index_t s, const index_t n){ 	return range_t<>(s,n);}template<index_t S, index_t L>inline range_t<cindex<S>,cindex<L> > range(const cindex<S> s, const cindex<L> n){ 	return range_t<cindex<S>,cindex<L> >(s,n);}template<index_t S>inline range_t<cindex<S>,index_t> range(const cindex<S> s, const index_t n){ 	return range_t<cindex<S>,index_t>(s,n);}template<index_t L>inline range_t<index_t,cindex<L> > range(const index_t s, const cindex<L> n){ 	return range_t<index_t,cindex<L> >(s,n);}template<class S, class L>inline std::ostream &operator<<(std::ostream &os, const range_t<S,L> &range){	os << "[" << range.start() << "+" << range.length() << "]";	return os;}template<class S, class L, index_t N>inline typename range_index_traits<S,L,cindex<N> >::sum_t operator+ (const range_t<S,L> &r, const cindex<N> &n){	typedef typename range_index_traits<S,L,cindex<N> >::sum_t result_t;		return result_t((typename result_t::start_t)(r.start() + n), r.length());}template<class S, class L>inline typename range_index_traits<S,L,index_t>::sum_t operator+ (const range_t<S,L> &r, const index_t &n){	typedef typename range_index_traits<S,L,index_t>::sum_t result_t;		return result_t((typename result_t::start_t)(r.start() + n), r.length());}template<class S, class L, index_t N>inline typename range_index_traits<S,L,cindex<N> >::diff_t operator- (const range_t<S,L> &r, const cindex<N> &n){	typedef typename range_index_traits<S,L,cindex<N> >::diff_t result_t;		return result_t((typename result_t::start_t)(r.start() - n), r.length());}template<class S, class L>inline typename range_index_traits<S,L,index_t>::diff_t operator- (const range_t<S,L> &r, const index_t &n){	typedef typename range_index_traits<S,L,index_t>::diff_t result_t;		return result_t((typename result_t::start_t)(r.start() - n), r.length());}} // namespace colorfield#endif /* __RANGE_H */