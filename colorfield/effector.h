/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1995 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __EFFECTOR_H_#define __EFFECTOR_H_// Abstract Template Class EFFECTOR//// template parameter T is the type of the value to be read/writtentemplate<class T> class effector {	//¥¥¥GetValue(seed_type&) [const] and ValueChanged(seed_type&)	// should execute atomicallypublic:				typedef T			  value_type;				typedef unsigned long seed_type;						// constant interface														seed_type			GetSeed(void) const									  { return fSeed; };				bool				HasValueChanged(seed_type &old_seed) const									  { return (old_seed != fSeed); };												  const T				   &GetValue(void) const									  { return *fReference; };		  const T				   &GetValue(seed_type &seed) const									  { seed = fSeed; return *fReference; }																			operator const T& (void) const									  { return *fReference; }									  						// mutable interface							T				   &GetValue(void)									  { return *fReference; }				T				   &GetValue(seed_type &seed)									  { seed = fSeed; return *fReference; }									  				seed_type			ValueUpdated(void)									  { return ++fSeed; }													operator T& (void)									  { return *fReference; }				protected:				seed_type			fSeed;				T				   *fReference;										// instantiate only from derived class									effector(T *ref)									  : fReference(ref), fSeed(1)									  {};									effector(T &ref)									  : fReference(&ref), fSeed(1)									  {};};// Template Class VALUE_EFFECTOR//// Stores a value and manages changes to ittemplate<class T> class value_effector : public effector<T> {public:									value_effector(const T &val) 									  : effector<T>(fValue), fValue(val) 									  {};									private:				T					fValue;};// Template Class REFERENCE_EFFECTOR//// Stores a reference to a value and manages changes to ittemplate<class T> class reference_effector : public effector<T> {public:									reference_effector(T &val) 									  : effector<T>(val)									  {};};template<class T> class pointer_effector : public effector<T> {public:									pointer_effector(T *val) 									  : effector<T>(val)									  {};									  				T				   *change(T *new_ref)			{ T *old_ref = fReference; fReference = new_ref; return old_ref; }};#endif /* __EFFECTOR_H_ */