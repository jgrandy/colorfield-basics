/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __GENERIC_ITERATORS_H#define __GENERIC_ITERATORS_H#include "index.h"#include <ostream>#include <map>namespace colorfield {/*1.				2.						3.*/#pragma mark dummy_iteratortemplate<class T>class dummy_iterator {public:										dummy_iterator(const T &val)								: val_(val) {}										dummy_iterator(const dummy_iterator &cit)					: val_(cit.val_) {}				dummy_iterator&			operator=(const dummy_iterator &cit)						{ val_ = cit.val_; return this; }				friend			bool					operator==(const dummy_iterator<T>& it1, const dummy_iterator<T> &it2)	{ return (it1.val_ == it2.val_); }				friend			bool					operator!=(const dummy_iterator<T>& it1, const dummy_iterator<T> &it2)	{ return (it1.val_ != it2.val_); }										  const T					   &operator* (void) const										{ return val_; }								dummy_iterator<T>		operator++(void) /* preincrement */							{ return *this; }		  const dummy_iterator<T>		operator++(int)  /* postincrement */						{ return dummy_iterator<T>(*this); }				dummy_iterator<T>		operator--(void) /* predecrement */							{ return *this; }		  const dummy_iterator<T>		operator--(int)  /* postdecrement */						{ return dummy_iterator<T>(*this); }		  				dummy_iterator<T>		operator+=(int)												{ return *this; }				dummy_iterator<T>		operator-=(int)												{ return *this; }protected:    friend std::ostream &operator<<(std::ostream &, const dummy_iterator<T>&);		  const T					   &val_;};template<class T>    inline std::ostream &operator<<(std::ostream &os, const dummy_iterator<T> &cit){	os << "dummy_iterator: " << cit.val_;	return os;}#pragma mark ptr_iteratortemplate<class T, class VP, class CP> class       ptr_iterator;template<class T, class VP, class CP> class const_ptr_iterator;#if AC_DEFAULT_TEMPLATE_PARAMETERStemplate<class T, class VP = T*, class CP = const T*>#elsetemplate<class T, class VP, class CP>#endifclass ptr_iterator {public:				typedef ptr_iterator<T,VP,CP> this_t;														ptr_iterator(VP ptr)										: ptr_(ptr) {}										ptr_iterator(const ptr_iterator &pit)						: ptr_(pit.ptr_) {}				this_t&					operator=(const this_t &pit)								{ ptr_ = pit.ptr_; return *this; }				bool					operator==(const this_t &rit) const							{ return (ptr_ == rit.ptr_); }								bool					operator==(const const_ptr_iterator<T,VP,CP> &rit) const	{ return (ptr_ == rit.ptr_); }								bool					operator!=(const this_t &rit) const							{ return (ptr_ != rit.ptr_); }				bool					operator!=(const const_ptr_iterator<T,VP,CP> &rit) const	{ return (ptr_ != rit.ptr_); }								T					   &operator* (void)											{ return *ptr_; }		  const T					   &operator* (void) const										{ return *ptr_; }				this_t					operator++(void) /* preincrement */							{ ++ptr_; return *this; }		  const this_t					operator++(int)  /* postincrement */						{																									  const this_t rit(*this);																									  ++ptr_;																									  return rit;																									}				this_t					operator--(void) /* predecrement */							{ --ptr_; return *this; }		  const this_t					operator--(int)  /* postdecrement */						{																									  const this_t rit(*this);																									  --ptr_;																									  return rit;																									}				this_t					operator+=(int inc)											{ ptr_ += inc; return *this; }				this_t					operator-=(int dec)											{ ptr_ -= dec; return *this; }				    friend			std::ostream&				operator<<(std::ostream &os, const this_t &pit)				{																									 os << '[' << pit.ptr_ << ": " << *(pit.ptr_) << ']';																									 return os;																									}protected:friend class const_ptr_iterator<T,VP,CP>;				VP						ptr_;};#pragma mark const_ptr_iterator#if AC_DEFAULT_TEMPLATE_PARAMETERStemplate<class T, class VP = T*, class CP = const T*>#elsetemplate<class T, class VP, class CP>#endifclass const_ptr_iterator {public:				typedef const_ptr_iterator<T,VP,CP> this_t;														const_ptr_iterator(CP ptr)							: ptr_(ptr) {}										const_ptr_iterator(const this_t &rit)				: ptr_(rit.ptr_) {}														this_t&					operator= (this_t &rit)								{ ptr_ = rit.ptr_; return *this; }				bool					operator==(const this_t &rit) const					{ return (ptr_ == rit.ptr_); }				bool					operator==(const ptr_iterator<T,VP,CP> &rit) const	{ return (ptr_ == rit.ptr_); }				bool					operator!=(const this_t &rit) const					{ return (ptr_ != rit.ptr_); }				bool					operator!=(const ptr_iterator<T,VP,CP> &rit) const	{ return (ptr_ != rit.ptr_); }						  const T					   &operator* (void) const								{ return *ptr_; }								this_t					operator++(void) /* preincrement */					{ ++ptr_; return *this; }		  const this_t					operator++(int)  /* postincrement */				{																					 		 const const_ptr_iterator<T,VP,CP> rit(*this);																					 		 ++ptr_;																							 return rit;																							}				this_t					operator--(void) /* predecrement */					{ --ptr_; return *this; }		  const this_t					operator--(int)  /* postdecrement */				{																							 const this_t rit(*this);																							 --ptr_;																							 return rit;																							}				this_t					operator+=(int inc)									{ ptr_ += inc; return *this; }				this_t					operator-=(int dec)									{ ptr_ -= dec; return *this; }friend 			std::ostream&				operator<<(std::ostream &os, const this_t &pit)		{																							 os << '[' << pit.ptr_ << ": " << *(pit.ptr_) << ']';																							 return os;																							}protected:friend class ptr_iterator<T,VP,CP>;				CP						ptr_;};#pragma mark slicetemplate<class T, class S> class slice;template<class T, class S> class const_slice;template<class T, class S = index_t>class slice {public:				typedef slice<T,S> 			this_t;				typedef const_slice<T,S>	const_t;				typedef S 					stride_t;														slice(T *ptr, stride_t stride)			: ptr_(ptr), stride_(stride) {}										slice(const slice &s)					: ptr_(s.ptr_), stride_(s.stride_) {}														this_t&					operator= (const  this_t &s)			{ ptr_ = s.ptr_; stride_ = s.stride_; return *this; }								bool					operator==(const  this_t &s) const		{ return (ptr_ == s.ptr_) && (stride_ == s.stride_); }				bool					operator==(const const_t &s) const		{ return (ptr_ == s.ptr_) && (stride_ == s.stride_); }				bool					operator!=(const  this_t &s) const		{ return (ptr_ != s.ptr_) || (stride_ != s.stride_); }				bool					operator!=(const const_t &s) const		{ return (ptr_ != s.ptr_) || (stride_ != s.stride_); }								T&						operator* (void)						{ return *ptr_; }		  const T&						operator* (void) const					{ return *ptr_; }				this_t					operator++(void)	/* preincrement */		{ 																				  ptr_ += (index_t) stride_; 																				  return *this; 																				}		  const this_t					operator++(int)		/* postincrement */		{																				  const this_t sp(*this);																				  ptr_ += (index_t) stride_; 																				  return sp;																				}				this_t					operator--(void)	/* predecrement */		{ 																				  ptr_ -= (index_t) stride_; 																				  return *this; 																				}		  const this_t					operator--(int)		/* postdecrement */		{																				  const this_t sp(*this);																				  ptr_ -= (index_t) stride_; 																				  return sp;																				}				this_t&					operator+=(index_t i)						{ 																				  ptr_ += (stride_ * i); 																				  return *this; 																				}				this_t&					operator-=(index_t i)						{ 																				  ptr_ -= (stride_ * i); 																				  return *this; 																				}friend 			std::ostream &				operator<<(std::ostream &os, const this_t &cs)	{																				  os << cs.ptr_ << " (" << cs.stride_ << ")";																				  return os;																				}//protected:friend class const_slice<T, stride_t>;				T					   *ptr_;		  const stride_t				stride_;		};#pragma mark const_slicetemplate<class T, class S = index_t>class const_slice {public:				typedef const_slice<T,S> this_t;				typedef slice<T,S>		volatile_t;				typedef S 				stride_t;														const_slice(const T *ptr, stride_t stride)	: ptr_(ptr), stride_(stride) {}										const_slice(const const_slice &cs)			: ptr_(cs.ptr_), stride_(cs.stride_) {}														this_t					operator= (const     this_t &s)				{ ptr_ = s.ptr_; stride_ = s.stride_; return *this; }				bool					operator==(const volatile_t &s) const		{ return (ptr_ == s.ptr_) && (stride_ == s.stride_); }				bool					operator==(const     this_t &s) const		{ return (ptr_ == s.ptr_) && (stride_ == s.stride_); }				bool					operator!=(const volatile_t &s) const		{ return (ptr_ != s.ptr_) || (stride_ != s.stride_); }				bool					operator!=(const     this_t &s) const		{ return (ptr_ != s.ptr_) || (stride_ != s.stride_); }						  const T					   &operator* (void) const						{ return *ptr_; }				this_t					operator++(void)	/* preincrement */		{ 																					  ptr_ += (index_t) stride_; 																					  return *this; 																					}		  const this_t					operator++(int)		/* postincrement */		{																					  const this_t sp(*this);																					  ptr_ += (index_t) stride_; 																					  return sp;																					}				this_t					operator--(void)	/* predecrement */		{ 																					  ptr_ -= (index_t) stride_; 																					  return *this; 																					}		  const this_t					operator--(int)		/* postdecrement */			{																					  const this_t sp(*this);																					  ptr_ -= (index_t) stride_; 																					  return sp;																					}				this_t &				operator+=(index_t i)						{ 																					  ptr_ += (stride_ * i); 																					  return *this; 																					}				this_t &				operator-=(index_t i)						{ 																					  ptr_ -= (stride_ * i); 																					  return *this; 																					}friend 			std::ostream &				operator<<(std::ostream &os, const this_t &cs)	{																					  os << cs.ptr_ << " (" << cs.stride_ << ")";																					  return os;																					}//private:friend class slice<T, stride_t>;		  const T					   *ptr_;		  const stride_t				stride_;		};#pragma mark slice_iteratortemplate<class T, class S = index_t>class slice_iterator : public ptr_iterator<T, slice<T,S>, const_slice<T,S> > {public:				typedef slice_iterator<T,S> this_t;								typedef T elem_t;				typedef S stride_t;														slice_iterator(T *ptr, S stride)					: ptr_iterator<T, slice<T,S>, const_slice<T,S> >(slice<T,S>(ptr, stride)) {}										slice_iterator(const this_t &pit) 					: ptr_iterator<T, slice<T,S>, const_slice<T,S> >(pit) {}				this_t&					operator= (const this_t &sit)						{ this->ptr_ = sit.ptr_; this->stride_ = sit.stride_; return *this; }								this_t					operator++(void) /* preincrement */					{ ++this->ptr_; return *this; }		  const this_t					operator++(int)  /* postincrement */				{																							  const this_t rit(*this);																							  ++this->ptr_;																							  return rit;																							}				this_t					operator--(void) /* predecrement */					{ --this->ptr_; return *this; }		  const this_t					operator--(int)  /* postdecrement */				{																							  const this_t rit(*this);																							  --this->ptr_;																							  return rit;																							}				this_t					operator+=(int inc)									{ this->ptr_ += inc; return *this; }				this_t					operator-=(int dec)									{ this->ptr_ -= dec; return *this; }				};template<class T, class S = index_t>class const_slice_iterator : public const_ptr_iterator<T, slice<T,S>, const_slice<T,S> > {public:			typedef const_slice_iterator<T,S> this_t;							typedef T elem_t;				typedef S stride_t;														const_slice_iterator(const T *ptr, S stride)		: const_ptr_iterator<T, slice<T,S>, const_slice<T,S> >(const_slice<T,S>(ptr, stride)) {}										const_slice_iterator(const this_t &spit) 			: const_ptr_iterator<T, slice<T,S>, const_slice<T,S> >(spit) {}				this_t&					operator= (const this_t &sit)						{ this->ptr_ = sit.ptr_; this->stride_ = sit.stride_; return *this; }				this_t					operator++(void) /* preincrement */					{ ++this->ptr_; return *this; }		  const this_t					operator++(int)  /* postincrement */				{																							  const this_t rit(*this);																							  ++this->ptr_;																							  return rit;																							}				this_t					operator--(void) /* predecrement */					{ --this->ptr_; return *this; }		  const this_t					operator--(int)  /* postdecrement */				{																							  const this_t rit(*this);																							  --this->ptr_;																							  return rit;																							}				this_t					operator+=(int inc)									{ this->ptr_ += (unsigned short) inc; return *this; }				this_t					operator-=(int dec)									{ this->ptr_ -= (unsigned short) dec; return *this; }				};template<class Map> class map_key_iterator {};template<class Key, class Value> class map_key_iterator<std::map<Key,Value> > {public:		typedef map_key_iterator<std::map<Key,Value> > this_t;		typedef Key						key_t;											map_key_iterator(void) 								: mit_() {}										map_key_iterator(const this_t &it) 					: mit_(it.mit_) {} 										map_key_iterator(const typename std::map<Key,Value>::const_iterator mit)	: mit_(mit) {}				key_t					operator * (void) const								{ return mit_->first; }		  const key_t*					operator ->(void) const 							{ return &(mit_->first);}				this_t&					operator ++(void) 									{ ++mit_; return *this;}				this_t					operator ++(int)									{ this_t temp(*this); ++mit_; return temp; }				this_t&					operator --(void)									{ --mit_; return *this;}				this_t					operator --(int)									{this_t temp(*this); --mit_; return temp;}friend			bool					operator ==(const this_t& x, const this_t& y)		{return x.mit_ == y.mit_;}friend			bool 					operator !=(const this_t& x, const this_t& y)		{return x.mit_ != y.mit_;}private:				typename std::map<Key,Value>::const_iterator	mit_;};				} /* namespace colorfield */#endif /* __GENERIC_ITERATORS_H */