/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 2001 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __REF_WRAPPER_H#define __REF_WRAPPER_H#include <stdexcept>// To Do://// - add debug-time ref verification// - support for get_retain_count?namespace colorfield {/*1.					2.					3.				4.*/template<class Traits> class ref_wrapper;template<typename Ref, Ref Null = NULL, typename Exception = std::runtime_error>class simple_ref_traits{public:			typedef simple_ref_traits<Ref, Null, Exception>	this_t;			typedef Ref								ref_t;			typedef Exception						exception_t;			typedef ref_wrapper<this_t>				wrapper_t;static		  const ref_t				null_;static				bool				is_allocated(ref_t ref)				{ return ref != null_; }//static				void				require_null(ref_t ref)				{ if (ref != null_) throw exception_t("non-null ref"); }//static				void				require_nonnull(ref_t ref)			{ if (ref == null_) throw exception_t("null ref"); }};template<typename Ref, Ref Null, typename Exception>const Ref simple_ref_traits<Ref, Null, Exception>::null_ = Null;template<typename Ref, Ref Null, typename Exception> class ref_wrapper<simple_ref_traits<Ref, Null, Exception> > {public:			typedef ref_wrapper<simple_ref_traits<Ref, Null, Exception> >	this_t;			typedef simple_ref_traits<Ref, Null, Exception>	 			traits_t;			typedef traits_t::ref_t								ref_t;			typedef boost::call_traits<ref_t>::reference		ref_ref_t;			typedef boost::call_traits<ref_t>::const_reference	const_ref_ref_t;													ref_wrapper(void) 			: ref_(traits_t::null_) {}										ref_wrapper(const this_t &d)  : ref_(d.ref_) {}										ref_wrapper(ref_t ref) 		: ref_(ref) {}										this_t&				operator= (const this_t &d) 	{ set_ref(d); return *this; }					this_t&				operator= (ref_t ref) 		{ set_ref(ref); return *this; }										bool				operator==(const this_t& d) const 	{ return ref_ == d.ref_; }					bool				operator==(ref_t ref) const 			{ return ref_ == ref; }					bool				operator!=(const this_t& d) const 	{ return ref_ != d.ref_; }					bool				operator!=(ref_t ref) const 			{ return ref_ != ref; }										bool				operator< (const this_t& d) const 	{ return ref_ < d.ref_; }															operator const_ref_ref_t(void) const 																			{ return ref_; }										operator ref_ref_t(void) 	{ return ref_; }					ref_t				get_ref(void) const			{ return ref_; }										bool				is_allocated(void) const 	{ return traits_t::is_allocated(ref_); }													ref_t				detach(void) 				{ ref_t tmp = ref_; set_ref(traits_t::null_); return tmp; }					void				require_ref(void) const		{ require_nonnull(ref_); }protected:					void				set_ref(ref_t ref) 			{ ref_ = ref; }					traits_t::ref_t		ref_;};template<typename Ref, void (Dispose)(Ref), Ref Null = NULL, typename Exception = std::runtime_error>class disposable_ref_traits : public simple_ref_traits<Ref, Null, Exception> {public:			typedef disposable_ref_traits<Ref, Dispose, Null, Exception>	this_t;			typedef simple_ref_traits<Ref, Null, Exception> base_t;			typedef Ref					ref_t;			typedef ref_wrapper<this_t>	wrapper_t;static				void				dispose(ref_t ref)				{ Dispose(ref); }					};template<typename Ref, void (Dispose)(Ref), Ref Null, typename Exception>class ref_wrapper<disposable_ref_traits<Ref,Dispose,Null, Exception> > : public ref_wrapper<simple_ref_traits<Ref,Null, Exception> > {public:			typedef ref_wrapper<disposable_ref_traits<Ref,Dispose,Null, Exception> >	this_t;			typedef ref_wrapper<simple_ref_traits<Ref, Null, Exception> > 				base_t;			typedef disposable_ref_traits<Ref, Dispose, Null, Exception> 				traits_t;			typedef traits_t::ref_t										ref_t;						class auto_dispose : boost::noncopyable {			public:										auto_dispose(ref_t r)			: ref_(r) {}										~auto_dispose(void)				{ if (ref_ != traits_t::null_) traits_t::dispose(ref_); }										operator this_t(void)			{ return ref_; }					ref_t				detach(void)					{ ref_t r = ref_; ref_ = traits_t::null_; return r; }			private:					ref_t				ref_;			};										ref_wrapper(void)				: base_t(traits_t::null_) {}										ref_wrapper(const this_t &d)	: base_t(d.ref_) {}										ref_wrapper(ref_t ref)			: base_t(ref) {}										this_t&				operator= (const this_t &d)		{ base_t::operator=(d); return *this; }					this_t&				operator= (ref_t ref)			{ base_t::operator=(ref); return *this; }										void				dispose(void)					{ if (ref_ != traits_t::null_) traits_t::dispose(ref_); }					};template<typename Ref, Ref (Acquire)(Ref), void (Release)(Ref), Ref Null = NULL, typename Exception = std::runtime_error>class refcounted_ref_traits : public simple_ref_traits<Ref, Null, Exception> {public:			typedef refcounted_ref_traits<Ref, Acquire, Release, Null, Exception>	this_t;			typedef simple_ref_traits<Ref, Null, Exception>				base_t;			typedef Ref													ref_t;			typedef ref_wrapper<this_t>									wrapper_t;static				ref_t				acquire(ref_t ref)				{ return Acquire(ref); }static				void				release(ref_t ref)				{ Release(ref); }					};template<typename Ref, Ref (Acquire)(Ref), void (Release)(Ref), Ref Null, typename Exception>class ref_wrapper<refcounted_ref_traits<Ref,Acquire,Release,Null, Exception> > 	: public ref_wrapper<refcounted_ref_traits<Ref,Acquire,Release,Null, Exception>::base_t> {public:			typedef refcounted_ref_traits<Ref,Acquire,Release,Null, Exception> 				traits_t;			typedef ref_wrapper<traits_t>	this_t;			typedef ref_wrapper<traits_t::base_t>			base_t;			typedef traits_t::ref_t		ref_t;						class auto_release : boost::noncopyable {			public:										auto_release(ref_t r)			: ref_(r) {}										~auto_release(void)				{ if (ref_ != traits_t::null_) traits_t::release(ref_); }										operator this_t(void)			{ return ref_; }					ref_t				detach(void)					{ ref_t r = ref_; ref_ = traits_t::null_; return r; }			private:					ref_t				ref_;			};										ref_wrapper(void)				: base_t(traits_t::null_) {}										ref_wrapper(ref_t ref)			: base_t(ref) {}										ref_wrapper(const this_t &d)	: base_t(d.ref_) {}										this_t&				operator= (const this_t &d)		{ base_t::operator=(d); return *this; }					this_t&				operator= (ref_t ref)			{ base_t::operator=(ref); return *this; }										this_t&				acquire(void)					{ require_ref(); traits_t::acquire(ref_); return *this; }			  const this_t&				acquire(void) const				{ require_ref(); traits_t::acquire(ref_); return *this; }					void				release(void) const				{ if (ref_ != traits_t::null_) traits_t::release(ref_); }};} // namespace colorfield#endif /* __REF_WRAPPER_H */