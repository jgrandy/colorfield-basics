/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __SIMULATION_H#define __SIMULATION_H#include "simcore.h"#include "matrix.h"#include "matrix-inst.h"#include "nonlinear-solver.h"#include "vector-function.h"#include "objective-function.h"#include <list>namespace cf_simcore {// A simulation is:////   - the current time (t_)//   - the current state (q_)//// Each step increases the current time, and produces// a new state.//// The simulation advances according to a function of// four other values://   - the derivative of the current state wrt time (qdot)//   - the constraints computed relative to state (C(q))//   - the derivative of the constraints computed relative to state (dCdq); and//   - the objective function computed relative to state and time//// State is traditionally a column vector, as are constraints. This makes// the derivative of the constraints wrt the current state a matrix with// height equal to the number of constraints and width equal to the number// of state variables.//// The objective is a sum-of-squares of vector functions of the state. Hence,// it is a matrix, row and column dimensions equal to the number of state// variables. It is symmetric along the diagonal.//// If the simulation has boundary constraints, then their values are// computed as well, and used to determine whether to impose temporary// additional constraints on the system.///*1.				2.						3.									4.*/class simulation {public:					// Types		typedef simulation				this_t;				typedef scalar_t				time_t;		typedef scalar_t				scalar_t;			typedef	matrixn1				q_t;		typedef matrixn1				qdot_t;				typedef nonlinear_solver<q_t>	solver_t;		typedef matrixn1				pq_t;		typedef matrixn					dpqdq_t;		typedef vector_function			q_accessor_t;									// Construction/Destruction														simulation(      solver_t *solver,												   const time_t &initial_time,												   const q_t    &initial_state)										  : solver_(solver),										    t_(initial_time),										    q_(new q_t(initial_state)),										    state_accessors_(0)										  {}										  										simulation(      solver_t *solver,												   const time_t &initial_time)										  : solver_(solver),										    t_(initial_time),										    q_(new q_t(zero,one)),										    state_accessors_(0)										  {}virtual									~simulation(void);					// Simulation Controlvirtual			time_t					step(time_t delta);											// attempts to step by the given delta.											// returns the time at completion of the step.																// State Management		  const q_accessor_t*			add_state(const pq_t &pq);				void					remove_state(const q_accessor_t *qf);												// Accessors											// return current simulation time		  const time_t&					time(void) const					{ return t_; }											// return current simulation state		  const q_t&					state(void) const					{ return *q_; }				void					state(q_t &q) const					{ q = *q_; }				void					state(pq_t &pq, const q_accessor_t *qf)	{ qf->apply(pq, (scalar_t) 1, *q_); }				protected:				solver_t*				solver(void)						{ return solver_; }				void					set_solver(solver_t *solver)		{ delete solver_; solver_ = solver; }				protected:virtual			void					set_state(q_t *new_q);virtual			void					set_state(const q_t &new_q);virtual			void					set_time(const time_t &new_t);private:				class state_vf {											public:							typedef state_vf				this_t;							typedef colorfield::range_t<>	range_t;							typedef range_t::length_t		result_size_t;																			state_vf(range_t r)						: range_(r) {}												state_vf(const this_t &s)				: range_(s.range_) {}																			this_t&				operator= (const this_t &s)				{ range_ = s.range_; return *this; }														this_t&				operator+=(index_t t)					{ range_ = range_ + t; return *this; }							this_t&				operator-=(index_t t)					{ range_ = range_ - t; return *this; }				template<class q_t, class result_t>							void				apply(result_t &r, const scalar_t &a, const q_t &q) const		{ axpy(a, q.rows(range_), (scalar_t) 1, r); }				template<class q_t, class dfdq_t> 							void				derive(dfdq_t &dfdq, const scalar_t &a, const q_t &) const		{ typename matrix_traits<dfdq_t,range_t>::cols_t dc(dfdq,range_,column_axis); set_diagonal(dc, a); }				template<class q_t, class result_t, class dfdq_t>							void				apply_derive(result_t &r, dfdq_t &dfdq, const scalar_t &a, const q_t &q) const	{ axpy(a, q.rows(range_), (scalar_t) 1, r); typename matrix_traits<dfdq_t,range_t>::cols_t dc(dfdq,range_,column_axis); set_diagonal(dc, a); }				template<class q_size_t>							result_size_t		result_size(const q_size_t &) const		{ return range_.length(); }				friend		std::ostream&		operator<<(std::ostream &os, const this_t &vf)	{ return (os << "state" << vf.range_); }							range_t				range_;				};				typedef generic_vf<state_vf>	generic_state_vf;				typedef std::list<generic_state_vf*>	state_accessors_t;private:				solver_t*				solver_;				time_t					t_;				q_t *					q_;				state_accessors_t		state_accessors_;};} // namespace cf_simcore#endif /* __SIMULATION_H */