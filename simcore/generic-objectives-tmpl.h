/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __GENERIC_OBJECTIVES_TMPL_H#define __GENERIC_OBJECTIVES_TMPL_H#include "simulation.h"#include "objective-function.h"#include "vector-function.h"#include "matrix-inst.h"namespace cf_simcore {template<class R> class attractor : public objective_function<R> {public:/*	Interactive dragging objective		We want particle ci(q) to head toward cm, the objective particle. That is, we want particle i's velocity (v0)	to be:			v0 = k(cm - ci)																	  v0 : ci-size x 1		Another way of stating the goal is that we want to minimize an energy measure relating actual velocity (dci/dt)	to desired velocity (v0).			e = 1/2  *  (v0  -  dci/dt) ^ 2													   e : scalar																					  dci/dt : ci-size x 1			e = 1/2  *  (v0  -  dci/dq * qdot)T  *  (v0  -  dci/dq * qdot)				  dci/dq : ci-size x q-size																					 	qdot : q-size x 1		de/dqdot  = d/dqdot((v0  -  dci/dq * qdot)T)  *  (v0  -  dci/dq * qdot)  +					(v0  -  dci/dq * qdot)T  *  d/dqdot(v0  -  dci/dq * qdot)				  				  = d/dqdot((- dci/dq * qdot)T)  *  (v0  -  dci/dq * qdot)  +					(v0  -  dci/dq * qdot)T  *  d/dqdot(- dci/dq * qdot)									  = (- dci/dq)T  *  (v0  -  dci/dq * qdot)  +					(v0  -  dci/dq * qdot)T  *  (- dci/dq)									  = -(dci/dq)T * v0  +  (dci/dq)T * dci/dq * qdot  +					-(v0)T * dci/dq  +  (dci/dq * qdot)T * dci/dq								  = -(dci/dq)T * v0  +  -(v0)T * dci/dq  +					 (dci/dq)T * dci/dq * qdot  +  (dci/dq * qdot)T * dci/dq							  = - 2 * (dci/dq)T * v0  +  2 * (dci/dq)T * dci/dq * qdot				  				  = 2 * (dci/dq)T * dci/dq * qdot  -  2 * (dci/dq)T * v0		   de/dqdot : 1 x q-size						 	So, if de/dqdot = M * qdot - b, then				M  =  2 * (dci/dq)T * dci/dq													  M : q-size x q-size				b  =  2 * (dci/dq)T * k * (cm - ci)												  b : q-size x 1	Note that cm is not a function of t or q, it is an independent vector value chosen at the	beginning of the computation. (It might change between computations -- before each step() -- 	but we don't care about that.)*/					// Types				typedef attractor<R>			this_t;				typedef objective_function<R>	base_t;								typedef typename base_t::time_t			time_t;				typedef typename base_t::q_t				q_t;								typedef typename base_t::objective_t		objective_t;				typedef typename base_t::M_t				M_t;				typedef typename base_t::b_t				b_t;								typedef matrixn1				time_store_t;				typedef typename matrix_traits<b_t,q_t>::deriv_t dci_t;									typedef vector_function			ci_f_t;		// point being attracted				typedef vector_function			cm_f_t;		// point attracting				typedef vector_function			k_f_t;		// attraction strength														attractor(const ci_f_t *ci_f, 												  const cm_f_t *cm_f,												  const k_f_t * k_f)										  : k_(0.0), 										    ci_f_(ci_f),										    cm_f_(cm_f),										    k_f_(k_f),										    cm_(cm_f_->result_size(one),one)										  {}										attractor(const scalar_t &k, 												  const ci_f_t *ci_f, 												  const cm_f_t *cm_f)										  : k_(k), 										    ci_f_(ci_f),										    cm_f_(cm_f),										    k_f_(NULL),										    cm_(cm_f_->result_size(one),one)										  {}virtual			bool					accumulate_dEdqdot(M_t &M, b_t &b, const q_t &q) const;	virtual			void					update(const time_t &t, const q_t &q);		  const ci_f_t*					attractee_accessor(void) const				{ return ci_f_; }		  const k_f_t*					mouse_accessor(void) const					{ return cm_f_; }		  const b_t&					current_mouse_position(void) const			{ return cm_; }		  protected:				scalar_t				k_;		  const ci_f_t*					ci_f_;		  const cm_f_t*					cm_f_;		  const k_f_t*					k_f_;				b_t						cm_;};template<class R>bool attractor<R>::accumulate_dEdqdot(M_t &M, b_t &b, const q_t &q) const{	const typename q_t::height_t q_size = q.height();	const typename b_t::height_t ci_size = (*ci_f_).result_size(q_size);	AC_PRECONDITION(b.width() == 1)	AC_PRECONDITION(M.width() == M.height())	AC_PRECONDITION(b.height() == M.width())	AC_PRECONDITION(b.height() == q_size)		b_t v0 (cm_.extent());	dci_t dci(ci_size, q_size, init_zero);		// v0 = k(ci - cm)	v0 = cm_;//clog << "cm: " << cm_ << endl;//clog << "q: " << q << endl;	(*ci_f_).apply_derive(v0, dci, (scalar_t) -1.0, q);				// this negates the derivative -- which we don't want, so we correct...//	if (has_nan(v0)) ::Debugger();//	if (norm_maxabs(v0) > 1.0f) ::Debugger();//clog << "cm - ci : " << v0 << endl;//clog << "angle: " << atan(v0(two,zero) / v0(one,zero)) << endl;//clog << "- dci: " << dci << endl;	typename dci_t::transpose_t dci_T = dci.transpose();//clog << "- dci_T: " << dci_T << endl;	axpy((scalar_t) - 2.0 * k_, dci_T, v0 , (scalar_t) 1, b);		// ...by negating the scalar multiplier here	axpy((scalar_t)   2.0 , dci_T, dci, (scalar_t) 1, M);			return true;}template<class R>void attractor<R>::update(const time_t &t, const q_t &){	time_store_t t_store(one,one);	t_store(zero,zero) = t;		cm_ = (scalar_t) 0.0;	(*cm_f_).apply(cm_, scalar1, t_store);//	if (has_nan(cm_)) ::Debugger();//	if (norm_maxabs(cm_) > 1.0f) ::Debugger();//clog << "\t// cm(" << t << ") = " << cm_ << endl;	if (k_f_ != NULL) {		time_store_t k_store(one,one);		k_store(zero,zero) = 0.0;		(*k_f_).apply(k_store, scalar1, t_store);		k_ = k_store(zero,zero);	}}} // namespace cf_simcore#endif /* __GENERIC_OBJECTIVES_TMPL_H */