/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __CONSTRAINED_SIMULATION_H#define __CONSTRAINED_SIMULATION_H#include "simulation.h"#include "vector-function.h"//#include "vector-function-tmpl.h"namespace cf_simcore {class constrained_simulation : public simulation {	public:							//Types								typedef constrained_simulation				this_t;				typedef simulation							base_t;				typedef base_t::time_t						time_t;				typedef base_t::q_t							q_t;				typedef base_t::qdot_t						qdot_t;				typedef base_t::solver_t					solver_t;												typedef base_t::pq_t						pq_t;				typedef base_t::dpqdq_t						dpqdq_t;				typedef base_t::q_accessor_t				q_accessor_t;				typedef matrixn1 							C_t;				typedef matrix_traits<C_t,q_t>::deriv_t		dCdq_t;				typedef vector_function						constraints_t;											typedef C_t::rows_t							pC_t;				typedef matrix_traits<pC_t,q_t>::deriv_t	dpCdq_t;				typedef vector_function						constraint_t;					typedef objective_function<q_t>				objective_t;				typedef stacked_of<objective_t>				objectives_t;private:				typedef stacked_vf<constraint_t>			constraint_list_t;				typedef generic_vf<constraint_list_t>		constraints_store_t;				constraints_store_t		constraints_;	 			objectives_t			objectives_;public:					// Construction/Destruction															constrained_simulation(      solver_t *solver,												   			   const time_t &initial_time)										  : base_t(solver, initial_time),										    constraints_(constraint_list_t()),										    objectives_()										    {}										virtual									~constrained_simulation(void);					// Simulation Controlvirtual			time_t					step(time_t delta);					// Simulation State		  const constraints_t*			constraints(void) const						 	{ return &constraints_; }				void					add_constraint(const constraint_t * vf)			{ constraints_.prim().add(vf); }				void					remove_constraint(const constraint_t * vf)		{ constraints_.prim().remove(vf); }				bool					is_constraint(const constraint_t * vf) const	{ return constraints_.prim().find(vf); }		  		  const objectives_t*			objectives(void) const							{ return &objectives_; }				objectives_t*			objectives(void)								{ return &objectives_; }				void					add_objective(objective_t *of)					{ objectives_.add(of); }				void					remove_objective(objective_t *of)				{ objectives_.remove(of); }				bool					is_objective(objective_t *of)	 				{ return objectives_.find(of); }		  };} // namespace cf_simcore#endif /* __CONSTRAINED_SIMULATION_H */