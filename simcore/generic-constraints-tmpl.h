/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1995 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __GENERIC_CONSTRAINTS_TMPL_H#define __GENERIC_CONSTRAINTS_TMPL_H#include "simcore.h"#include "vector-function.h"namespace cf_simcore {template<class Sim, class VF1, class VF2>void add_delta_constraint(Sim &sim, const vector_function_adaptor<VF1> f1, const vector_function_adaptor<VF2> f2){	typedef state_vector_adaptor<summed_vector_function<VF1,VF2> > diff_t;	diff_t delta_f = state_f(f1 - f2);	typedef primitive_state_function<Sim::time_t,Sim::result_t,Sim::part_C_t,Sim::part_dCdq_t,diff_t> abstract_diff_t;		abstract_diff_t *adf_ptr = new abstract_diff_t(delta_f);	sim.add_constraint(adf_ptr);}template<class Sim, class VF1, class Store, class Structure, class Block>void add_delta_constraint(Sim &sim, const vector_function_adaptor<VF1> f1, const base_matrix<Store,Structure,Block> &q){	matrixn1 k(f1.result_size(q.height()), one);		f1.eval(k, q, false);		typedef constant_vector_function<matrixn1> VF2;	vector_function_adaptor<VF2> f2 = adapt_vf(constant_f(k));	add_delta_constraint(sim,f1,f2);}template<class Sim, class VF1, class VF2, class Store, class Structure, class Block>void add_delta_constraint(Sim &sim, const vector_function_adaptor<VF1> f1, const vector_function_adaptor<VF2> f2, const base_matrix<Store,Structure,Block> &q){	matrixn1 k(f1.result_size(q.height()), one);		f1.eval(k, q, false);	k *= (matrixn1::scalar_t) -1.0;	f2.eval(k, q, true);			typedef constant_vector_function<matrixn1> VF3;	vector_function_adaptor<VF3> f3 = adapt_vf(constant_f(k));	add_delta_constraint(sim,f1 - f2, f3);}template<class Sim, class VF, class PF>void add_delta_constraint(Sim &sim, const vector_function_adaptor<VF> f1, 									const parametric_function_adaptor<PF> f2){	typedef summed_state_function<state_vector_adaptor<VF>, state_parametric_adaptor<PF> > diff_t;	diff_t delta_f = state_f(f1) - state_f(f2);	typedef primitive_state_function<Sim::time_t,Sim::result_t,Sim::C_t,Sim::dCdq_t,diff_t> abstract_diff_t;	abstract_diff_t *adf_ptr = new abstract_diff_t(delta_f);	sim.add_constraint(adf_ptr);}template<class Sim, class VF1, class VF2, class VF3>void add_delta_constraint(Sim &sim, const vector_function_adaptor<VF1> f1, 									const vector_function_adaptor<VF2> f2, 									const vector_function_adaptor<VF3> f3){	typedef state_vector_adaptor<summed_vector_function<summed_vector_function<VF1,VF2>, VF3> > diff_t;	diff_t diff_f = state_f((f1 - f2) - f3);	typedef primitive_state_function<Sim::time_t,Sim::result_t,Sim::C_t,Sim::dCdq_t,diff_t> abstract_diff_t;	abstract_diff_t adelta_f(delta_f);	sim.add_constraint(new abstract_diff_t(adelta_f));}} // namespace cf_simcore#endif /* __GENERIC_CONSTRAINTS_TMPL_H */