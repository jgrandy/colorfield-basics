/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __OBJECTIVE_FUNCTION_H#define __OBJECTIVE_FUNCTION_H#include "simcore.h"#include "vector-function.h"#include <list>namespace cf_simcore {template<class R = matrixn1> class objective_function {public:					// Types				typedef scalar_t        time_t;				typedef scalar_t        scalar_t;				typedef R			q_t;				typedef typename matrix_traits<q_t,typename q_t::transpose_t>::multiply_t	objective_t;				typedef objective_t										M_t;				typedef q_t												b_t;virtual			bool					accumulate_dEdqdot(M_t &M, b_t &b, const q_t &q) const = 0;											// dEdqdot = M*qdot + b											// we must compute the M and the b, since qdot is the unknown.virtual			void					update(const time_t &t, const q_t &q) = 0;};template<class F>class stacked_of : public objective_function<typename F::q_t> {public:				typedef stacked_of<F>					this_t;				typedef objective_function<typename F::q_t>		base_t;											typedef typename base_t::time_t		time_t;				typedef typename base_t::q_t			q_t;								typedef typename base_t::objective_t	objective_t;				typedef typename base_t::M_t			M_t;				typedef typename base_t::b_t			b_t;										~stacked_of(void);virtual			bool					accumulate_dEdqdot(M_t &M, b_t &b, const q_t &q) const;virtual			void					update(const time_t &t, const q_t &q);				void					add(F * const);				void					remove(F * const);				bool					find(F * const f) const				{ return (std::find(functions_.begin(),functions_.end(),f) != functions_.end()); }				bool					empty(void) const					{ return functions_.empty(); }protected:										typedef std::list<F*>	functions_t;			functions_t					functions_;};} // namespace cf_simcore#endif /* __OBJECTIVE_FUNCTION_H */