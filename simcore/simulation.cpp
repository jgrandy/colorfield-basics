/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#include "simulation.h"#include "matrix-ops-multiply-tmpl.h"namespace cf_algebra {    template cvector& axpy(const scalar_t &a, const cvector &x, const scalar_t &b, cvector &y);}namespace cf_simcore {simulation::~simulation(void){}typename simulation::time_t simulation::step(time_t delta){	const time_t        t0 = time(),				        t1 = t0 + delta,				 step_size = delta;	solver_->suggest_step_size(step_size);		const q_t &q = this->state();	time_t t;	if (q.height() == 0) {			t = solver_->get_time() + delta;		solver_->set_time(t);	} else {			index_t steps = 0;				do {			t = solver_->step();			steps++;		} while ((steps < 5) && (t < t1));		set_time(solver_->get_time());		set_state(solver_->get_state());	}			return t;}const typename simulation::q_accessor_t* simulation::add_state(const pq_t &pq){//	clog << "adding: " << pq << " to " << state_accessors_.size() << endl;		index_t next_start, next_len;		// find last state accessor	if (state_accessors_.size() > 0) {			const generic_state_vf *last = state_accessors_.back();//		std::assert(last != NULL);		//		clog << "last: " << *last << " (" << last << ')' << endl;			const state_vf &last_state = *last;			// compute start of next accessor		next_start = (index_t) (last_state.range_.start() + last_state.range_.length());			} else {		next_start = 0;	}		next_len   = pq.height();//	clog << "adding from " << next_start << " len " << next_len << endl;		// create accessor and add it to accessor list	const colorfield::range_t<> new_range(next_start, next_len);	generic_state_vf *new_accessor = new generic_state_vf(state_vf(new_range));	state_accessors_.push_back(new_accessor);		// update state vector with new state		q_t *new_q = new q_t((index_t) (next_start+next_len),one);	const q_t &old_q = state();	new_q->rows(range(zero,next_start)) = old_q;	new_q->rows(new_range) = pq;	//	clog << "new q: " << new_q << endl;		set_state(new_q);		return new_accessor;}void simulation::remove_state(const q_accessor_t *qf){	// find state accessor in list	state_accessors_t::iterator it = state_accessors_.begin(),								it_end = state_accessors_.end();	while ((it != it_end) && (*it != qf))		++it;		state_accessors_t::iterator it2 = it;	++it;	// note its state length	const state_vf &dead_state = (const state_vf&) (*it2);	const index_t splice = dead_state.range_.start(),				    gap = dead_state.range_.length();		// remove it	state_accessors_.erase(it2);		// update remaining accessors in list	while (it != it_end) {		state_vf &s = (state_vf&) (*it);		++it;		s -= gap;	}		// update state	const q_t &old_q = state();	const index_t new_height = (index_t) (old_q.height() - gap);	q_t *new_q = new q_t(new_height, one);	new_q->rows(range(zero,splice)) = old_q.rows(range(zero,splice));	new_q->rows(range(splice,(index_t)(new_height - splice))) = old_q.rows(range((index_t)(splice+gap),(index_t)(new_height-splice)));		set_state(new_q);}void simulation::set_state(q_t *new_q){	delete q_; q_ = new_q;	solver_->set_state1(time(), state());} void simulation::set_state(const q_t &new_q){	delete q_; q_ = new q_t(new_q);	solver_->set_state1(time(), state());} void simulation::set_time(const time_t &new_t){	t_ = new_t; 	solver_->set_time(time());}} // namespace cf_simcore