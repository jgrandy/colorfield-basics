/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#pragma inline_depth(12)#pragma inline_bottom_up on#include "first-order-simulation.h"#include "cholesky.tmpl.h"#include "runge-kutta.tmpl.h"#include "conjugate-gradient-tmpl.h"#include "objective-function-tmpl.h"#include "matrix-ops-multiply-tmpl.h"//#include "vector-function-tmpl.h"#include "matrix-ops.h"#include "matrix-io.h"#include "cf-debug.h"namespace cf_algebra {    template class adaptive_rk4_solver<cf_simcore::first_order_simulation::q_t>;}namespace cf_simcore {    using std::clog;using std::endl;    first_order_simulation::system::system(const simulation_t &sim, const scalar_t &damping)  : simulation_(sim), damping_(damping),    M_matrix(NULL), W_matrix(NULL), b_vector(NULL),    C_vector(NULL), J_matrix(NULL),    lhs_matrix(NULL), JW_matrix(NULL),    rhs_vector(NULL), lambda_vector(NULL),    JT_lambda_vector(NULL),    linear_solver_(NULL){}/*	We want to minimize an energy measure E, a scalar, subject to any active constraints.		Here, C(q) is the function computing those constraints, and J = dC/dq.		To meet our constraints, we have to ensure that	(1)		dE/dqdot = JT * lambda						dE/dqdot : 1 x q-size														  JT : q-size x c-size													  lambda : c-size x 1		and	(2)		J * qdot = - k * C								   J : c-size x q-size		In order to solve for qdot, we must first solve for lambda. Let's assume that E is	a least-squares measure, that is			E = sum( ei(t) )			where each ei(t) is a sum-of-squares term:			ei = 1/2  *  (ki - fi(t)) ^ 2		This lets us write dE/dqdot as	(3)		dE/dqdot =  M * qdot - b			where			M  =  sum( (dfi/dq)T * dfi/dq	)				  M : q-size x q-size, symmetric positive-definite				b  =  sum( (dfi/dq)T * ki )						  b : q-size x 1	Combining (3) and (1), we get			M * qdot - b  =  JT * lambda					M * qdot  =  JT * lambda  +  b			(4)			qdot  =  W * JT * lambda  +  W * b			  W = inverse(M) : q-size x q-size	Substituting (4) into (2), we have		J * (W * JT * lambda  +  W * b)  =  - k * C		J * W * JT * lambda  +  J * W * b  =  - k * C==>		J * W * JT * lambda  =  - J * W * b  -  k * C		*/void first_order_simulation::system::apply (qdot_t &qdot, const q_t &q, const time_t &t) const{	const bool local_debug = cf_debug::verbose_debugging && false;		const q_t::height_t q_size = q.height();	const C_size_t C_size = simulation_.constraints()->result_size(q_size);		this->reset_caches(q_size, C_size);		if (local_debug) {		clog << endl << "t: " << t << " q: " << q << endl;	}	objective_t::M_t &M = *M_matrix;	objective_t::M_t &W = *W_matrix;	q_t &b = *b_vector;	M = scalar0;	set_diagonal(M, (scalar_t) 1.0);	b = scalar0;		bool has_objectives = simulation_.objectives()->accumulate_dEdqdot(M,b,q);		if (has_objectives) {		if (local_debug) {			clog << "M: " << M << endl;			clog << "b: " << b << endl;		}				cholesky_solver<objective_t::M_t,objective_t::b_t,objective_t::b_t> cholesky(M.height());				cholesky.invert(W,M);		// this destroys M									// ***isolate non-identity block to invert?		// preliminary qdot = W * b		matrix_multiply(qdot, W, b);		if (local_debug) {			clog << "W: " << W << endl;			clog << "qdot (prelim): " << qdot << endl;		}	} else {				set_diagonal(M, (scalar_t) 1.0);		W = M;							// M is identity matrix, so inverse is also identity		qdot = scalar0;	// no objective ==> no change	}		if (C_size != 0) {		C_t &C = *C_vector;		dCdq_t &J = *J_matrix;		dCdq_t::transpose_t JT = J.transpose();				C = scalar0;		J = scalar0;		simulation_.constraints()->apply_derive(C,J,(scalar_t) 1,q);					if (local_debug && ! (C == scalar0)) {			// clog << "|C| = " << norm_p2(C) << " |J|: " << norm_p2(J) << " |W|: " << norm_p2(W) << endl;			clog << "C = " << C << " J: " << J << " W: " << W << " JT: " << JT << endl;		}		// lhs = J * W * JT		lhs_t &lhs = *lhs_matrix;					// C_size x C_size		dCdq_t &JW = *JW_matrix;					// C_size x q_size				matrix_multiply(JW, J, W);					// we reuse JW for rhs, below		matrix_multiply(lhs, JW, JT);				// lhs <- J * W * JT		// rhs = - k * C  -  J * W * b		C_t &rhs = *rhs_vector;						// C_size		rhs = C;		rhs *= (scalar_t) - damping_;			// rhs <- - kC		axpy((scalar_t) -1.0, JW, b, (scalar_t) 1, rhs);	// rhs <- rhs - JWb				// J * W * JT * lambda  =  - k * C  -  J * W * b		C_t &lambda = *lambda_vector;		// C_size		if ((lhs == scalar0) || (rhs == scalar0))			lambda = scalar0;		else {			linear_solver_->solve(lhs,lambda,rhs);		}				if (local_debug && ! (lambda == scalar0)) {			clog << "lhs: " << lhs << endl;			clog << "rhs: " << rhs << endl;			clog << "lambda = " << lambda << endl;			clog << "JT = " << JT << endl;			clog << "J = " << J << endl;		}		// qdot  =  W * JT * lambda  +  W * b					// really, qdot += W * (JT * lambda)		q_t &JT_lambda = *JT_lambda_vector;	// q_size		matrix_multiply(JT_lambda, JT, lambda);	// q_size x 1  <--  q_size x C_size  *  C_size				axpy(scalar1, W, JT_lambda, scalar1, qdot);		// q_size x 1  <--  q_size x q_size  *  q_size		if (local_debug && ! (qdot == scalar0)) {			clog << "qdot = " << qdot << endl;		}	}}std::ostream& first_order_simulation::system::put(std::ostream &os) const{	return (os << "particle-system");}void first_order_simulation::system::reset_caches(q_t::height_t q_size, C_size_t C_size) const{	if ((! b_vector) || (b_vector->height() != q_size)) {		if (b_vector) delete b_vector;		b_vector = new q_t(q_size,one_t());				if (M_matrix) delete M_matrix;		M_matrix = new objective_t::M_t(q_size,q_size);		if (W_matrix) delete W_matrix;		W_matrix = new objective_t::M_t(q_size,q_size);		if (JT_lambda_vector) delete JT_lambda_vector;		JT_lambda_vector = new q_t(q_size,one_t());	}		if ((! C_vector) || (C_vector->height() != C_size)) {		if (C_vector) delete C_vector;		C_vector = new C_t(C_size,one_t());				if (lhs_matrix) delete lhs_matrix;		lhs_matrix = new lhs_t(C_size,C_size);				if (rhs_vector) delete rhs_vector;		rhs_vector = new C_t(C_size,one_t());				if (lambda_vector) delete lambda_vector;		lambda_vector = new C_t(C_size,one_t());				if (linear_solver_) delete linear_solver_;		linear_solver_ = new conjugate_gradient_solver<lhs_t,C_t,C_t>(C_size);	}		if ((! J_matrix) || (J_matrix->extent() != coord(C_size,q_size))) {		if (J_matrix) delete J_matrix;		J_matrix = new dCdq_t(C_size,q_size);				if (JW_matrix) delete JW_matrix;		JW_matrix = new dCdq_t(C_size,q_size);			}}} // namespace cf_simcore