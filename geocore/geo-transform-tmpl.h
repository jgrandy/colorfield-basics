/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __GEOMETRY_TRANSFORM_TMPL_H#define __GEOMETRY_TRANSFORM_TMPL_H#include "geo-transform.h"namespace cf_geocore {template<class ROrder, class COrder>template<class Q, class Res, class DR>void rectangular_to_cylindrical<ROrder,COrder>::apply_derive(Res &r, DR &dfdq, const scalar_t &a, const Q &q) const{	const scalar_t x_val = q(ROrder::reorder(zero), zero),				   y_val = q(ROrder::reorder(one ), zero),				   z_val = q(ROrder::reorder(two ), zero);	//	clog << " rect: " << q << endl;		const scalar_t d2 = (x_val * x_val) + (y_val * y_val),				 dist = sqrt(d2);		r(COrder::reorder(zero),zero) += a * dist;	r(COrder::reorder(one ),zero) += a * atan2(y_val,x_val);	r(COrder::reorder(two ),zero) += a * z_val;	//	clog << " cyl: " << r << endl;	dfdq(COrder::reorder(zero),ROrder::reorder(zero)) += (a * x_val) / dist;	dfdq(COrder::reorder(zero),ROrder::reorder(one )) += (a * y_val) / dist;	dfdq(COrder::reorder(one ),ROrder::reorder(zero)) += a * (- y_val) / d2;	dfdq(COrder::reorder(one ),ROrder::reorder(one )) += a * (+ x_val) / d2;		dfdq(COrder::reorder(two ),ROrder::reorder(two )) += a;//	clog << " dcyl: " << dfdq << endl;}template<class ROrder, class COrder>template<class Q, class Res>void rectangular_to_cylindrical<ROrder,COrder>::apply(Res &r, const scalar_t &a, const Q &q) const{	const scalar_t x_val = q(ROrder::reorder(zero), zero),				   y_val = q(ROrder::reorder(one ), zero),				   z_val = q(ROrder::reorder(two ), zero);	//	clog << " rect: " << q << endl;		const scalar_t d2 = (x_val * x_val) + (y_val * y_val),				 dist = sqrt(d2);		r(COrder::reorder(zero),zero) += a * dist;	r(COrder::reorder(one ),zero) += a * atan2(y_val,x_val);	r(COrder::reorder(two ),zero) += a * z_val;	//	clog << " cyl: " << r << endl;}template<class ROrder, class COrder>template<class Q, class DR> void rectangular_to_cylindrical<ROrder,COrder>::derive(DR &dfdq, const scalar_t &a, const Q &q) const{	const scalar_t x_val = q(ROrder::reorder(zero), zero),				   y_val = q(ROrder::reorder(one ), zero),				   z_val = q(ROrder::reorder(two ), zero);	//	clog << " rect: " << q << endl;		const scalar_t d2 = (x_val * x_val) + (y_val * y_val),				 dist = sqrt(d2);		dfdq(COrder::reorder(zero),ROrder::reorder(zero)) += (a * x_val) / dist;	dfdq(COrder::reorder(zero),ROrder::reorder(one )) += (a * y_val) / dist;	dfdq(COrder::reorder(one ),ROrder::reorder(zero)) += a * (- y_val) / d2;	dfdq(COrder::reorder(one ),ROrder::reorder(one )) += a * (+ x_val) / d2;		dfdq(COrder::reorder(two ),ROrder::reorder(two )) += a;//	clog << " dcyl: " << dfdq << endl;}template<class COrder, class ROrder>template<class Q, class Res, class DR>void cylindrical_to_rectangular<COrder,ROrder>::apply_derive(Res &r, DR &dfdq, const scalar_t &a, const Q &q) const{	const scalar_t  r_val = q(COrder::reorder(zero),zero),				theta_val = q(COrder::reorder(one ),zero),					z_val = q(COrder::reorder(two ),zero);		const scalar_t asin_theta = a * sin(theta_val),				   acos_theta = a * cos(theta_val);		r(ROrder::reorder(zero),zero) += acos_theta * r_val;	r(ROrder::reorder(one ),zero) += asin_theta * r_val;	r(ROrder::reorder(two ),zero) += a * z_val;		dfdq(ROrder::reorder(zero), COrder::reorder(zero)) += acos_theta;	dfdq(ROrder::reorder(zero), COrder::reorder(one )) += - asin_theta * r_val;	dfdq(ROrder::reorder(one ), COrder::reorder(zero)) += asin_theta;	dfdq(ROrder::reorder(one ), COrder::reorder(one )) += acos_theta * r_val;	dfdq(ROrder::reorder(two ), COrder::reorder(two )) += a;}template<class COrder, class ROrder>template<class Q, class Res>void cylindrical_to_rectangular<COrder,ROrder>::apply(Res &r, const scalar_t &a, const Q &q) const{	const scalar_t  r_val = q(COrder::reorder(zero),zero),				theta_val = q(COrder::reorder(one ),zero),					z_val = q(COrder::reorder(two ),zero);		const scalar_t asin_theta = a * sin(theta_val),				   acos_theta = a * cos(theta_val);		r(ROrder::reorder(zero),zero) += acos_theta * r_val;	r(ROrder::reorder(one ),zero) += asin_theta * r_val;	r(ROrder::reorder(two ),zero) += a * z_val;}template<class COrder, class ROrder>template<class Q, class DR> void cylindrical_to_rectangular<COrder,ROrder>::derive(DR &dfdq, const scalar_t &a, const Q &q) const{	const scalar_t  r_val = q(COrder::reorder(zero),zero),				theta_val = q(COrder::reorder(one ),zero),					z_val = q(COrder::reorder(two ),zero);		const scalar_t asin_theta = a * sin(theta_val),				   acos_theta = a * cos(theta_val);		dfdq(ROrder::reorder(zero), COrder::reorder(zero)) += acos_theta;	dfdq(ROrder::reorder(zero), COrder::reorder(one )) += - asin_theta * r_val;	dfdq(ROrder::reorder(one ), COrder::reorder(zero)) += asin_theta;	dfdq(ROrder::reorder(one ), COrder::reorder(one )) += acos_theta * r_val;	dfdq(ROrder::reorder(two ), COrder::reorder(two )) += a;}} // namespace cf_geocore#endif /* __GEOMETRY_TRANSFORM_TMPL_H */