/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#include "geo-relations.h"#include "matrix-ops-multiply-tmpl.h"namespace cf_algebra {    template cvector& axpy(const scalar_t &a, const cvector &x, const scalar_t &b, cvector &y);}namespace cf_geocore {relation_id_t point_position::create(system *sys, locus_id_t ptid, space_id_t sid) throw(system::entity_not_found){	const point_position *reln = new point_position(sys,ptid,sid);	std::vector<locus_id_t> loci(1);	loci[0] = ptid;	entity_id_t reln_id = sys->add_relation(reln, this_t::relation_tag, sid, loci);	return reln_id;}relation_id_t point_distance::create(system *sys, locus_id_t pt1, locus_id_t pt2, space_id_t sid) throw(system::entity_not_found){	const point_distance *reln = new point_distance(sys,pt1,pt2,sid);	std::vector<locus_id_t> loci(2);	loci[0] = pt1;	loci[1] = pt2;	entity_id_t reln_id = sys->add_relation(reln, this_t::relation_tag, sid, loci);	return reln_id;}relation_id_t segment_length::create(system *sys, locus_id_t segid, space_id_t sid) throw(system::entity_not_found){	const segment_length *reln = new segment_length(sys,segid,sid);	std::vector<locus_id_t> loci(1);	loci[0] = segid;	entity_id_t reln_id = sys->add_relation(reln, this_t::relation_tag, sid, loci);	return reln_id;}relation_id_t point_angle_distance::create(system *sys, locus_id_t pt1, locus_id_t pt2, space_id_t sid) throw(system::entity_not_found){	const point_angle_distance *reln = new point_angle_distance(sys,pt1,pt2,sid);	std::vector<locus_id_t> loci(2);	loci[0] = pt1;	loci[1] = pt2;	entity_id_t reln_id = sys->add_relation(reln, this_t::relation_tag, sid, loci);	return reln_id;}relation_id_t parametric_distance::create(system *sys, locus_id_t ptid, locus_id_t segid, const cvector &u, space_id_t sid) throw(system::entity_not_found){	const parametric_distance *reln = new parametric_distance(sys,ptid,segid,u,sid);		std::vector<locus_id_t> loci(2);	loci[0] = ptid;	loci[1] = segid;	entity_id_t reln_id = sys->add_relation(reln, this_t::relation_tag, sid, loci);	return reln_id;}relation_id_t parametric_distance::create(system *sys, locus_id_t ptid, locus_id_t segid, const scalar_t &t, space_id_t sid) throw(system::entity_not_found){	cvector u(one,one);	u[zero] = t;	return parametric_distance::create(sys,ptid,segid,u,sid);}} // namespace cf_geocore