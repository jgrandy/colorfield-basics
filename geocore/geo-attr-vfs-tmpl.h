/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __GEOMETRY_ATTR_VFS_TMPL_H#define __GEOMETRY_ATTR_VFS_TMPL_H#include "geo-attr-vfs.h"#include "matrix-ops.h"namespace cf_geocore {    template<class q_t, class result_t>inline void radius_apply(result_t &r, const scalar_t &a, const q_t &q){	const scalar_t x = q(0,0),				   y = q(1,0);		const scalar_t C = sqrt((x * x) + (y * y));		r(0,0) += a * C;	}template<class q_t, class dfdq_t> inline void radius_derive(dfdq_t &dfdq, const scalar_t &a, const q_t &q){	const scalar_t x = q(0,0),				   y = q(1,0);		const scalar_t C = sqrt((x * x) + (y * y));		dfdq(0,0) += (a * x) / C;	dfdq(0,1) += (a * y) / C;}template<class q_t, class result_t, class dfdq_t>inline void radius_apply_derive(result_t &r, dfdq_t &dfdq, const scalar_t &a, const q_t &q){	const scalar_t x = q(0,0),				   y = q(1,0);		const scalar_t C = sqrt((x * x) + (y * y));		r(0,0) += a * C;		dfdq(0,0) += (a * x) / C;	dfdq(0,1) += (a * y) / C;}template<class q_t, class result_t>inline void angle2_apply(result_t &r, const scalar_t &a, const q_t &q){	const scalar_t x = q[zero],				   y = q[one];//		clog << "q[" << zero << "] = " << x;//		clog << " q[" << one << "] = " << y << endl;	r[zero] += a * atan2(y,x);//		clog << "r: " << r << endl;}template<class q_t, class result_t, class dfdq_t>inline void angle2_apply_derive(result_t &r, dfdq_t &dfdq, const scalar_t &a, const q_t &q){	const scalar_t x = q[zero],				   y = q[one];				   //		clog << "q[" << zero << "] = " << x;//		clog << " q[" << one << "] = " << y << endl;	r[zero] += a * atan2(y,x);	const scalar_t dist = (x*x) + (y*y);		dfdq(zero,zero) += a * (- y) / dist;	dfdq(zero,one) += a * (+ x) / dist;	//		clog << "r: " << r << endl;//		clog << "drdq: " << dfdq << endl;}template<class q_t, class dfdq_t> inline void angle2_derive(dfdq_t &dfdq, const scalar_t &a, const q_t &q){	const scalar_t x = q[zero],				   y = q[one];	const scalar_t dist = (x*x) + (y*y);		dfdq(zero,zero) += a * (- y) / dist;	dfdq(zero,one) += a * (+ x) / dist;}template<class VF, class RF>template<class q_t, class result_t>void dynamic_rotation_vf<VF,RF>::apply(result_t &r, const scalar_t &a, const q_t &q) const{	const typename q_t::height_t q_height = q.height();		// compute angle	matrixn1 rf_result(one,one, init_zero);	matrixn rf_deriv(one,q_height, init_zero);	rf_.apply_derive(rf_result, rf_deriv, scalar1, q);	const scalar_t theta = rf_result(zero,zero);	const scalar_t cos_theta = cos(theta),				   sin_theta = sin(theta);	const scalar_t asin_theta = a * sin_theta,				   acos_theta = a * cos_theta;	//		clog << "theta: " << rf_result << endl;			// compute vector	const typename VF::result_size_t vf_height = vf_.result_size(q_height);	AC_PRECONDITION(vf_height == two)		matrixn1 vf_result(vf_height, one, init_zero);	matrixn vf_deriv(vf_height, q_height, init_zero);			vf_.apply_derive(vf_result, vf_deriv, scalar1, q);	const scalar_t vx = vf_result(zero,zero), 				   vy = vf_result(one,zero);	//		clog << "p: " << vf_result << endl;			// transform vector	const float arx = (acos_theta * vx) - (asin_theta * vy),				ary = (asin_theta * vx) + (acos_theta * vy);					r(zero,zero) += arx;	r(one ,zero) += ary;	//		clog << "p': " << vf_result << endl;}template<class VF, class RF>template<class q_t, class result_t, class dfdq_t>void dynamic_rotation_vf<VF,RF>::apply_derive(result_t &r, dfdq_t &dfdq, const scalar_t &a, const q_t &q) const{	const typename q_t::height_t q_height = q.height();		// compute angle	matrixn1 rf_result(one, one, init_zero);	matrixn rf_deriv(one, q_height, init_zero);	rf_.apply_derive(rf_result, rf_deriv, scalar1, q);		const scalar_t theta = rf_result(zero,zero);	const scalar_t cos_theta = cos(theta),				   sin_theta = sin(theta);	const scalar_t asin_theta = a * sin_theta,				   acos_theta = a * cos_theta;//		clog << "theta: " << rf_result << endl;//		clog << "dtheta: " << rf_deriv << endl;		// compute vector	const typename VF::result_size_t vf_height = vf_.result_size(q_height);	AC_PRECONDITION(vf_height == two)		matrixn1 vf_result(vf_height, one, init_zero);	matrixn vf_deriv(vf_height, q_height, init_zero);			vf_.apply_derive(vf_result, vf_deriv, scalar1, q);	const scalar_t vx = vf_result(zero,zero), 				   vy = vf_result(one,zero);//		clog << "p: " << vf_result << endl;//		clog << "dp: " << vf_deriv << endl;				// transform vector	const float arx = (acos_theta * vx) - (asin_theta * vy),				ary = (asin_theta * vx) + (acos_theta * vy);					r(zero,zero) += arx;	r(one ,zero) += ary;	//		clog << "p': " << r << endl;		// compute derivative	const matrixn::row_t dvx(vf_deriv, zero, row_axis),						 dvy(vf_deriv, one , row_axis);	typename dfdq_t::row_t dpx(dfdq, zero, row_axis),				  dpy(dfdq, one, row_axis);				  //		clog << "dvx: " << dvx << endl;//		clog << "dvy: " << dvy << endl;	axpy(- ary, rf_deriv,		 scalar1, dpx);		axpy(+ acos_theta, dvx,		 - asin_theta, dvy,		 scalar1, dpx);		 	axpy(+ arx, rf_deriv,		 scalar1, dpy);	axpy(+ asin_theta, dvx,		 + acos_theta, dvy,		 scalar1, dpy);	//		clog << "dpx: " << dpx << endl;//		clog << "dpy: " << dpy << endl;//		clog << "dp': " << dfdq << endl;}template<class VF, class RF>template<class q_t, class dfdq_t> void dynamic_rotation_vf<VF,RF>::derive(dfdq_t &dfdq, const scalar_t &a, const q_t &q) const{	const typename q_t::height_t q_height = q.height();		// compute angle	matrixn1 rf_result(one,one);	matrixn rf_deriv(one,q_height);	rf_.apply_derive(rf_result, rf_deriv, scalar1, q);		// compute vector	const typename VF::result_size_t vf_height = vf_.result_size(q_height);		AC_PRECONDITION(vf_height == two)		matrixn1 vf_result(vf_height, one);	matrixn vf_deriv(vf_height, q_height);			vf_.apply_derive(vf_result, vf_deriv, scalar1, q);		// generate transform matrix	const scalar_t theta = rf_result(zero,zero);	const scalar_t cos_theta = cos(theta),				   sin_theta = sin(theta);	// transform vector	const float asin_theta = a * sin_theta,				acos_theta = a * cos_theta;	const float vx = vf_result(zero,zero), vy = vf_result(one,zero);	const float arx = (acos_theta * vx) - (asin_theta * vy),				ary = (asin_theta * vx) + (acos_theta * vy);					// compute derivative	const typename matrixn::row_t dvx(vf_deriv, zero, row_axis),						  dvy(vf_deriv, one, row_axis);	typename dfdq_t::row_t dpx(dfdq, zero, row_axis),				  dpy(dfdq, one, row_axis);	axpy(- ary, rf_deriv,		 scalar1, dpx);		axpy(+ acos_theta, dvx,		 - asin_theta, dvy,		 scalar1, dpx);		 	axpy(+ arx, rf_deriv,		 scalar1, dpy);	axpy(+ asin_theta, dvx,		 + acos_theta, dvy,		 scalar1, dpy);}} // namespace cf_geocore#endif /* __GEOMETRY_ATTR_VFS_TMPL_H */