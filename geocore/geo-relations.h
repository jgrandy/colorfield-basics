/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __GEO_RELATION_H#define __GEO_RELATION_H#include "geometry-core.h"#include "geo-system.h"#include "vector-relations.h"#include "geo-attr-vfs-tmpl.h"#include <vector>namespace cf_geocore {/*1.				2.				3.*/class angle_distance : public vector_relation {	// a relation between two angles -- note that just subtracting doesn't work,	// since the difference between 0 degrees and 2 degrees is the same as the	// difference between 359 degrees and 1 degree.public:				typedef angle_distance					this_t;				typedef vector_relation					base_t;				typedef vector_function					vf_t;				typedef base_t::q_t						q_t;				typedef vf_t::result_t					value_t;												angle_distance(const vf_t* xy1,											   const vf_t* xy2, 											   const q_t &q)									: base_t(NULL), xy1_(xy1), xy2_(xy2), original_angle_(one, one, init_zero)									{									  try {									  (angle2(dynamic_rotation(adapt_vf(xy2_), - angle2(adapt_vf(xy1_)))))									  	.apply(original_angle_, scalar1, q);									  } catch (std::exception &exc) {                                          std::clog << exc.what() << std::endl;									  }									  this->set_relation(this->make_relation());//									  clog << "original theta: " << original_angle_[zero] << endl;									}virtual							~angle_distance(void)						{ delete relation_; }				this_t&			operator= (const this_t &vp)				{																			  xy1_ = vp.xy1_; xy2_ = vp.xy2_; 																			  original_angle_ = vp.original_angle_;																			  if (relation_) delete relation_; 																			  this->set_relation(this->make_relation());																			  return *this;																			}																					  const vf_t*			get_vector_function1(void) const			{ return xy1_; }		  const vf_t*			get_vector_function2(void) const			{ return xy2_; }protected:		  const vector_function* make_relation(void) const						  							{		  							  return (vf_t::make_vf(angle2(dynamic_rotation(adapt_vf(xy2_), - angle2(adapt_vf(xy1_))))		  							  						- adapt_vf(original_angle_)));		  							}		  const vf_t*			xy1_;		  const vf_t*			xy2_;				value_t			original_angle_;};class point_position : public vector_position {public:		typedef point_position		this_t;		typedef vector_position		base_t;		static	  const system::tag_t		relation_tag = system::relation_point_position_type;static			relation_id_t		create(system *sys, locus_id_t ptid, space_id_t sid) throw(system::entity_not_found);static			relation_id_t		get(system *sys, locus_id_t ptid, space_id_t sid)	{ return sys->get_relation(ptid, this_t::relation_tag, sid); }									~point_position(void)					{ delete this->get_vector_function(); }				locus_id_t			get_point(void) const					{ return pt_; }protected:									point_position(const system *sys, locus_id_t pt, const space_id_t s)																			: base_t(sys->create_point_accessor(pt,s), 																					 sys->state()),																			  pt_(pt)																			{}				locus_id_t			pt_;};class segment_length : public vector_distance {public:		typedef segment_length		this_t;		typedef vector_distance		base_t;		typedef geometric_system	system_t;		static	  const system::tag_t		relation_tag = system::relation_segment_length_type;static			relation_id_t		create(system *sys, locus_id_t segid, space_id_t sid) throw(system::entity_not_found);static			relation_id_t		get(system *sys, locus_id_t segid, space_id_t sid)	{ return sys->get_relation(segid, this_t::relation_tag, sid); }									~segment_length(void)					{ delete this->get_vector_function1(); delete this->get_vector_function2(); }				locus_id_t			get_segment(void) const					{ return seg_; }protected:									segment_length(const system *sys, entity_id_t seg, space_id_t s)																			: base_t(sys->create_segment_start_accessor(seg, s),																					 sys->create_segment_end_accessor(seg, s),																					 sys->state()),																			  seg_(seg)																			{}				locus_id_t			seg_;};class point_distance : public vector_difference {public:		typedef point_distance		this_t;		typedef vector_difference	base_t;static	  const system::tag_t		relation_tag = system::relation_point_distance_type;				static			relation_id_t		create(system *sys, locus_id_t pt1, locus_id_t pt2, space_id_t sid) throw(system::entity_not_found);static			relation_id_t		get(system *sys, locus_id_t pt1, locus_id_t pt2, space_id_t sid)	{ return sys->get_relation(pt1,pt2, this_t::relation_tag, sid); }									~point_distance(void)					{ delete this->get_vector_function1(); delete this->get_vector_function2(); }				locus_id_t			get_point1(void) const					{ return pt1_; }				locus_id_t			get_point2(void) const					{ return pt2_; }protected:									point_distance(const system *sys, locus_id_t pt1, locus_id_t pt2, space_id_t s)																			: base_t(sys->create_point_accessor(pt1,s),																					 sys->create_point_accessor(pt2,s), 																					 sys->state()),																			  pt1_(pt1), pt2_(pt2)																			{}																		private:				locus_id_t			pt1_, pt2_;};class point_angle_distance : public angle_distance {public:		typedef point_angle_distance	this_t;		typedef angle_distance			base_t;		static	  const system::tag_t		relation_tag = system::relation_point_angle_distance_type;		static			relation_id_t		create(system *sys, locus_id_t pt1, locus_id_t pt2, space_id_t sid) throw(system::entity_not_found);static			relation_id_t		get(system *sys, locus_id_t pt1, locus_id_t pt2, space_id_t sid)	{ return sys->get_relation(pt1,pt2, this_t::relation_tag, sid); }									~point_angle_distance(void)				{ delete this->get_vector_function1(); delete this->get_vector_function2(); }				locus_id_t			get_point1(void) const					{ return pt1_; }				locus_id_t			get_point2(void) const					{ return pt2_; }protected:									point_angle_distance(const system *sys, locus_id_t pt1, locus_id_t pt2, space_id_t s)																			: base_t(sys->create_point_accessor(pt1,s),																					 sys->create_point_accessor(pt2,s), 																					 sys->state()),																			  pt1_(pt1), pt2_(pt2)																			{}private:				locus_id_t			pt1_, pt2_;};class parametric_distance : public vector_difference {public:		typedef parametric_distance		this_t;		typedef vector_difference		base_t;		typedef geometric_system	system_t;		static	  const system::tag_t		relation_tag = system::relation_parametric_distance_type;static			relation_id_t		create(system *sys, locus_id_t ptid, locus_id_t segid, const cvector &u, space_id_t sid) throw(system::entity_not_found);static			relation_id_t		create(system *sys, locus_id_t ptid, locus_id_t segid, const scalar_t &t, space_id_t sid) throw(system::entity_not_found);static			relation_id_t		get(system *sys, locus_id_t ptid, locus_id_t segid, space_id_t sid)	{ return sys->get_relation(ptid,segid, this_t::relation_tag, sid); }virtual								~parametric_distance(void)				{ delete this->get_vector_function1(); delete this->get_vector_function2(); }		  const cvector&			get_parameter(void) const				{ return t_; }				locus_id_t			get_point(void) const					{ return pt_; }				locus_id_t			get_segment(void) const					{ return seg_; }protected:									parametric_distance(const system *sys, locus_id_t pt, locus_id_t loc, const cvector &u, space_id_t s)																			: base_t(sys->create_point_accessor(pt, s),																					 sys->create_locus_parametric_accessor(loc,s,u),																					 sys->state()),																			  t_(u.height(),one), pt_(pt), seg_(loc)																			{ t_ = u; }				cvector				t_;				locus_id_t			pt_, seg_;};} // namespace vf_geocore#endif /* __GEO_RELATION_H */