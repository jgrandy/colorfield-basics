/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999-2000 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#include "geo-system.h"#include "geo-system-impl.h"#include <strstream>using std::clog;using std::endl;namespace cf_geocore {uint32_t system::next_id_ = 1;system::system(sim_t *sim): sim_(sim), observer_(NULL),  entities_(), transforms_(){}system::~system(void){	transform_map_t::iterator xit = transforms_.begin(),							xstop = transforms_.end();	while (xit != xstop) {		const vector_function *xform = xit->second;		// if xform is between space and its basis space, and space		// is not a subspace of its basis space, then client		// supplied it and we shouldn't delete it.		if ((is_subspace(xit->first.second)) || 			((xit->first.second != get_space_basis(xit->first.first)) &&			 (xit->first.first != get_space_basis(xit->first.second))))			delete xform;//		transforms_.erase(xit);		++xit;	}	entities_t::iterator eit = entities_.begin(),					   estop = entities_.end();	while (eit != estop) {		entity_record* er = eit->second;		delete er;//		spaces_.erase(sit);		++eit;	}}system::time_t system::step_to_quiescence(const time_t dt){	cvector dq(sim_->state().height(), one);	time_t t;		try {			do {			dq = sim_->state();			t = sim_->step(dt);			dq -= sim_->state();				} while (norm_p2(dq) > 1.0e-7);			} catch (std::logic_error &exc) {		clog << "step exception: " << exc.what() << endl;		dq = 0.0f;	} catch (std::exception &exc) {		dq = 0.0f;	}				if (observer_ != NULL) {		this->update_entity_seeds(dq);		observer_->handle_new_state(t);	}				return t;}system::time_t system::step(const time_t dt){	cvector dq(sim_->state().height(), one);	time_t t;		try {				dq = sim_->state();		t = sim_->step(dt);		dq -= sim_->state();			} catch (std::logic_error &exc) {		clog << "step exception: " << exc.what() << endl;		dq = 0.0f;	} catch (std::exception &exc) {		dq = 0.0f;	}				if ((observer_ != NULL) && (norm_p2(dq) > 1.0e-9)) {		this->update_entity_seeds(dq);		observer_->handle_new_state(t);	}				return t;}void system::lock(void){}void system::unlock(void){}bool system::is_locked(void) const throw(){	return false;}system::entity_type system::get_entity_type(entity_id_t eid) const throw(system::entity_not_found){	const entity_record *er = get_record<entity_record>(eid,entities_);	return er->get_entity_type();}void system::set_entity_name(entity_id_t eid, const std::string &n) throw (entity_not_found){	entity_record *er = get_record<entity_record>(eid,entities_);	er->set_name(n);	er->set_seed(sim_);}const std::string& system::get_entity_name(entity_id_t eid) throw (entity_not_found){	const entity_record *er = get_record<entity_record>(eid,entities_);	return er->get_name();}entity_id_t system::get_entity_by_name(const std::string &n) const throw(){	entity_id_t eid = NULL;		entities_t::const_iterator eit = entities_.begin(),					   estop = entities_.end();	while (eit != estop) {		const entity_record* er = eit->second;		if (er->get_name() == n) {			eid = er->id();			break;		}		++eit;	}	return eid;}bool system::entity_has_changed(entity_id_t eid, time_t t) const throw(system::entity_not_found){	const entity_record *er = get_record<entity_record>(eid,entities_);	return (er->get_seed() > t);}void system::set_entity_has_changed(entity_id_t eid) throw(system::entity_not_found){	entity_record *er = get_record<entity_record>(eid,entities_);	er->set_seed(sim());}void system::update_entity_seeds(const cvector &dq){	entities_t::iterator eit = entities_.begin(),					   estop = entities_.end();	while (eit != estop) {		entity_record* er = eit->second;		++eit;		if (er->has_changed(this, dq))			er->set_seed(sim());	}}space_id_t system::add_space(index_t dims, tag_t space_type){	space_id_t sid = this->new_id();		space_record *sr = new space_record(sid,dims,space_type);	sr->set_default_name();		entities_[sid] = sr;		if (observer_)		observer_->handle_entity_added(sid);	return sid;}space_id_t system::add_space(index_t dims,									 space_id_t basis,									 const vector_function *from_basis,									 const vector_function *to_basis,									 tag_t space_type){	space_id_t sid = this->new_id();		space_record *sr = new space_record(sid, dims, space_type);		if (basis != 0) {		sr->set_basis(basis);				if (from_basis != NULL) {			transforms_[std::make_pair(basis,sid)] = from_basis;//			clog << "added xform " << basis << " -> " << sid << endl;		}		if (to_basis != NULL) {			transforms_[std::make_pair(sid,basis)] = to_basis;//			clog << "added xform " << sid << " -> " << basis << endl;		}	}			sr->set_default_name();	entities_[sid] = sr;		if (observer_)		observer_->handle_entity_added(sid);	return sid;}void system::remove_space(space_id_t s){	entities_t::iterator p = entities_.find(s);		if (p == entities_.end() || p->second->get_entity_type() != entity_space_type)		throw entity_not_found(s);		entity_record *sr = p->second;		entities_.erase(p);		delete sr;	if (observer_)		observer_->handle_entity_removed(s);}space_id_t system::get_space(entity_subtype subtype) const throw(system::entity_not_found){	space_id_t sid = NULL;		entities_t::const_iterator eit = entities_.begin(),							 estop = entities_.end();	while (eit != estop) {		const entity_record* er = eit->second;		++eit;		if ((er->get_entity_type() == entity_space_type) && (er->get_entity_subtype() == subtype)) {			sid = er->id();			break;		}	}	return sid;}index_t system::get_space_dimensions(space_id_t sid) const throw(system::entity_not_found){	const space_record *sr = get_record<space_record>(sid,entities_);	if (sr == NULL) 		throw entity_not_found(sid);	return sr->dimensions();}system::tag_t system::get_space_type(space_id_t sid) const throw(system::entity_not_found){	const space_record *sr = get_record<space_record>(sid,entities_);	if (sr == NULL) 		throw entity_not_found(sid);	return sr->space_type();}space_id_t system::get_space_basis(space_id_t sid) const throw(system::entity_not_found){	const space_record *sr = get_record<space_record>(sid,entities_);	if (sr == NULL) 		throw entity_not_found(sid);	return sr->basis();}const vector_function* system::get_space_transform_or_nil(space_id_t src, space_id_t dest) const{	transform_map_t::const_iterator tit = transforms_.find(std::make_pair(src,dest));	if (tit != transforms_.end())		return tit->second;	else		return NULL;		}const vector_function* system::get_space_transform(space_id_t src, space_id_t dest) const throw(system::entity_not_found){	const vector_function *xform = this->get_space_transform_or_nil(src,dest);	if (xform == NULL)		return this->create_transform_entry(src,dest);	else		return xform;}const vector_function *system::make_forward_transform(space_id_t src, std::list<space_id_t> &chain) const{	// chain is [src ... dest]		// pull next space off	space_id_t dest = chain.front();	chain.pop_front();		const vector_function *xform = get_space_transform_or_nil(src,dest);		if (! chain.empty()) {		space_id_t last = chain.back();		const vector_function *x2 = make_forward_transform(dest,chain);		xform = vector_function::make_vf((*x2)(xform));		transforms_[std::make_pair(src,last)] = xform;//		clog << "added between " << src << " and " << last << endl;	}		return xform;}const vector_function *system::make_backward_transform(space_id_t src, std::list<space_id_t> &chain) const{	// chain is [dest ... src]		// pull next off	AC_PRECONDITION(! chain.empty())	space_id_t dest = chain.back();	chain.pop_back();		const vector_function *xform = get_space_transform_or_nil(src,dest);		if (! chain.empty()) {		space_id_t last = chain.front();		const vector_function *x2 = make_backward_transform(dest,chain);		xform = vector_function::make_vf((*x2)(xform));		transforms_[std::make_pair(src,last)] = xform;//		clog << "added between " << src << " and " << last << endl;	}		return xform;}const vector_function* system::create_transform_entry(space_id_t src, space_id_t dest) const throw(system::entity_not_found){//	clog << "xform " << src << " -> " << dest << " size before op " << transforms_.size() << endl;	const vector_function *xform = NULL;		// create list of basis spaces starting from each space	std::list<space_id_t> src_chain, dest_chain;	space_id_t common = NULL;		for (space_id_t s = dest; s != NULL; s = get_space_basis(s)) {		dest_chain.push_front(s);		if (s == src) {			common = s;			break;		}	}	if (common != NULL) {		// dest_chain is [src ... dest]		dest_chain.pop_front();		xform = make_forward_transform(src,dest_chain);			} else {		for (space_id_t s = src; s != NULL; s = get_space_basis(s)) {			src_chain.push_front(s);			if (s == dest) {				common = s;				break;			}		}		if (common != NULL) {			// src_chain is [dest ... src]			src_chain.pop_back();			xform = make_backward_transform(src,src_chain);					} else {			// find branch point between two lists (if they don't start with same basis, then just return NULL)			space_id_t src_parent = src_chain.front(), dest_parent = dest_chain.front();			if (src_parent == dest_parent) {				space_id_t common;				while (src_parent == dest_parent) {	// always true the first time					common = src_parent;					src_chain.pop_front();					src_parent = src_chain.front();					dest_chain.pop_front();					dest_parent = dest_chain.front();				}									// src_chain is [common ... src]				// dest_chain is [common ... dest]				const vector_function *x1 = get_space_transform_or_nil(src,common),									  *x2 = get_space_transform_or_nil(common,dest);				if (x1 == NULL) {					src_chain.pop_back();					x1 = make_backward_transform(src,src_chain);				}												if (x2 == NULL) {					dest_chain.pop_front();					x2 = make_forward_transform(common,dest_chain);				}								xform = vector_function::make_vf((*x2)(x1));				transforms_[std::make_pair(src,dest)] = xform;//				clog << "spliced " << src << " -> " << common << " -> " << dest << endl;			}		}	}//	clog << "transforms size now " << transforms_.size() << endl;		return xform;}bool system::is_subspace(space_id_t sid) const throw(system::entity_not_found){	const space_record *sr = get_record<space_record>(sid,entities_);	if (sr == NULL) 		throw entity_not_found(sid);	return sr->is_subspace();}system::space_record::subspace_record* system::space_record::get_subspace_record(subspace_record *sr, index_t x){	if (sr->extensions_[x] == NULL)		sr->extensions_[x] = new subspace_record;		return sr->extensions_[x];}void system::get_subspace_indices(space_id_t sid, std::vector<index_t> &indices) const throw (system::entity_not_found){	const space_record *sr = get_record<space_record>(sid,entities_);	if (sr == NULL) 		throw entity_not_found(sid);	indices = sr->get_indices();}space_id_t system::get_subspace(space_id_t sid, const std::vector<index_t> &indices) throw(system::entity_not_found){	space_record *sr = get_record<space_record>(sid,entities_);	if (sr == NULL) 		throw entity_not_found(sid);	const int n = indices.size();	space_record::subspace_record *srx = sr->get_subspace_tree();	for (int i=0; i<n; i++)		srx = sr->get_subspace_record(srx,indices[i]);	if (srx->subspace_ == NULL) {		const vector_function *from = NULL;		switch (n) {			case 1:				from = vector_function::make_vf(adapt_vf(pickn_vf<one_t>(indices[0])));				break;			case 2:				from = vector_function::make_vf(adapt_vf(pickn_vf<two_t>(indices[0], indices[1])));				break;			case 3:				from = vector_function::make_vf(adapt_vf(pickn_vf<three_t>(indices[0], indices[1], indices[2])));				break;			case 4:				from = vector_function::make_vf(adapt_vf(pickn_vf<four_t>(indices[0], indices[1], indices[2], indices[3])));				break;			default:				FAILFALSE(false)		}		srx->subspace_ = this->add_space(n, sid, from, NULL, subspace_type);		space_record *sr2 = get_record<space_record>(srx->subspace_, entities_);		sr2->set_is_subspace(true);		sr2->set_indices(indices);		sr2->set_seed(sim_);	}	return srx->subspace_;	}space_id_t system::get_subspace(space_id_t sid, index_t x) throw(system::entity_not_found){	std::vector<index_t> indices(1);	indices[0] = x;	return this->get_subspace(sid,indices);}space_id_t system::get_subspace(space_id_t sid, index_t x, index_t y) throw(system::entity_not_found){	std::vector<index_t> indices(2);	indices[0] = x;	indices[1] = y;	return this->get_subspace(sid,indices);}void system::set_observer(observer *obs){ 	observer_ = obs;}system::observer* system::get_observer(void) const{	return observer_;}dictionary& system::get_entity_tags(locus_id_t eid) throw(system::entity_not_found){	std::map<entity_id_t,system::entity_record*>::iterator p = entities_.find(eid);	if (p == entities_.end())		throw entity_not_found(eid);		return p->second->get_tags();}const dictionary& system::get_entity_tags(locus_id_t eid) const throw(system::entity_not_found){	std::map<entity_id_t,system::entity_record*>::const_iterator p = entities_.find(eid);	if (p == entities_.end())		throw entity_not_found(eid);	return p->second->get_tags();}void system::entity_record::set_default_name(void){    entity_type etype = type_ ? type_ : 'gnrc';    void* eid = id_;	char ename[5];	((uint32_t*)ename)[0] = etype;	ename[4] = 0;	std::ostrstream nstr;	nstr << ((char*) ename) << '-' << eid << '\0';	this->set_name(nstr.str());}bool system::locus_record::has_changed(const system */*sys*/, const cvector &dq) const{	const index_t rs = accessor_->result_size(dq.height());	cvector r(rs,one,init_zero);	accessor_->apply(r,scalar1,dq);	return (norm_maxabs(r) > 1.0e-9);}bool system::relation_record::has_changed(const system *sys, const cvector &dq) const{	bool c = false;	const int n = participants_.size();	for (int i=0; i<n; i++) {		entity_id_t eid = participants_[i];		const entity_record *er = get_record<entity_record>(eid,sys->entities_);		if (er->has_changed(sys,dq)) {			c = true;			break;		}	}		return c;}    template<>system::entity_record* system::get_record<system::entity_record>(entity_id_t eid, std::map<entity_id_t,system::entity_record*> &entities){    std::map<entity_id_t,system::entity_record*>::iterator p = entities.find(eid);    if (p == entities.end())        return NULL;    else        return p->second;}template<>const system::entity_record* system::get_record<system::entity_record>(entity_id_t eid, const std::map<entity_id_t,system::entity_record*> &entities){    std::map<entity_id_t,system::entity_record*>::const_iterator p = entities.find(eid);    if (p == entities.end())        return NULL;    else        return p->second;}			} // namespace cf_geocore