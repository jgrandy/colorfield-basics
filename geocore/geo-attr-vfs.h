/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __GEOMETRY_ATTR_VFS_H#define __GEOMETRY_ATTR_VFS_H#include "geometry-core.h"#include "index.h"#include "vector-function.h"namespace cf_geocore {    template<class q_t, class result_t> void angle2_apply(result_t &r, const scalar_t &a, const q_t &q);template<class q_t, class dfdq_t> void angle2_derive(dfdq_t &dfdq, const scalar_t &a, const q_t &q);template<class q_t, class result_t, class dfdq_t> void angle2_apply_derive(result_t &r, dfdq_t &dfdq, const scalar_t &a, const q_t &q);class radius_vf {	// we have to give member function bodies inline, because even though CW Pro 5 allows	// out-of-line declaration of template member functions, it only allows it for members	// of *template* classes!public:			typedef radius_vf				this_t;						typedef one_t					result_size_t;		// one_t because radius is a scalar attribute			template<class q_t, class result_t>			void				apply(result_t &r, const scalar_t &a, const q_t &q) const	{ radius_apply(r,a,q); }template<class q_t, class dfdq_t> 			void				derive(dfdq_t &dfdq, const scalar_t &a, const q_t &q) const																								{ radius_derive(dfdq,a,q); }template<class q_t, class result_t, class dfdq_t>			void				apply_derive(result_t &r, dfdq_t &dfdq, const scalar_t &a, const q_t &q) const																								{ radius_apply_derive(r,dfdq,a,q); }			result_size_t		result_size(const two_t &) const								{ return one; }			result_size_t		result_size(const index_t &) const								{ return one; }			friend		std::ostream&		operator<<(std::ostream &os, const this_t &)					{ return (os << "radius"); }};template<class VF>vf_wrapper<composite_vf<radius_vf, VF> > radius(const vf_wrapper<VF> &f){	return adapt_vf(composite_vf<radius_vf,VF>(radius_vf(), (const VF&) f));}class angle2_vf {public:				typedef angle2_vf			this_t;							typedef one_t				result_size_t;		// one_t because angle is a scalar attribute	template<class q_t, class result_t>					void				apply(result_t &r, const scalar_t &a, const q_t &q) const																									{ angle2_apply(r,a,q); }	template<class q_t, class dfdq_t> 					void				derive(dfdq_t &dfdq, const scalar_t &a, const q_t &q) const																									{ angle2_derive(dfdq,a,q); }	template<class q_t, class result_t, class dfdq_t>					void				apply_derive(result_t &r, dfdq_t &dfdq, const scalar_t &a, const q_t &q) const																									{ angle2_apply_derive(r,dfdq,a,q); }				result_size_t		result_size(const two_t  &) const								{ return one; }				result_size_t		result_size(const index_t &) const								{ return one; }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &)					{ return (os << "angle2"); }};template<class VF>vf_wrapper<composite_vf<angle2_vf, VF> > angle2(const vf_wrapper<VF> &f){	return adapt_vf(composite_vf<angle2_vf,VF>(angle2_vf(), (const VF&) f));}template<class VF, class RF>class dynamic_rotation_vf {	// rotate the vector determined by VF(q) by the angle given by RF(q).public:				typedef dynamic_rotation_vf<VF,RF>	this_t;							typedef index_t					result_size_t;		// actually we only support 2D vectors,																	// but that's enforced at runtime													dynamic_rotation_vf(const VF &vf, const RF &rf)				: vf_(vf), rf_(rf) {}										dynamic_rotation_vf(const this_t &vf)						: vf_(vf.vf_), rf_(vf.rf_) {}															this_t&				operator= (const this_t &vf)								{ vf_ = vf.vf_; rf_ = vf.rf_; return *this; }					template<class q_t, class result_t>					void				apply(result_t &r, const scalar_t &a, const q_t &q) const;template<class q_t, class result_t, class dfdq_t>					void				apply_derive(result_t &r, dfdq_t &dfdq, const scalar_t &a, const q_t &q) const;template<class q_t, class dfdq_t> 					void				derive(dfdq_t &dfdq, const scalar_t &a, const q_t &q) const;template<class q_size_t>					result_size_t		result_size(const q_size_t &q_size) const					{ AC_PRECONDITION(vf_.result_size(q_size) == two) return two; }			friend				std::ostream&		operator<<(std::ostream &os, const this_t &f)				{ return (os << "(rotate " << f.vf_ << " by " << f.rf_ << ')'); }private:				VF				vf_;				RF				rf_;};template<class VF, class RF>vf_wrapper<dynamic_rotation_vf<VF,RF> > dynamic_rotation(const vf_wrapper<VF> &vf, const vf_wrapper<RF> &rf){	return adapt_vf(dynamic_rotation_vf<VF,RF>(vf,rf));}} // cf_geocore#endif /* __GEOMETRY_ATTR_VFS_H */