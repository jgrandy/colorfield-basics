/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1995 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#include "geometry-core.h"#include "geo-system.h"#include "first-order-simulation.h"#include "geo-space.h"#include "geo-locus.h"#include "geo-transform.h"#include "geo-transform-tmpl.h"#include "runge-kutta.tmpl.h"#include "matrix-ops-multiply-tmpl.h"namespace cf_algebra {    template cvector& axpy(const scalar_t &a, const cvector &x, const scalar_t &b, cvector &y);}using namespace cf_geocore;using std::clog;using std::endl;using std::exception;typedef cf_geocore::system system_t;typedef static_vector_space<rectangular3_vector_space_traits<> > rect_space_t;typedef static_vector_space<cylindrical_vector_space_traits<> > cyl_space_t;typedef rectangular_to_cylindrical<rect_space_t::reordering_t,cyl_space_t::reordering_t> r2c_t;typedef cylindrical_to_rectangular<cyl_space_t::reordering_t,rect_space_t::reordering_t> c2r_t;int test_geometry_core(void){	try {                clog << "Testing Geometry Core" << endl;                generic_vf<r2c_t> r2c = r2c_t();        generic_vf<c2r_t> c2r = c2r_t();		        cf_simcore::first_order_simulation sim;		system_t sys(&sim);				rect_space_t s1(vector_space::offset_coord);		s1.initialize(&sys);		cvector p1(three,one);		p1[0] = 1.0;		p1[1] = 2.0;		p1[2] = 3.0;		locus_id_t id1 = sys.add_point(p1, s1.get_id(), true);				cvector p2(three,one);		sys.get_point(id1,0,p2);	        clog << "p2: " << p2 << endl;		FAILFALSE(p1 == p2)		sys.get_point(id1,s1.get_id(),p2);        clog << "p2: " << p2 << endl;		FAILFALSE(p2 == p1)		cyl_space_t s2(vector_space::angle_coord);		s2.initialize(&s1);				cvector p3(three,one,init_zero);		p3 = scalar0;		r2c.apply(p3,scalar1,p1);        clog << "p3: " << p3 << endl;				sys.get_point(id1,s2.get_id(),p2);        clog << "p2: " << p2 << endl;		FAILFALSE(p3 == p2)				locus_id_t id2 = sys.add_point(p2, s2.get_id(), true);				p3 = scalar0;		c2r.apply(p3,scalar1,p2);				sys.get_point(id2,s2.get_id(),p3);		FAILFALSE(p3 == p2)				sys.get_point(id2,s1.get_id(),p3);		p3 -= p1;		FAILNEQ(norm_maxabs(p3),scalar0)		rect_space_t s3(vector_space::offset_coord);		s3.initialize(&s2);				p3 = scalar0;		sys.get_point(id1,s3.get_id(),p3);		p3 -= p1;		FAILNEQ(norm_maxabs(p3),scalar0);		cyl_space_t s4(vector_space::angle_coord);		s4.initialize(&s1);				sys.get_point(id1,s4.get_id(),p2);		locus_id_t id3 = sys.add_point(p2, s4.get_id(), true);		//          - s2(id2) - s3		//        /		// s1(id1)		//        \		//          - s4(id3)				p3 = scalar0;		sys.get_point(id3,s3.get_id(),p3);		p3 -= p1;		FAILNEQ(norm_maxabs(p3),scalar0);				space_id_t s310 = sys.get_subspace(s3.get_id(),1,0);				cvector p4(two,one);		sys.get_point(id1,s310,p4);		FAILNEQ(p4[0],p1[1])		FAILNEQ(p4[1],p1[0])						clog << "done." << endl;			} catch (exception &exc) {		clog << exc.what() << endl;	}		return 0;}