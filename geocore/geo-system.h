/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999-2000 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __GEO_SYSTEM_H#define __GEO_SYSTEM_H#include "geometry-core.h"#include "vector-function.h"#include "vector-relations.h"#include "objective-function.h"#include "constrained-simulation.h"//#include "cf-message-handler.h"#include "cf-dictionary.h"#include <iosfwd>#include <utility>#include <list>#include <map>/*1.				2.					3.*/namespace cf_geocore {class system {public:		typedef scalar_t			time_t;		typedef cf_simcore::constrained_simulation sim_t;		typedef sim_t::q_t			state_t;		typedef uint32_t			entity_type;		typedef uint32_t			entity_subtype;				typedef entity_subtype		locus_type;		typedef entity_subtype		space_type;		typedef entity_subtype		relation_type;				enum {	// entity types					entity_null_type      = 0,					entity_space_type	  = 'spac',					entity_locus_type	  = 'locs',					entity_relation_type  = 'reln',					entity_objective_type = 'objv',					entity_boundary_type  = 'bndy'				};						enum {					entity_null_subtype = 0				};														enum {		// entity subtype for locus entities					locus_point_type   = 'pont',					locus_segment_type = 'segm',					locus_curve_type   = 'curv',					locus_sheet_type   = 'shet',					locus_plane_type   = 'plan'				};								enum {		// entity subtype for relation entities					relation_point_position_type       = 'ppos',					relation_segment_length_type       = 'segl',					relation_point_distance_type       = 'pdis',					relation_point_angle_distance_type = 'adis',					relation_parametric_distance_type  = 'para'									};				static	  const index_t				point_parametric_args = 0;static	  const index_t				segment_parametric_args = 1;static	  const index_t				curve_parametric_args = 1;static	  const index_t				plane_parametric_args = 2;		typedef uint32_t			tag_t;		   		class entity_not_found : public std::runtime_error {		public:									entity_not_found(entity_id_t id)				: std::runtime_error("entity id not found"), id_(id) {}		private:				entity_id_t			id_;		};									system(sim_t *sim);									~system(void);						// System Control				time_t				step(const time_t dt);				time_t				step_to_quiescence(const time_t dt);		  const state_t&			state(void) const throw()						{ return sim_->state(); }				time_t				time(void) const throw()						{ return sim_->time(); }				void				lock(void);				void				unlock(void);				bool				is_locked(void) const throw();										// Entities (generic system entries)								entity_type			get_entity_type(entity_id_t eid) const throw(entity_not_found);				bool				entity_is_space(entity_id_t eid) const throw(entity_not_found)			{ return get_entity_type(eid) == entity_space_type; }				bool				entity_is_locus(entity_id_t eid) const throw(entity_not_found)			{ return get_entity_type(eid) == entity_locus_type; }				bool				entity_is_relation(entity_id_t eid) const throw(entity_not_found)		{ return get_entity_type(eid) == entity_relation_type; }				bool				entity_is_objective(entity_id_t eid) const throw(entity_not_found)		{ return get_entity_type(eid) == entity_objective_type; }				bool				entity_is_boundary(entity_id_t eid) const throw(entity_not_found)		{ return get_entity_type(eid) == entity_boundary_type; }								entity_subtype		get_entity_subtype(entity_id_t eid) const throw(entity_not_found);								void				set_entity_name(entity_id_t eid, const std::string &name) throw (entity_not_found);		  const std::string&		get_entity_name(entity_id_t eid) throw (entity_not_found);				entity_id_t			get_entity_by_name(const std::string &name) const throw();	// returns 0 if not found				template<typename T> void			entity_set_tag(entity_id_t eid, tag_t tag, const T &val, bool signal = true) throw(entity_not_found)														{ dictionary &tags = this->get_entity_tags(eid);														  tags.set<T>(tag,val);														  if (signal && (observer_ != NULL)) {														  	observer_->handle_tag_changed(eid,tag);														  }														  this->set_entity_has_changed(eid);														}template<typename T> T				entity_get_tag(entity_id_t eid, tag_t tag) const throw(entity_not_found)														{ const dictionary &tags = this->get_entity_tags(eid);														  return tags.get<T>(tag);														}				void				entity_remove_tag(entity_id_t eid, tag_t tag, bool signal = true) throw(entity_not_found)														{ dictionary &tags = this->get_entity_tags(eid);														  tags.remove(tag);														  if (signal && (observer_ != NULL)) {														  	observer_->handle_tag_removed(eid,tag);														  }														  this->set_entity_has_changed(eid);														}				bool				entity_has_tag(entity_id_t eid, tag_t tag) const throw(entity_not_found)														{ const dictionary &tags = this->get_entity_tags(eid);														  return tags.has(tag);														}								bool				entity_has_changed(entity_id_t eid, time_t t) const throw(entity_not_found);protected:				void				set_entity_has_changed(entity_id_t eid) throw(entity_not_found);				void				update_entity_seeds(const cvector &dq);public:										// Vector Spaces				enum {					generic_space_type = 'gens',					subspace_type = 'subs'				};								space_id_t			add_space(index_t dims, entity_subtype space_tag = generic_space_type);		// add new root space				space_id_t			add_space(index_t dims,											  space_id_t basis,		// add a derived space											  const vector_function *from_basis,											  const vector_function *to_basis,											  entity_subtype space_t = generic_space_type);				void				remove_space(space_id_t s);		// *** necessary?				space_id_t			get_space(entity_subtype tag) const throw(entity_not_found);				space_id_t			get_space_basis(space_id_t s) const throw(entity_not_found);				tag_t				get_space_type(space_id_t s) const throw(entity_not_found);				index_t				get_space_dimensions(space_id_t s) const throw(entity_not_found);		  const vector_function*	get_space_transform(space_id_t src, space_id_t dest) const throw(entity_not_found);				bool				is_subspace(space_id_t s) const throw(entity_not_found);				void				get_subspace_indices(space_id_t s, std::vector<index_t> &indices) const throw (entity_not_found);				space_id_t			get_subspace(space_id_t basis, const std::vector<index_t> &indices) throw (entity_not_found);				space_id_t			get_subspace(space_id_t base_id, index_t x) throw(entity_not_found);				space_id_t			get_subspace(space_id_t base_id, index_t x, index_t y) throw(entity_not_found);											// Statevirtual			locus_id_t 			add_locus(const cvector &q, locus_type t, space_id_t sid, bool dynamic);template<class E, class S>				locus_id_t			add_point(const matrix<E,S> &p, space_id_t sid, bool dynamic)									  {										cvector q(p.height(),one);										q = p;										const locus_id_t lid = this->add_locus(q, locus_point_type, sid, dynamic);										return lid;									  }template<class E, class S>				locus_id_t			add_segment(const matrix<E,S> &p1, const matrix<E,S> &p2, space_id_t sid, bool dynamic)									  {										const index_t n = p1.height();										cvector q(n+n,one);										q.rows(range(0,n)) = p1;										q.rows(range(n,n)) = p2;										const locus_id_t lid = this->add_locus(q, locus_segment_type, sid, dynamic);										return lid;									  }				bool				has_locus(locus_id_t eid) const;				void				remove_locus(locus_id_t eid) throw(entity_not_found);				entity_subtype		get_locus_type(locus_id_t eid) const throw(entity_not_found);	// use get_entity_subtype instead				space_id_t			get_locus_space(locus_id_t eid) const throw(entity_not_found);				bool				locus_is_dynamic(locus_id_t eid) const throw(entity_not_found);								void				get_point(locus_id_t eid, space_id_t space, cvector &p) const throw(entity_not_found);				void				get_segment_start(locus_id_t eid, space_id_t space, cvector &p) const throw(entity_not_found);				void				get_segment_end(locus_id_t eid, space_id_t space, cvector &p) const throw(entity_not_found);				void				get_segment_position(locus_id_t eid, scalar_t u, space_id_t dest, cvector &pos) const throw(entity_not_found);						  const vector_function*	create_point_accessor(locus_id_t eid, space_id_t space) const throw(entity_not_found);			  const vector_function*	create_segment_start_accessor(locus_id_t eid, space_id_t space) const throw(entity_not_found);			  const vector_function*	create_segment_end_accessor(locus_id_t eid, space_id_t space) const throw(entity_not_found);			  const vector_function*	create_locus_parametric_accessor(locus_id_t eid, space_id_t space, const cvector &u) const throw(entity_not_found);			  								// caller deallocates				bool				is_point(entity_id_t eid) const throw(entity_not_found);				bool				is_segment(entity_id_t eid) const throw(entity_not_found);										// Relations				virtual			relation_id_t		add_relation(tag_t reln_tag, space_id_t space, const std::vector<locus_id_t> &participants);				relation_id_t		add_relation(const vector_relation *vr, tag_t rtag, space_id_t space, const std::vector<locus_id_t> &participants);				void				remove_relation(relation_id_t rid) throw(entity_not_found);virtual			bool				can_add_relation(tag_t reln_tag, space_id_t space, const std::vector<locus_id_t> &participants) const;				bool				has_relation(tag_t reln_tag, const std::vector<locus_id_t> &participants) const;				bool				has_relation(relation_id_t rid) const;		  const vector_relation*	get_relation(relation_id_t rid) const throw(entity_not_found);				relation_id_t		get_relation(locus_id_t eid, tag_t rtag, space_id_t sid) const throw(entity_not_found);				relation_id_t		get_relation(locus_id_t eid1, locus_id_t eid2, tag_t rtag, space_id_t sid) const throw(entity_not_found);		  		entity_subtype		get_relation_type(relation_id_t rid) const throw(entity_not_found);	// use get_entity_subtype instead		  		space_id_t			get_relation_space(relation_id_t rid) const throw(entity_not_found);				index_t				get_relation_num_participants(relation_id_t rid) const throw(entity_not_found);				locus_id_t			get_relation_nth_participant(relation_id_t rid, index_t n) const throw(entity_not_found);				void				activate_relation(relation_id_t rid) throw(entity_not_found);				void				deactivate_relation(relation_id_t rid) throw(entity_not_found);				bool				relation_is_active(relation_id_t rid) const throw(entity_not_found);						// Objectivesvirtual			objective_id_t		add_objective(tag_t obj_tag, space_id_t space, const std::vector<locus_id_t> &participants);				objective_id_t		add_objective(cf_simcore::objective_function<> *of);				bool				has_objective(objective_id_t oid) const;				void				remove_objective(objective_id_t oid) throw(entity_not_found);cf_simcore::objective_function<>*	get_objective(objective_id_t oid) const throw(entity_not_found);							// Boundaries tbd																		// Observers										class observer {								public:									typedef std::pair<entity_id_t,dictionary::tag_t>	event_tag_changed_data_t;				virtual		void	handle_new_state(time_t new_time) = 0;				virtual		void	handle_entity_added(entity_id_t new_entity) = 0;				virtual		void	handle_entity_removed(entity_id_t ex_entity) = 0;				virtual		void	handle_entity_changed(entity_id_t changed_entity) = 0;				virtual		void	handle_tag_changed(entity_id_t changed_entity, dictionary::tag_t changed_tag) = 0;				virtual		void	handle_tag_removed(entity_id_t changed_entity, dictionary::tag_t changed_tag) = 0;								};				void				set_observer(observer *obs);				observer*			get_observer(void) const;				private:		  class entity_record;		  class space_record;		  class locus_record;		  class relation_record;		  class objective_record;		  class boundary_record;		  friend class relation_record;		typedef std::map<entity_id_t,entity_record*> entities_t;		typedef std::map<std::pair<space_id_t,space_id_t>,const vector_function*> transform_map_t;static			entity_id_t			new_id(void)			{ return reinterpret_cast<entity_id_t>(++next_id_); }template<class T> static T* get_record(entity_id_t eid, std::map<entity_id_t,system::entity_record*> &entities);template<class T> static const T* get_record(entity_id_t eid, const std::map<entity_id_t,system::entity_record*> &entities);								sim_t*				sim(void)				{ return sim_; }		  const sim_t*				sim(void) const			{ return sim_; }				dictionary&			get_entity_tags(entity_id_t eid) throw(entity_not_found);		  const dictionary&			get_entity_tags(entity_id_t eid) const throw(entity_not_found);		inline	  const vector_function*	get_space_transform_or_nil(space_id_t, space_id_t) const;		  const vector_function*	make_forward_transform(space_id_t src, std::list<space_id_t> &chain) const;		  const vector_function*	make_backward_transform(space_id_t src, std::list<space_id_t> &chain) const;		  const vector_function*	create_transform_entry(space_id_t, space_id_t) const throw(entity_not_found);//		  		void				signal_clients(cf_messaging::message *msg, bool replace = false) const;static			uint32_t			next_id_;				sim_t*				sim_;				observer*			observer_;				entities_t			entities_;		// each entity is stored here and in one of the maps below.mutable			transform_map_t		transforms_;};} // namespace cf_geocore#endif /* __GEO_SYSTEM_H */