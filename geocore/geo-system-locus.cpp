/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999-2000 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#include "geo-system.h"#include "geo-system-impl.h"#include "geo-locus.h"#include "matrix-ops-multiply-tmpl.h"namespace cf_algebra {    template cvector& axpy(const scalar_t &a, const cvector &x, const scalar_t &b, cvector &y);}namespace cf_geocore {locus_id_t system::add_locus(const cvector &q, locus_type t, space_id_t sid, bool dynamic){	locus_id_t eid = this->new_id();		locus_record *lr = new locus_record(t, eid);	lr->set_space(sid);	lr->set_dynamic(dynamic);	lr->set_default_name();	if (dynamic) {		const vector_function *vf = sim()->add_state(q);		lr->set_accessor(vf);	} else {		const vector_function *vf = vector_function::make_vf(adapt_vf(q));		lr->set_accessor(vf);	}		entities_[eid] = lr;		if (observer_)		observer_->handle_entity_added(eid);		return eid;}bool system::has_locus(locus_id_t eid) const{	const locus_record *lr = get_record<locus_record>(eid,entities_);	return (lr != nil);}void system::remove_locus(locus_id_t eid) throw(system::entity_not_found){	entities_t::iterator p = entities_.find(eid);		if (p == entities_.end() || (p->second->get_entity_type() != entity_locus_type))		throw entity_not_found(eid);		locus_record *lr = (locus_record*) p->second;		entities_.erase(p);		if (lr->is_dynamic())		sim()->remove_state(lr->accessor());	else		delete lr->accessor();	delete lr;	if (observer_)		observer_->handle_entity_removed(eid);}system::locus_type system::get_locus_type(locus_id_t eid) const throw(system::entity_not_found){	const locus_record *lr = get_record<locus_record>(eid,entities_);	if (lr == nil) 		throw entity_not_found(eid);	return lr->get_locus_type();}bool system::is_point(locus_id_t eid) const throw(system::entity_not_found){	if (this->entity_is_locus(eid))		return (this->get_locus_type(eid) == locus_point_type);	else		return false;}bool system::is_segment(locus_id_t eid) const throw(system::entity_not_found){	if (this->entity_is_locus(eid))		return (this->get_locus_type(eid) == locus_segment_type);	else		return false;}space_id_t system::get_locus_space(locus_id_t eid) const throw(system::entity_not_found){	const locus_record *lr = get_record<locus_record>(eid,entities_);	if (lr == nil) 		throw entity_not_found(eid);	return lr->space();}bool system::locus_is_dynamic(locus_id_t eid) const throw(system::entity_not_found){	const locus_record *lr = get_record<locus_record>(eid,entities_);	if (lr == nil) 		throw entity_not_found(eid);	return lr->is_dynamic();}void system::get_point(locus_id_t eid, space_id_t dest, cvector &pos) const throw(system::entity_not_found){	const locus_record *lr = get_record<locus_record>(eid,entities_);	if (lr == nil) 		throw entity_not_found(eid);	space_id_t src = lr->space();		pos = scalar0;	const vector_function *ax = lr->accessor();		if (src == dest || dest == 0) {		ax->apply(pos, scalar1, sim()->state());	} else {		const index_t n = ax->result_size(sim()->state().height());		cvector x(n,one,init_zero);		ax->apply(x, scalar1, sim()->state());		const vector_function *xform = get_space_transform(src,dest);		xform->apply(pos, scalar1, x);	}}void system::get_segment_start(locus_id_t eid, space_id_t dest, cvector &pos) const throw(system::entity_not_found){	const locus_record *lr = get_record<locus_record>(eid,entities_);	if (lr == nil) 		throw entity_not_found(eid);	space_id_t src = lr->space();	const index_t d = this->get_space_dimensions(src);		pos = scalar0;		if (src == dest || dest == 0) {		const vector_function *ax = lr->accessor();		(*ax)[range(0,d)].apply(pos, scalar1, sim()->state());	} else {		const vector_function *ax = lr->accessor();		const vector_function *xform = get_space_transform(src,dest);		((*xform)(adapt_vf((*ax)[range(0,d)]))).apply(pos, scalar1, sim()->state());			}}void system::get_segment_end(locus_id_t eid, space_id_t dest, cvector &pos) const throw(system::entity_not_found){	const locus_record *lr = get_record<locus_record>(eid,entities_);	if (lr == nil) 		throw entity_not_found(eid);	space_id_t src = lr->space();	const index_t d = this->get_space_dimensions(src);		pos = scalar0;		if (src == dest || dest == 0) {		const vector_function *ax = lr->accessor();		(*ax)[range(d,d)].apply(pos, scalar1, sim()->state());	} else {		const vector_function *ax = lr->accessor();		const vector_function *xform = get_space_transform(src,dest);		((*xform)(adapt_vf((*ax)[range(d,d)]))).apply(pos, scalar1, sim()->state());			}}void system::get_segment_position(locus_id_t eid, scalar_t u, space_id_t dest, cvector &pos) const throw(system::entity_not_found){	const locus_record *lr = get_record<locus_record>(eid,entities_);	if (lr == nil) 		throw entity_not_found(eid);	AC_PRECONDITION(lr->get_locus_type() == locus_segment_type)	space_id_t src = lr->space();		pos = scalar0;	const vector_function *ax = lr->accessor();	if (src == dest || dest == 0) {		(parametric_segment_vf(ax, u)).apply(pos, scalar1, sim()->state());	} else {		const vector_function *xform = get_space_transform(src,dest);		((*xform)(adapt_vf(parametric_segment_vf(ax, u)))).apply(pos, scalar1, sim()->state());	}}const vector_function* system::create_point_accessor(locus_id_t eid, space_id_t dest) const throw(system::entity_not_found){	const locus_record *lr = get_record<locus_record>(eid,entities_);	if (lr == nil) 		throw entity_not_found(eid);	space_id_t src = lr->space();		if (src == dest || dest == 0) {		const vector_function *ax = lr->accessor();		return vector_function::make_vf(adapt_vf(ax));	} else {		const vector_function *ax = lr->accessor();		const vector_function *xform = get_space_transform(src,dest);		return vector_function::make_vf((*xform)(ax));		}}const vector_function* system::create_segment_start_accessor(locus_id_t eid, space_id_t dest) const throw(system::entity_not_found){	const locus_record *lr = get_record<locus_record>(eid,entities_);	if (lr == nil) 		throw entity_not_found(eid);	space_id_t src = lr->space();	const index_t d = this->get_space_dimensions(src);		const vector_function *ax = lr->accessor();	if (src == dest || dest == 0) {		return vector_function::make_vf((*ax)[range(0,d)]);	} else {		const vector_function *xform = get_space_transform(src,dest);		return vector_function::make_vf((*xform)(adapt_vf((*ax)[range(0,d)])));	}}const vector_function* system::create_segment_end_accessor(locus_id_t eid, space_id_t dest) const throw(system::entity_not_found){	const locus_record *lr = get_record<locus_record>(eid,entities_);	if (lr == nil) 		throw entity_not_found(eid);	space_id_t src = lr->space();	const index_t d = this->get_space_dimensions(src);		const vector_function *ax = lr->accessor();	if (src == dest || dest == 0) {		return vector_function::make_vf((*ax)[range(d,d)]);	} else {		const vector_function *xform = get_space_transform(src,dest);		return vector_function::make_vf((*xform)(adapt_vf((*ax)[range(d,d)])));	}}const vector_function* system::create_locus_parametric_accessor(locus_id_t eid, space_id_t dest, const cvector &u) const throw(system::entity_not_found){	const locus_record *lr = get_record<locus_record>(eid,entities_);	if (lr == nil) 		throw entity_not_found(eid);	AC_PRECONDITION(lr->get_locus_type() == locus_segment_type)	space_id_t src = lr->space();	const vector_function *ax = lr->accessor();	if (src == dest || dest == 0) {		return vector_function::make_vf(adapt_vf(parametric_segment_vf(ax, u[zero])));	} else {		const vector_function *xform = get_space_transform(src,dest);		return vector_function::make_vf((*xform)(adapt_vf(parametric_segment_vf(ax, u[zero]))));	}}} // namespace cf_geocore