/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __GEO_LOCUS_H#define __GEO_LOCUS_H#include "geo-space.h"#include "vector-function.h"#include "matrix-inst.h"#include "matrix-io.h"#include <iostream>#include <map>namespace cf_geocore {class locus;class point;class line;/*1.				2.					3.*/class locus {public:		typedef locus				this_t;									locus(const vector_space *s, index_t n)	: space_(s), state_(n, one, init_zero) {}									locus(const this_t &loc)			: space_(loc.space_), state_(loc.state_.height(),one) 																		{ state_ = loc.state_; }virtual								~locus(void)						{ space_ = nil; }				this_t&				operator= (const this_t &loc)		{ space_ = loc.space_; state_ = loc.state_; return *this; }						  const vector_space*			space(void) const					{ return space_; }				index_t				dimensions(void) const				{ return space_->dimensions(); }								index_t				state_size(void) const				{ return state_.height(); }				void				state(matrixn1 &state) const		{ state = state_; }		  const cvector&			state(void) const					{ return state_; }protected:									locus(const vector_space *s, const matrixn1 &st)																		: space_(s), state_(st.height(),one)																		{ state_ = st; }				cvector&			state(void)							{ return state_; }private:						  const vector_space*		space_;				cvector				state_;};class point : public locus {public:		typedef point				this_t;		typedef locus				base_t;											point(const vector_space *s)				: base_t(s, s->dimensions()) {} template<class E, class S>			point(const vector_space *s, const matrix<E,S> &pt) 																		: base_t(s, s->dimensions()) 																		{ AC_PRECONDITION(pt.height() == s->dimensions())																		  state() = pt; }											point(const point &p, const vector_space *s, const vector_function *transform);									point(const this_t &loc)			: base_t(loc) {}				void				set(const point &src, const vector_function *xform);template<class E, class S>				void				set(const matrix<E,S> &pt)			{ state() = pt; }				void				position(matrixn1 &pos) const		{ this->state(pos); }				scalar_t			operator[](index_t i) const			{ return state()[i]; }				};class segment : public locus {public:		typedef segment			this_t;		typedef locus			base_t;											segment(const vector_space *s)		: base_t(s, 2 * s->dimensions()) {} 																		segment(const vector_space *s, const point &p0, const point &p1) 																		: base_t(s, 2 * s->dimensions())																		{																		  const index_t d = this->dimensions();																		  matrixn1 s0(this->state(), range(0,d), row_axis),																		  		   s1(this->state(), range(d,d), row_axis);																		  p0.position(s0); 																		  p1.position(s1); 																		}																		  									segment(const this_t &loc)			: base_t(loc) {}				void				set(const segment &src, const vector_function *xform);				void				compute_start(matrixn1 &pos) const	{ pos = this->state().rows(range(0,dimensions())); }								void				compute_end  (matrixn1 &pos) const	{ pos = this->state().rows(range(dimensions(),dimensions())); }				void				position(matrixn1 &pos, scalar_t t)	{																		  pos = scalar0; 																		  const index_t d = this->dimensions(); 																		  axpy((scalar1 - t), this->state().rows(range(0,d)), 																		       t, this->state().rows(range(d,d)), 																		       scalar1, pos);																		}				scalar_t			nearest_parametric_position(const point& pt) const;static			scalar_t			nearest_parametric_position(const cvector &p, const cvector &seg0, const cvector &seg1);};class parametric_segment_vf {public:		typedef parametric_segment_vf	this_t;					typedef index_t				result_size_t;									parametric_segment_vf(const vector_function *segment_accessor, scalar_t t)																		: f_(segment_accessor), t_(t) {}	template<class q_t, class result_t>					void				apply(result_t &r, const scalar_t &a, const q_t &q) const																		{																		  const index_t d = f_->result_size(q.height()) / 2;																		  matrixn1 seg(d+d,one,init_zero);																		  f_->apply(seg,a,q);																		  matrixn1 p0(seg,range(0,d),row_axis),																		  		   p1(seg,range(d,d),row_axis);																		  axpy((scalar1 - t_), p0, t_, p1, scalar1, r);																		}	template<class q_t, class result_t, class dfdq_t>					void				apply_derive(result_t &r, dfdq_t &dfdq, const scalar_t &a, const q_t &q) const																		{																		  const index_t qsize = q.height(),																		  			       d = f_->result_size(qsize) / 2;																		  matrixn1 seg(d+d,one,init_zero);																		  matrixn dseg(d+d,qsize,init_zero);																		  f_->apply_derive(seg,dseg,a,q);																		  matrixn1 p0(seg,range(0,d),row_axis),																		  		   p1(seg,range(d,d),row_axis);																		  matrixn dp0(dseg,range(0,d),row_axis),																		  		  dp1(dseg,range(d,d),row_axis);																		  axpy((scalar1 - t_),  p0, t_,  p1, scalar1, r);																		  axpy((scalar1 - t_), dp0, t_, dp1, scalar1, dfdq);																		}	template<class q_t, class dfdq_t> 					void				derive(dfdq_t &dfdq, const scalar_t &a, const q_t &q) const																		{																		  const index_t qsize = q.height(),																		  			       d = f_->result_size(qsize) / 2;																		  matrixn dseg(d+d,qsize,init_zero);																		  f_->derive(dseg,a,q);																		  matrixn dp0(dseg,range(0,d),row_axis),																		  		  dp1(dseg,range(d,d),row_axis);																		  axpy((scalar1 - t_), dp0, t_, dp1, scalar1, dfdq);																		}template<class q_size_t>				result_size_t		result_size(const q_size_t &q_size) const																		{ return f_->result_size(q_size) / 2; }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &)																		{ return (os << "interp "); }private:			  const vector_function*	f_;					scalar_t			t_;};} // namespace cf_geocore#endif /* __GEO_LOCUS_H */