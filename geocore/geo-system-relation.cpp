/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999-2000 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#include "geo-system.h"#include "geo-system-impl.h"#include "geo-relations.h"namespace cf_geocore {relation_id_t system::add_relation(tag_t reln_tag, space_id_t space, const std::vector<locus_id_t> &participants){	relation_id_t reln = NULL;		switch(reln_tag) {			case relation_point_position_type:			break;		case relation_segment_length_type:			break;		case relation_point_distance_type:			break;		case relation_point_angle_distance_type:			break;		case relation_parametric_distance_type:			break;	}		return reln;}bool system::can_add_relation(tag_t reln_tag, space_id_t space, const std::vector<locus_id_t> &participants) const{	return false;}relation_id_t system::add_relation(const vector_relation *vf, tag_t rtag, space_id_t sid, const std::vector<locus_id_t> &participants)	//*** disallow if reln with rtag and sid is already there {	relation_id_t rid = this->new_id();		relation_record *rr = new relation_record(rtag,rid);	rr->set_default_name();	rr->set_relation(vf);	rr->set_space(sid);	rr->set_participants(participants);		entities_[rid] = rr;		if (observer_)		observer_->handle_entity_added(rid);	return rid;}bool system::has_relation(relation_id_t rid) const{	const relation_record *rr = get_record<relation_record>(rid,entities_);	return (rr != nil);}void system::remove_relation(relation_id_t rid) throw(system::entity_not_found){	entities_t::iterator p = entities_.find(rid);		if (p == entities_.end() || (p->second->get_entity_type() != entity_relation_type))		throw entity_not_found(rid);		entity_record *rr = p->second;		this->deactivate_relation(rid);		entities_.erase(p);		delete rr;	if (observer_)		observer_->handle_entity_removed(rid);}const vector_relation* system::get_relation(relation_id_t rid) const throw(system::entity_not_found){	const relation_record *rr = get_record<relation_record>(rid,entities_);	if (rr == nil) 		throw entity_not_found(rid);	return rr->relation();}bool system::relation_record::has_participant(locus_id_t lid) const{	bool found = false;	std::vector<locus_id_t>::const_iterator pit = participants_.begin(),										  pstop = participants_.end();	while (pit != pstop) {		if (*pit == lid) {			found = true;			break;		}		++pit;	}	return found;}relation_id_t system::get_relation(locus_id_t eid, tag_t rtag, space_id_t sid) const throw(system::entity_not_found){	relation_id_t rid = 0;		entities_t::const_iterator eit = entities_.begin(),							 estop = entities_.end();	while (eit != estop) {		const entity_record *er = eit->second;		++eit;		if (er->get_entity_type() == entity_relation_type) {			const relation_record *rr = (const relation_record*) er;			if (rr->get_relation_type() == rtag && rr->space() == sid)				if (rr->has_participant(eid)) {					rid = er->id();					break;				}		}	}	return rid;}relation_id_t system::get_relation(locus_id_t eid1, locus_id_t eid2, tag_t rtag, space_id_t sid) const throw(system::entity_not_found){	relation_id_t rid = 0;		entities_t::const_iterator eit = entities_.begin(),							 estop = entities_.end();	while (eit != estop) {		const entity_record *er = eit->second;		++eit;		if (er->get_entity_type() == entity_relation_type) {			const relation_record *rr = (const relation_record*) er;			if (rr->get_relation_type() == rtag && rr->space() == sid && 				rr->has_participant(eid1) && rr->has_participant(eid2)) {				rid = er->id();				break;			}		}	}	return rid;}space_id_t system::get_relation_space(relation_id_t rid) const throw(system::entity_not_found){	const relation_record *rr = get_record<relation_record>(rid,entities_);	if (rr == nil) 		throw entity_not_found(rid);	return rr->space();}system::tag_t system::get_relation_type(relation_id_t rid) const throw(system::entity_not_found){	const relation_record *rr = get_record<relation_record>(rid,entities_);	if (rr == nil) 		throw entity_not_found(rid);	return rr->get_relation_type();}index_t system::get_relation_num_participants(relation_id_t rid) const throw(system::entity_not_found){	const relation_record *rr = get_record<relation_record>(rid,entities_);	if (rr == nil) 		throw entity_not_found(rid);	return rr->participants().size();}locus_id_t system::get_relation_nth_participant(relation_id_t rid, index_t n) const throw(system::entity_not_found){	const relation_record *rr = get_record<relation_record>(rid,entities_);	if (rr == nil) 		throw entity_not_found(rid);	return rr->participants()[n];}void system::activate_relation(relation_id_t rid) throw(system::entity_not_found){	relation_record *rr = get_record<relation_record>(rid,entities_);	if (rr == nil) 		throw entity_not_found(rid);	const vector_relation *rel = rr->relation();	const vector_function *vf = rel->get_relation();	if (! sim()->is_constraint(vf)) {		sim()->add_constraint(vf);		rr->set_seed(sim());	}}void system::deactivate_relation(relation_id_t rid) throw(system::entity_not_found){	relation_record *rr = get_record<relation_record>(rid,entities_);	if (rr == nil) 		throw entity_not_found(rid);	const vector_relation *rel = rr->relation();	const vector_function *vf = rel->get_relation();	if (sim()->is_constraint(vf)) {		sim()->remove_constraint(vf);		rr->set_seed(sim());	}}bool system::relation_is_active(relation_id_t rid) const throw(system::entity_not_found){	const relation_record *rr = get_record<relation_record>(rid,entities_);	if (rr == nil) 		throw entity_not_found(rid);	const vector_relation *rel = rr->relation();	return (sim()->is_constraint(rel->get_relation()));}} // namespace cf_geocore