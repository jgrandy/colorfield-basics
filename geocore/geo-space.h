/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __GEOMETRY_SPACE_H#define __GEOMETRY_SPACE_H#include "geometry-core.h"#include "geo-system.h"#include "index.h"#include <map>namespace cf_geocore {/*1.				2.					3.*/class vector_space {public:		typedef vector_space		this_t;		typedef space_id_t			id_t;		typedef system::entity_subtype space_type_t;				typedef uint32_t			coord_type;							enum {									offset_coord = 'rect',									angle_coord = 'angl'								 };											vector_space(index_t dims, space_type_t t)			: dims_(dims), type_(t), id_(nil), sys_(nil), basis_(nil) {}virtual								~vector_space(void);				void				initialize(const vector_space *basis);				void				initialize(system *sys);								index_t				dimensions(void) const								{ return dims_; }				space_type_t		space_type(void) const								{ return type_; }		  const vector_space*		basis_space(void) const								{ return basis_; }virtual			coord_type			coordinate_type(index_t) const						{ return offset_coord; }virtual			index_t				reorder(index_t i) const							{ return i; }										// override these to add/remove "reference" colors (e.g. illuminant, primaries)virtual			space_id_t			add_to_system(system *sys);virtual			void				remove_from_system(void);				system*				get_system(void) const								{ return sys_; }				id_t				get_id(void) const									{ return id_; }					virtual			bool				has_direct_transform_to_basis(const vector_space *basis) const;virtual	  const vector_function*	create_direct_transform_to_basis(const vector_space *basis) const = 0;virtual			bool				has_direct_transform_from_basis(const vector_space *basis) const;virtual	  const vector_function*	create_direct_transform_from_basis(const vector_space *basis) const = 0;private:									vector_space(const this_t &);				this_t&				operator= (const this_t &);								index_t				dims_;				space_type_t		type_;				space_id_t			id_;				system*				sys_;		  const vector_space*		basis_;};template<index_t D, typename R = reordering<D>, 		 vector_space::space_type_t C0 = vector_space::offset_coord, vector_space::space_type_t C1 = vector_space::offset_coord, 		 vector_space::space_type_t C2 = vector_space::offset_coord, vector_space::space_type_t C3 = vector_space::offset_coord, 		 vector_space::space_type_t C4 = vector_space::offset_coord, vector_space::space_type_t C5 = vector_space::offset_coord, 		 vector_space::space_type_t C6 = vector_space::offset_coord, vector_space::space_type_t C7 = vector_space::offset_coord> struct vector_space_traits {		typedef vector_space::coord_type coords_t;		typedef cindex<D>			dim_t;		typedef R					reordering_t;static	  const dim_t				dim_;static		vector_space::space_type_t	coord(zero_t )				{ return C0; }static		vector_space::space_type_t	coord(one_t  )				{ return C1; }static		vector_space::space_type_t	coord(two_t  )				{ return C2; }static		vector_space::space_type_t	coord(three_t)				{ return C3; }static		vector_space::space_type_t	coord(four_t )				{ return C4; }static		vector_space::space_type_t	coord(five_t )				{ return C5; }static		vector_space::space_type_t	coord(six_t  )				{ return C6; }static		vector_space::space_type_t	coord(seven_t)				{ return C7; }static				index_t				coord(index_t i)			{ static const vector_space::space_type_t sw[8] = { C0, C1, C2, C3, C4, C5, C6, C7 }; return sw[i]; }};template<index_t D, typename R,		 vector_space::space_type_t C0, vector_space::space_type_t C1, vector_space::space_type_t C2, vector_space::space_type_t C3, 		 vector_space::space_type_t C4, vector_space::space_type_t C5, vector_space::space_type_t C6, vector_space::space_type_t C7>	const cindex<D> vector_space_traits<D,R,C0,C1,C2,C3,C4,C5,C6,C7>::dim_;template<index_t I0=0, index_t I1=1, index_t I2=2>struct rectangular3_vector_space_traits : public vector_space_traits<3,reordering<3,I0,I1,I2> > {		typedef rectangular3_vector_space_traits<I0,I1,I2> this_t;		typedef vector_space_traits<3,reordering<3,I0,I1,I2> > base_t;};template<index_t I0=0, index_t I1=1, index_t I2=2, index_t I3=3>struct rectangular4_vector_space_traits : public vector_space_traits<4,reordering<4,I0,I1,I2,I3> > {		typedef rectangular4_vector_space_traits<I0,I1,I2,I3> this_t;		typedef vector_space_traits<4,reordering<4,I0,I1,I2,I3> > base_t;};template<index_t I0=0, index_t I1=1, index_t I2=2>struct cylindrical_vector_space_traits : public vector_space_traits<3,reordering<3,I0,I1,I2>,vector_space::offset_coord,vector_space::angle_coord,vector_space::offset_coord> {		// I0 is radius, I1 is angle, I2 is height		typedef cylindrical_vector_space_traits<I0,I1,I2> this_t;		typedef vector_space_traits<3,reordering<3,I0,I1,I2>,vector_space::offset_coord,vector_space::angle_coord,vector_space::offset_coord> base_t;};template<class Traits> class static_vector_space : public vector_space {public:		typedef Traits							traits_t;		typedef static_vector_space<traits_t>	this_t;		typedef vector_space					base_t;		typedef base_t::space_type_t			space_type_t;		typedef typename Traits::reordering_t			reordering_t;													static_vector_space(space_type_t t)				: base_t(traits_t::dim_,t) {}virtual			coord_type			coordinate_type(index_t i) const				{ return traits_t::coord(i); }virtual			index_t				reorder(index_t i) const						{ return traits_t::reordering_t::reorder(i); }    virtual	  const vector_function*    create_direct_transform_to_basis(const vector_space *basis) const { return nil; }    virtual	  const vector_function*    create_direct_transform_from_basis(const vector_space *basis) const { return nil; }};} // cf_geocore#endif /* __GEOMETRY_SPACE_H */