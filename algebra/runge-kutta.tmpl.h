/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __RUNGE_KUTTA_TMPL_H#define __RUNGE_KUTTA_TMPL_H#include "runge-kutta.h"#include <algorithm>#include <limits>#include <cmath>namespace cf_algebra {template<class Q>rk4_solver<Q>::~rk4_solver(void){		if (temp_q_vector)     delete temp_q_vector;		if (temp_qdot1_vector) delete temp_qdot1_vector;		if (temp_qdot2_vector) delete temp_qdot2_vector;}	template<class Q>void rk4_solver<Q>::set_state(const time_t &t0, const q_t &q0, const qdot_t &qdot0){	const typename q_t::height_t qsize = q0.height();		base_t::set_state(t0,q0,qdot0);		if ((!temp_q_vector) || (temp_q_vector->height() != qsize)) {		if (temp_q_vector) delete temp_q_vector;		temp_q_vector = new q_t(qsize, one);			if (temp_qdot1_vector) delete temp_qdot1_vector;		temp_qdot1_vector = new qdot_t(qsize, one); 		if (temp_qdot2_vector) delete temp_qdot2_vector;		temp_qdot2_vector = new qdot_t(qsize, one);	}}template<class Q>typename rk4_solver<Q>::time_t rk4_solver<Q>::step(void){		const time_t full_stepsize = this->delta_t_,				 half_stepsize  = full_stepsize / ((time_t) 2.0),				 third_stepsize = full_stepsize / ((time_t) 3.0),				 sixth_stepsize = full_stepsize / ((time_t) 6.0);				 	const time_t t0 = this->get_time(),				 half_step  = t0 + half_stepsize,				 whole_step = t0 + full_stepsize;				 	const typename q_t::height_t qsize = this->q_->height();			q_t    &temp_q     = *temp_q_vector;	qdot_t &temp_qdot1 = *temp_qdot1_vector,		   &temp_qdot2 = *temp_qdot2_vector;		matrixn1 temp_t(one,one);			// First Step	axpy((scalar_t) 1, *(this->q_),		 half_stepsize, *(this->qdot_),		 (scalar_t) 0, temp_q);		// Second Step	temp_qdot1 = (scalar_t) 0;	(this->f_).apply(temp_qdot1, temp_q, half_step);	axpy((scalar_t) 1, *(this->q_),		 half_stepsize, temp_qdot1,		 (scalar_t) 0, temp_q);			// Third Step	temp_qdot2 = (scalar_t) 0;	(this->f_).apply(temp_qdot2, temp_q, half_step);	axpy((scalar_t) 1, *(this->q_),		 full_stepsize, temp_qdot2, 		 (scalar_t) 0, temp_q);	temp_qdot2 += temp_qdot1;			// Fourth Step	temp_qdot1 = (scalar_t) 0;	(this->f_).apply(temp_qdot1, temp_q, whole_step);	axpy(sixth_stepsize, *(this->qdot_),		 (scalar_t) 1, *(this->q_));	axpy(sixth_stepsize, temp_qdot1,		 third_stepsize, temp_qdot2, 		 (scalar_t) 1, *(this->q_));		*(this->qdot_) = (scalar_t) 0;	(this->f_).apply(*(this->qdot_), *(this->q_), whole_step);		this->set_time(whole_step);	return whole_step;}template<class Q>adaptive_rk4_solver<Q>::~adaptive_rk4_solver(void){	flush_caches();}template<class Q>void adaptive_rk4_solver<Q>::set_state(const time_t &t0, const q_t &q0, const qdot_t &qdot0){	const typename q_t::height_t qsize = q0.height();		base_t::set_state(t0,q0,qdot0);		if ((!temp_q_vector1) || (temp_q_vector1->height() != qsize)) {			flush_caches();		temp_q_vector1   = new q_t(qsize, one);		temp_q_vector2   = new q_t(qsize, one);		temp_q_vector3   = new q_t(qsize, one);		temp_qdot_vector = new qdot_t(qsize, one);		q_error_vector   = new q_t(qsize, one);		ak2_vector = new qdot_t(qsize, one);		ak3_vector = new qdot_t(qsize, one);		ak4_vector = new qdot_t(qsize, one);		ak5_vector = new qdot_t(qsize, one);		ak6_vector = new qdot_t(qsize, one);	}}template<class Q>void adaptive_rk4_solver<Q>::flush_caches(void) const{	if (temp_q_vector1)   delete temp_q_vector1;	if (temp_q_vector2)   delete temp_q_vector2;	if (temp_q_vector3)   delete temp_q_vector3;	if (temp_qdot_vector) delete temp_qdot_vector;	if (q_error_vector)   delete q_error_vector;	if (ak2_vector)       delete ak2_vector;	if (ak3_vector)       delete ak3_vector;	if (ak4_vector)       delete ak4_vector;	if (ak5_vector)       delete ak5_vector;	if (ak6_vector)       delete ak6_vector;}template<class Q>typename adaptive_rk4_solver<Q>::time_t adaptive_rk4_solver<Q>::step(void){	const time_t tiny = std::numeric_limits<time_t>::epsilon();	const index_t max_steps = 1000;	      time_t t_current = this->get_time();	      time_t substep   = this->delta_t_;	      	const time_t t_target  = t_current + substep;		matrixn1 temp_t(one,one);		const typename q_t::height_t qsize = this->q_->height();			qdot_t &temp_qdot = *temp_qdot_vector;	   q_t &q_scale   = *temp_q_vector1;	   q_t *qs[2]     = { temp_q_vector2, temp_q_vector3 };	   	unsigned int steps = 0;	// setup initial state (becomes last_q in first iteration of loop, below)	*(qs[0]) = *(this->q_);	*(qs[1]) = (time_t) 0.0;	// debugging		while (steps < max_steps) {	 	const q_t &last_q = *(qs[steps % 2]);	 	      q_t &next_q = *(qs[(steps + 1) % 2]);		temp_qdot = (scalar_t) 0;		(this->f_).apply(temp_qdot, last_q, t_current);					for (index_t i=0; i<qsize; i++)			q_scale(i,0) = std::fabs((*(this->q_))(i,0)) + std::fabs(temp_qdot(i,0)*substep) + tiny;				if (((t_current + substep - t_target) * (t_current + substep - this->get_time())) > 0.)			substep = t_target - t_current;				t_current += this->step_once(next_q, substep, 							 		 t_current, substep, 							 		 last_q, temp_qdot, q_scale);							 		 		if (((t_current - t_target) * this->delta_t_) >= 0.0) {			*(this->q_) = next_q;			this->set_time(t_current);			return t_current;		}					if (std::fabs(substep) <= min_step_)			throw step_size_too_small();				steps++;	}	throw too_many_steps();}template<class Q>typename adaptive_rk4_solver<Q>::time_t adaptive_rk4_solver<Q>::step_once(      q_t &new_q, time_t &next_stepsize, 													const time_t t, const time_t stepsize,													const q_t &q, const qdot_t &qdot,													const q_t &q_scale){	const time_t safety = (time_t) 0.9,			  pgrow  = (time_t) -0.2,			  pshrnk = (time_t) -0.25,			  errcon = (time_t) 1.89e-4; // (5/safety)^(1/pgrow)	const time_t tiny   = std::numeric_limits<time_t>::epsilon();				 	const typename q_t::height_t qsize = q.height();	q_t &q_error   = *q_error_vector;	time_t h = stepsize;	time_t errmax;		while (true) {			this->static_rk5_step(new_q, t, h, q, qdot, q_error);				errmax = (time_t) 0.0;		for (index_t i=0; i<qsize; i++)//			errmax = fmax(errmax, fabs(q_error[i] / q_scale[i]));			errmax = (q_scale(i,0) <= tiny)						? errmax                        : std::max(errmax, (time_t) std::fabs(q_error(i,0) / q_scale(i,0)));		errmax /= eps_;		if (errmax < 1.0)			break;					const time_t htemp = safety * h * pow(errmax, pshrnk);				if (h > 0.0)			h = std::max(htemp, ((time_t) 0.1) * h);		else			h = std::min(htemp, ((time_t) 0.1) * h);				if (t + h == t)			throw std::runtime_error("stepsize underflow in adaptive runge-kutta");	}		if (errmax > errcon)		next_stepsize = safety * h * pow(errmax,pgrow);	else		next_stepsize = (time_t) 5.0 * h;			return h;}template<class Q>void adaptive_rk4_solver<Q>::static_rk5_step(      q_t &new_q,																const time_t t, const time_t stepsize, 																const q_t &q, const qdot_t &qdot, 																q_t &q_error){	const time_t a2 = (time_t) 0.2,			  a3 = (time_t) 0.3,			  a4 = (time_t) 0.6,			  a5 = (time_t) 1.0,			  a6 = (time_t) 0.875,			 b21 = (time_t) 0.2,			 b31 = (time_t) (3.0 / 40.0),			 b32 = (time_t) (9.0 / 40.0),			 b41 = (time_t) 0.3,			 b42 = (time_t) -0.9,			 b43 = (time_t) 1.2,			 b51 = (time_t) (-11.0 / 54.0),			 b52 = (time_t) 2.5,			 b53 = (time_t) (-70.0 / 27.0),			 b54 = (time_t) (35.0 / 27.0),			 b61 = (time_t) (1631.0 / 55296.0),			 b62 = (time_t) (175.0 / 512.0),			 b63 = (time_t) (575.0 / 13824.0),			 b64 = (time_t) (44275.00 / 110592.0),			 b65 = (time_t) (253.00 / 4096.0),			  c1 = (time_t) (37.0 / 378.0),			  c3 = (time_t) (250.0 / 621.0),			  c4 = (time_t) (125.00 / 594.0),			  c6 = (time_t) (512.00 / 1771.0),			 dc5 = (time_t) (-277.0 / 14336.0),			 dc1 = c1 - (time_t) (2825.0 / 27648.0),			 dc3 = c3 - (time_t) (18575.0 / 48384.0),			 dc4 = c4 - (time_t) (13525.0 / 55296.0),			 dc6 = c6 - (time_t) 0.25;	qdot_t &ak2  = *ak2_vector,		   &ak3  = *ak3_vector,		   &ak4  = *ak4_vector,		   &ak5  = *ak5_vector,		   &ak6  = *ak6_vector;	matrixn1 temp_t(one,one);	{		q_t &temp_q  = new_q;		// we don't need this storage until later; use it as temp until then			// first step		axpy((scalar_t) 1, q,			 b21*stepsize, qdot, 			 (scalar_t) 0, temp_q);		ak2 = (scalar_t) 0;		(this->f_).apply(ak2, temp_q, t + (a2 * stepsize));				// second step		temp_q = q;		axpy(b31*stepsize, qdot, 			 b32*stepsize, ak2,			 (scalar_t) 1, temp_q);		ak3 = (scalar_t) 0;		(this->f_).apply(ak3, temp_q, t + (a3 * stepsize));				// third step		axpy((scalar_t) 1, q,			 b41*stepsize, qdot, 			 (scalar_t) 0, temp_q);		axpy(b42*stepsize, ak2, 			 b43*stepsize, ak3, 			 (scalar_t) 1, temp_q);		ak4 = (scalar_t) 0;		(this->f_).apply(ak4, temp_q, t + (a4 * stepsize));		// fourth step		temp_q = q;		axpy(b51*stepsize, qdot,			 b52*stepsize, ak2, 			 (scalar_t) 1, temp_q);		axpy(b53*stepsize, ak3,			 b54*stepsize, ak4, 			 (scalar_t) 1, temp_q);		ak5 = (scalar_t) 0;		(this->f_).apply(ak5, temp_q, t + (a5 * stepsize));		// fifth step		axpy((scalar_t) 1, q,			 b61*stepsize, qdot, 			 (scalar_t) 0, temp_q);		axpy(b62*stepsize, ak2, 			 b63*stepsize, ak3, 			 (scalar_t) 1, temp_q);		axpy(b64*stepsize, ak4, 			 b65*stepsize, ak5, 			 (scalar_t) 1, temp_q);		ak6 = (scalar_t) 0;		(this->f_).apply(ak6, temp_q, t + (a6 * stepsize));	}			// flesh out the answer	new_q = q;	axpy(c1*stepsize, qdot, 		 c3*stepsize, ak3, 		 (scalar_t) 1, new_q);	axpy(c4*stepsize, ak4, 		 c6*stepsize, ak6, 		 (scalar_t) 1, new_q);		axpy(dc1*stepsize, qdot, 		 dc3*stepsize, ak3, 		 (scalar_t) 0, q_error);	axpy(dc4*stepsize, ak4, 		 dc5*stepsize, ak5, 		 (scalar_t) 1, q_error);	axpy(dc6*stepsize, ak6, 		 (scalar_t) 1, q_error);}} /* namespace cf_algebra */#endif /* __RUNGE_KUTTA_TMPL_H */