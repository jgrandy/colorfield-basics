/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __MATRIX_OPS_MULTIPLY_TMPL_H#define __MATRIX_OPS_MULTIPLY_TMPL_H#include "matrix.h"#include "matrix-ops.h"#include "matrix-exceptions.h"#include "matrix-ops-meta-tmpl.h"#include "colorfield-functionals.h"namespace cf_algebra {// y <- A xtemplate<class R1, class Structure1, class Extent2, class Structure2, class R3, class Structure3>		matrix<coord_t<R1,one_t>,Structure1>&	matrix_multiply															(      matrix<coord_t<R1,one_t>,Structure1> &y,															 const matrix<Extent2,          Structure2> &a,															 const matrix<coord_t<R3,one_t>,Structure3> &x){	AC_PRECONDITION(y.height() == a.height());	AC_PRECONDITION(a.width() == x.height());		const R1 h = y.height();	const R3 n = x.height();		typename matrix<coord_t<R1,one_t>,Structure1>::col_it_t y_it = y.col_it(zero);	for (int i=0; i<h; i++) {				scalar_t &y_elt = *y_it;		++y_it;				y_elt = (scalar_t) 0.0;				typename matrix<Extent2,          Structure2>::crow_it_t a_it = a.row_it(i);		typename matrix<coord_t<R3,one_t>,Structure3>::ccol_it_t x_it = x.col_it(zero);							for (int k=0; k<n; k++) {					const scalar_t a_val = *a_it;			const scalar_t x_val = *x_it;			++a_it; ++x_it;						y_elt += a_val * x_val;		}		}	return y;}// C <- x y'template<class Extent1, class Structure1, class R2, class Structure2, class C3, class Structure3>		matrix<Extent1,Structure1>&		matrix_multiply															(      matrix<Extent1,    Structure1> &c,															 const matrix<coord_t<R2,one_t>,Structure2> &x,															 const matrix<coord_t<one_t,C3>,Structure3> &y){	AC_PRECONDITION(c.height() == x.height());	AC_PRECONDITION(c.width() == y.width());		const typename Extent1::height_t h = c.height();	const typename Extent1::width_t  w = c.width();		typename matrix<coord_t<R2,one_t>,Structure2>::ccol_it_t x_it = x.col_it(zero);		for (int i=0; i<h; i++) {				const scalar_t x_val = *x_it;		++x_it;		typename matrix<Extent1,          Structure1>:: row_it_t c_it = c.row_it(i);		typename matrix<coord_t<one_t,C3>,Structure3>::crow_it_t y_it = y.row_it(zero);				for (int j=0; j<w; j++) {			const scalar_t y_val = *y_it;			scalar_t &c_elt = *c_it;			++y_it; ++c_it;						c_elt = x_val * y_val;				}	}	return c;}															 // a <- x' ytemplate<class R1, class Structure1, class R2, class Structure2>		scalar_t&										matrix_multiply															(      scalar_t &a,															 const matrix<coord_t<one_t,R1>,Structure1> &x,															 const matrix<coord_t<R2,one_t>,Structure2> &y){	AC_PRECONDITION(x.width() == y.height());		const R1 h = x.width();		a = (scalar_t) 0.0;		typename matrix<coord_t<one_t,R1>,Structure1>::crow_it_t x_it = x.row_it(zero);	typename matrix<coord_t<R2,one_t>,Structure2>::ccol_it_t y_it = y.col_it(zero);		for (int i=0; i<h; i++) {		const scalar_t x_val = *x_it;		const scalar_t y_val = *y_it;		++x_it; ++y_it;				a += x_val * y_val;	}	return a;}															 // C <- A Btemplate<class Extent1, class Structure1, 				  class Extent2, class Structure2, 				  class Extent3, class Structure3>				matrix<Extent1,Structure1>&		matrix_multiply															(      matrix<Extent1,Structure1> &c,															 const matrix<Extent2,Structure2> &a,															 const matrix<Extent3,Structure3> &b){	AC_PRECONDITION(c.width()  == b.width());	AC_PRECONDITION(c.height() == a.height());	AC_PRECONDITION(a.width()  == b.height());		const typename Extent1::height_t h = c.height();	const typename Extent1::width_t  w = c.width();	const typename Extent2::width_t  n = a.width();		for (int i=0; i<h; i++) {			typename matrix<Extent1,Structure1>::row_it_t c_it = c.row_it(i);				for (int j=0; j<w; j++) {					scalar_t &c_elt = *c_it;			++c_it;						c_elt = (scalar_t) 0.0;						typename matrix<Extent2,Structure2>::crow_it_t a_it = a.row_it(i);			typename matrix<Extent3,Structure3>::ccol_it_t b_it = b.col_it(j);						for (int k=0; k<n; k++) {				const scalar_t a_val = *a_it;				const scalar_t b_val = *b_it;				++a_it; ++b_it;								c_elt += a_val * b_val;						}		}	}	return c;}// C <- A Btemplate<class Extent1, class Structure1, 				  class Extent2, class Structure2, 				  class Extent3, class Structure3>				matrix<Extent1,Structure1>&	matrix_multiply_upper_lower															(      matrix<Extent1,Structure1> &c,															 const matrix<Extent2,Structure2> &a,															 const matrix<Extent3,Structure3> &b){	AC_PRECONDITION(c.width() == c.height());	AC_PRECONDITION(a.extent() == c.extent());	AC_PRECONDITION(b.extent() == c.extent());	const typename Extent1::width_t n = c.width();		for (int i=0; i<n; i++) {			typename matrix<Extent1,Structure1>::row_it_t c_row = c.row_it(i);				for (int j=0; j<n; j++) {			const int s = std::max((uint32_t)i, (uint32_t)j);						typename matrix<Extent2,Structure2>::crow_it_t a_row = a.row_it(i);			a_row += s;			typename matrix<Extent3,Structure3>::ccol_it_t b_col = b.col_it(j);			b_col += s;						scalar_t &c_val = *c_row;			++c_row;			c_val = (scalar_t) 0.0;						for (int k=s; k<n; k++) {				const scalar_t a_val = *a_row;				const scalar_t b_val = *b_col;				++a_row; ++b_col;				c_val += a_val * b_val;			}			}	}	return c;}// y <- a x + b ytemplate<class Extent1, class Structure1, class Extent2, class Structure2>			matrix<Extent1,Structure1>&	axpy	  	(const scalar_t &a,													 const matrix<Extent2,Structure2> &x,													 const scalar_t &b,														   matrix<Extent1,Structure1> &y){	AC_PRECONDITION(x.height() == y.height());	AC_PRECONDITION(x.width() == y.width());		const typename Extent2::height_t h = x.height();	const typename Extent2::width_t  w = x.width();			for (int i=0; i<h; i++) {			typename matrix<Extent2,Structure2>::crow_it_t x_it = x.row_it(i);		typename matrix<Extent1,Structure1>:: row_it_t y_it = y.row_it(i);				for (int j=0; j<w; j++) {			const scalar_t  x_val = *x_it;			      scalar_t &y_val = *y_it;			++x_it; ++y_it;						y_val = (a * x_val) + (b * y_val);		}	}	return y;}// y <- a x + b ytemplate<class R1, class Structure1, class R2, class Structure2>		matrix<coord_t<R1,one_t>,Structure1>&	axpy	(const scalar_t &a,														 const matrix<coord_t<R2,one_t>,Structure2> &x,														 const scalar_t &b,														       matrix<coord_t<R1,one_t>,Structure1> &y){	AC_PRECONDITION(x.height() == y.height());		const R2 h = x.height();		typename matrix<coord_t<R2,one_t>,Structure2>::ccol_it_t x_it = x.col_it(zero);	typename matrix<coord_t<R1,one_t>,Structure1>:: col_it_t y_it = y.col_it(zero);			for (int i=0; i<h; i++) {		const scalar_t  x_val = *x_it;		      scalar_t &y_val = *y_it;		++x_it; ++y_it;				y_val = (a * x_val) + (b * y_val);	}	return y;}// y <- a x + b ytemplate<class R1, class Structure1, class Structure2>		matrix<coord_t<R1,one_t>,Structure1>&	axpy	(const scalar_t &a,														 const matrix<coord_t<one_t,one_t>,Structure2> &x,														 const scalar_t &b,														       matrix<coord_t<R1,one_t>,Structure1> &y){	AC_PRECONDITION(x.height() == y.height());		scalar_t &y_val = y(zero,zero);		y_val = (a * x(zero,zero)) + (b * y_val);		return y;}// z <- a x + b y + c z#if 0template<class R1, class Structure1, class R2, class Structure2, class R3, class Structure3>		matrix<coord_t<R1,one_t>,Structure1>&	axpy	  	(const scalar_t &a,															 const matrix<coord_t<R1,one_t>,Structure2> &x,															 const scalar_t &b,															 const matrix<coord_t<R2,one_t>,Structure3> &y,															 const scalar_t &c,															       matrix<coord_t<R3,one_t>,Structure1> &z){	AC_PRECONDITION(x.height() == y.height());	AC_PRECONDITION(x.height() == z.height());		const R1 h = x.height();		typename matrix<coord_t<R1,one_t>,Structure2>::ccol_it_t x_it = x.col_it(zero);	typename matrix<coord_t<R2,one_t>,Structure3>::ccol_it_t y_it = y.col_it(zero);	typename matrix<coord_t<R3,one_t>,Structure1>:: col_it_t z_it = z.col_it(zero);		for (int i=0; i<h; i++) {		const scalar_t  x_val = *x_it;		const scalar_t  y_val = *y_it;		      scalar_t &z_val = *z_it;		++x_it; ++y_it; ++z_it;				z_val = (a * x_val) + (b * y_val) + (c * z_val);	}	return z;}#endif// z <- a x + b y + c ztemplate<class Extent1, class Structure1, class Extent2, class Structure2, class Extent3, class Structure3>			matrix<Extent1,Structure1>&		axpy		(const scalar_t &a,															 const matrix<Extent2,Structure2> &x,															 const scalar_t &b,															 const matrix<Extent3,Structure3> &y,															 const scalar_t &c,															       matrix<Extent1,Structure1> &z){	AC_PRECONDITION(x.extent() == y.extent());	AC_PRECONDITION(x.extent() == z.extent());		const typename Extent1::height_t h = z.height();	const typename Extent1::width_t  w = z.width();	for (int i=0; i<h; i++) {		typename matrix<Extent2,Structure2>::crow_it_t x_it = x.row_it(i);		typename matrix<Extent3,Structure3>::crow_it_t y_it = y.row_it(i);		typename matrix<Extent1,Structure1>:: row_it_t z_it = z.row_it(i);			for (int j=0; j<w; j++) {			const scalar_t  x_val = *x_it;			const scalar_t  y_val = *y_it;			      scalar_t &z_val = *z_it;			++x_it; ++y_it; ++z_it;						z_val = (a * x_val) + (b * y_val) + (c * z_val);		}	}	return z;}// C <- a A B + b Ctemplate<class Extent1, class Structure1, class Extent2, class Structure2, class Extent3, class Structure3>			matrix<Extent1,Structure1>&		axpy		(const scalar_t &a,															 const matrix<Extent2,Structure2> &A,															 const matrix<Extent3,Structure3> &B,															 const scalar_t &b,															       matrix<Extent1,Structure1> &C){	AC_PRECONDITION(C.width()  == B.width());	AC_PRECONDITION(C.height() == A.height());	AC_PRECONDITION(A.width()  == B.height());		const typename Extent1::height_t h = C.height();	const typename Extent1::width_t  w = C.width();	const typename Extent2::width_t  n = A.width();		for (int i=0; i<h; i++) {			typename matrix<Extent1,Structure1>::row_it_t c_it = C.row_it(i);				for (int j=0; j<w; j++) {					scalar_t &c_elt = *c_it;			++c_it;			scalar_t ab = (scalar_t) 0;									typename matrix<Extent2,Structure2>::crow_it_t a_it = A.row_it(i);			typename matrix<Extent3,Structure3>::ccol_it_t b_it = B.col_it(j);						for (int k=0; k<n; k++) {				const scalar_t a_val = *a_it;				const scalar_t b_val = *b_it;				++a_it; ++b_it;								ab += a_val * b_val;						}						c_elt = (a * ab) + (b * c_elt);		}	}	return C;}				// y <- a A x + b ytemplate<class R1, class Structure1, class Extent2, class Structure2, class R3, class Structure3>		matrix<coord_t<R1,one_t>,Structure1>&	axpy		(const scalar_t &a,															 const matrix<Extent2,Structure2> &A,															 const matrix<coord_t<R3,one_t>,Structure3> &x,															 const scalar_t &b,															       matrix<coord_t<R1,one_t>,Structure1> &y){	const typename Extent2::height_t h = A.height();	const typename Extent2::width_t  w = A.width();		AC_PRECONDITION(h == y.height());	AC_PRECONDITION(w == x.height());		typename matrix<coord_t<R1,one_t>,Structure1>::col_it_t y_it = y.col_it(zero);		for (int i=0; i<h; i++) {		scalar_t &y_val = *y_it;		++y_it;					scalar_t Ax = (scalar_t) 0.0;				typename matrix<Extent2,          Structure2>::crow_it_t a_it = A.row_it(i);		typename matrix<coord_t<R3,one_t>,Structure3>::ccol_it_t x_it = x.col_it(zero);				for (int j=0; j<w; j++) {			const scalar_t &a_val = *a_it;			const scalar_t &x_val = *x_it;			++a_it; ++x_it;						Ax += (a_val * x_val);		}				y_val = (a * Ax) + (b * y_val);	}	return y;}// A <- a x y' + b Atemplate<class Extent1, class Structure1, class N2, class Structure2, class N3, class Structure3>			matrix<Extent1,Structure1>&		axpy		(const scalar_t &a,															 const matrix<coord_t<N2,one_t>,Structure2> &x,															 const matrix<coord_t<one_t,N3>,Structure3> &y,															 const scalar_t &b,															 matrix<Extent1,Structure1> &A){	AC_PRECONDITION(A.height() == x.height());	AC_PRECONDITION(A.width() == y.width());		const typename Extent1::height_t h = A.height();	const typename Extent1::width_t  w = A.width();		typename matrix<coord_t<N2,one_t>,Structure2>::ccol_it_t x_it = x.col_it(zero);		for (int i=0; i<h; i++) {				const scalar_t x_val = *x_it;		++x_it;		typename matrix<Extent1,           Structure1>:: row_it_t a_it = A.row_it(i);		typename matrix<coord_t<one_t,N3>,Structure3>::crow_it_t y_it = y.row_it(zero);				for (int j=0; j<w; j++) {			const scalar_t y_val = *y_it;			scalar_t &a_elt = *a_it;			++y_it; ++a_it;						a_elt = (a * x_val * y_val) + (b * a_elt);		}	}	return A;}} /* namespace cf_algebra */#endif /* __MATRIX_OPS_MULTIPLY_TMPL_H */