/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __CHOLESKY_TMPL_H#define __CHOLESKY_TMPL_H#include "cholesky.h"#include "matrix.h"#include "matrix-exceptions.h"#include "matrix-ops.h"#include "cf-debug.h"namespace cf_algebra {template<class A, class X, class B>void cholesky_solver<A,X,B>::solve(const A_t&, x_t&, const b_t&){	FAILTRUE(true);}template<class A, class X, class B>void cholesky_solver<A,X,B>::decompose(A_t &a, x_t &p)	// Numerical Recipes version, choldc, p. 97.{	const size_t n = this->problem_size();		AC_PRECONDITION(n == a.height())	AC_PRECONDITION(p.height() == n)	// i==0, j==0	scalar_t sum00 = a(zero,zero);	if (sum00 <= 0.) {		if (sum00 > -1.0e-16)			sum00 = (scalar_t) 0.0;		else			throw matrix_not_positive_definite("cholesky_decompose");	}	const scalar_t p00 = sqrt(sum00);	p(zero,zero) = p00;		// i==0, j==1:n	for (int j=1; j<n; j++) {		scalar_t sum0j = a(zero,j);		a(j,zero) = sum0j / p00;	}		// i==1:n, j==1:n	for (int i=1; i<n; i++) {		for (int j=i; j<n; j++) {			scalar_t sum = a(i,j);			typename A::row_it_t i_row = a.row_it(i),						j_row = a.row_it(j);			for (int k=0; k<i; k++) {			// sum -= a(i,0:i-1) * a(j,0:i-1)				sum -= (*i_row) * (*j_row);				++i_row; ++j_row;			}			if (i==j) {				if (sum <= 0.0) {					if (sum > -1.0e-16)	// close enough to zero						p(i,zero) = (scalar_t) 0.0;					else						throw matrix_not_positive_definite("cholesky_decompose");				} else					p(i,zero) = sqrt(sum);			} else				a(j,i) = sum / p(i,zero);		}	}}template<class A, class X, class B>void cholesky_solver<A,X,B>::invert(A_t &m_inv, A_t &m){	const size_t n = this->problem_size();		AC_PRECONDITION(m.extent().is_square())	AC_PRECONDITION(m_inv.extent() == m.extent())	// compute L such that L LT = M 	// (L a lower triangular)	x_t p(n,one);	this->decompose(m,p);		// now compute Linv (also lower triangular)	for (int i=0; i<n; i++) {		m(i,i) = ((scalar_t)1.0) / p(i,zero);		for (int j=(index_t)(i+1); j<n; j++) {			scalar_t dot = (scalar_t) 0.0;			for (int k=i; k<j; k++)				dot -= m(j,k) * m(k,i);			m(j,i) = dot / p(j,zero);		}	}		// Now compute Minv <- LinvT Linv	matrix_multiply_upper_lower(m_inv, m.transpose(), m);}} /* namespace cf_algebra */#endif /* __CHOLESKY_TMPL_H */	