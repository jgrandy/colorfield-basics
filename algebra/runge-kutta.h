/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __RUNGE_KUTTA_H#define __RUNGE_KUTTA_H#include "nonlinear-solver.h"namespace cf_algebra {template<class Q>class rk4_solver : public nonlinear_solver<Q> {public:					// Types			typedef rk4_solver<Q>			this_t;			typedef nonlinear_solver<Q>		base_t;			typedef typename base_t::function_t		function_t;			typedef typename base_t::time_t			time_t;			typedef typename base_t::q_t				q_t;			typedef typename base_t::qdot_t			qdot_t;					// Constructors					explicit						rk4_solver(function_t &f) 									: base_t(f),									  temp_q_vector(NULL), temp_qdot1_vector(NULL), temp_qdot2_vector(NULL)									  {};virtual							~rk4_solver(void);													// Simulation Statevirtual		void				set_state(const time_t &t, const q_t &q, const qdot_t &qdot);					// Steppingvirtual		time_t				step(void);private:				// cached working space					mutable q_t				   *temp_q_vector;	mutable qdot_t			   *temp_qdot1_vector,							   *temp_qdot2_vector;};template<class Q>class adaptive_rk4_solver : public nonlinear_solver<Q> {public:					// Types						typedef adaptive_rk4_solver<Q> this_t;			typedef nonlinear_solver<Q>	base_t;			typedef typename base_t::function_t		function_t;			typedef typename base_t::time_t			time_t;			typedef typename base_t::q_t				q_t;			typedef typename base_t::qdot_t			qdot_t;					// Exceptions						class step_size_too_small : public std::logic_error {				public:				         step_size_too_small(void) : std::logic_error("step size too small in adaptive RK4") {}				explicit step_size_too_small(const std::string& what_arg) : std::logic_error(what_arg) {}			};			class too_many_steps : public std::logic_error {				public:				         too_many_steps(void) : std::logic_error("too many steps in adaptive RK4") {}				explicit too_many_steps(const std::string& what_arg) : std::logic_error(what_arg) {}			};					// Constructorsexplicit						adaptive_rk4_solver(function_t &f) 									: base_t(f),									  eps_((time_t)1.0e-5), min_step_((time_t)0.0),									  temp_q_vector1(NULL), temp_q_vector2(NULL), temp_q_vector3(NULL), 									  temp_qdot_vector(NULL),									  q_error_vector(NULL),									  ak2_vector(NULL), ak3_vector(NULL), ak4_vector(NULL), ak5_vector(NULL), ak6_vector(NULL)									  {};virtual							~adaptive_rk4_solver(void);													// Operational Parameters								void				set_epsilon(const time_t &e)						{ eps_ = e; }			time_t &			get_epsilon(void)									{ return eps_; }						void				set_min_step(const time_t &mstep)					{ min_step_ = mstep; }			time_t &			get_min_step(void)									{ return min_step_; }					// Simulation Statevirtual		void				set_state(const time_t &t, const q_t &q, const qdot_t &qdot);					// Steppingvirtual		time_t				step(void);private:					// Cache Management								void				flush_caches(void) const;								// Stepping			time_t				step_once(      q_t &new_q, time_t &next_stepsize, 										  const time_t t, const time_t stepsize,										  const q_t &q, const qdot_t &qdot,										  const q_t &q_scale);			void				static_rk5_step(      q_t &new_q,									 			const time_t t, const time_t stepsize, 									 			const q_t &q, const qdot_t &qdot, q_t &q_error);			time_t				eps_, min_step_;						// -> for step	mutable q_t				   *temp_q_vector1, *temp_q_vector2, *temp_q_vector3;	mutable qdot_t			   *temp_qdot_vector;					// -> for step_once	mutable q_t				   *q_error_vector;							// -> for static_rk5_step			mutable qdot_t			   *ak2_vector, *ak3_vector, *ak4_vector, *ak5_vector, *ak6_vector;	};} /* namespace cf_algebra */#endif /* __RUNGE_KUTTA_H */