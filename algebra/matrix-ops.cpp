/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#pragma inline_depth(12)#include "matrix.h"#include "matrix-inst.h"#include "matrix-ops.h"#include "matrix-ops-tmpl.h"namespace cf_algebra {template matrixn&  copy(matrixn&, const matrixn&);template cvector&  copy(cvector&, const cvector&);template cvector&  copy(cvector&, const cvector3&);template cvector3& copy(cvector3&, const cvector3&);template matrixn&  fill(matrixn&, const scalar_t&);template cvector&  fill(cvector&, const scalar_t&);template bool operator== (const matrixn&, const scalar_t&);template bool operator== (const cvector&, const scalar_t&);template bool operator== (const cvector&, const cvector&);template bool operator!= (const cvector3&, const scalar_t&);template bool operator!= (const cvector&, const cvector&);template scalar_t norm_maxabs(const matrixn&);template scalar_t norm_maxabs(const cvector&);template scalar_t norm_p2(const cvector&);template cvector& operator+=(cvector&, const cvector&);template cvector& operator-=(cvector&, const cvector&);template cvector& operator*=(cvector&, const scalar_t&);template cvector& operator*=(cvector&, const cvector&);template matrixn& set_diagonal(matrixn&, const scalar_t&);template cvector& matrix_multiply(cvector &y, const matrixn_T &a, const cvector &x);template matrixn& matrix_multiply(matrixn &C, const matrixn &A, const matrixn &B);template matrixn& matrix_multiply(matrixn &C, const matrixn &A, const matrixn_T &B);template cvector& matrix_multiply(cvector &y, const matrixn &a, const cvector &x);template scalar_t& matrix_multiply(scalar_t &a, const cvector_T &x, const cvector &y);template matrixn& matrix_multiply_upper_lower(matrixn &c, const matrixn_T &a, const matrixn &b);template cvector& axpy(const scalar_t &a, const cvector &x, const scalar_t &b, cvector &y);template rvector& axpy(const scalar_t &a, const matrixn &x, const scalar_t &b, rvector &y);template matrixn& axpy(const scalar_t &a, const matrixn &x, const scalar_t &b, const matrixn &y, const scalar_t &c, matrixn &z);template rvector& axpy(const scalar_t &a, const rvector &x, const scalar_t &b, const rvector &y, const scalar_t &c, rvector &z);template cvector& axpy(const scalar_t &a, const cvector &x, const scalar_t &b, const cvector &y, const scalar_t &c, cvector &z);template matrixn& axpy(const scalar_t &a, const matrixn_T &A, const matrixn &x, const scalar_t &b, matrixn &y);template matrixn& axpy(const scalar_t &a, const matrixn &A, const matrixn &x, const scalar_t &b, matrixn &y);template cvector& axpy(const scalar_t &a, const matrixn_T &A, const cvector &x, const scalar_t &b, cvector &y);template cvector& axpy(const scalar_t &a, const matrixn &A, const cvector &x, const scalar_t &b, cvector &y);} // namespace cf_algebra