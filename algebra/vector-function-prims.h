/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __VECTOR_FUNCTION_PRIMS_H#define __VECTOR_FUNCTION_PRIMS_H#include "algebra-core.h"#include "matrix.h"#include "matrix-inst.h"#include "matrix-ops.h"#include "cf-debug.h"#include <iostream>#include <list>namespace cf_algebra {/*1.				2.					3.														4.*/		// forward declarations (defined in vector-function.h)class vector_function;class proxy_vf;class identity_vf {public:		typedef identity_vf			this_t;		typedef index_t				result_size_t;												identity_vf(void)										{}template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const		{ axpy(a, q, scalar1, r); }template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &) const	{ add_diagonal(dfdq, a); }template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const																								{ axpy(a, q, scalar1, r); add_diagonal(dfdq, a); }template<class q_size_t>		  const result_size_t		result_size(const q_size_t &q_size) const				{ return q_size; }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &)			{ return (os << 'q'); }};template<class K> class constant_vf {};template<class E, class S> class constant_vf<matrix<E,S> > {		typedef matrix<E,S>			matrix_t;				matrix_t	 		result_;			public:		typedef constant_vf<matrix_t> this_t;		typedef typename matrix_t::height_t	result_size_t;												constant_vf(const matrix_t &r)							: result_(r.extent()) { result_ = r; }									constant_vf(const this_t &k)							: result_(k.result_.extent()) { result_ = k.result_; }				this_t&				operator= (const this_t &k)								{ result_ = k.result_; return *this; }			template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q & ) const		{ axpy(a, result_, scalar1, r); }template<class Q, class DR> 				void				derive(DR &, const scalar_t &, const Q &) const		{}template<class Q, class R, class DR>				void				apply_derive(R &r, DR &, const scalar_t &a, const Q &) const																								{ axpy(a, result_, scalar1, r); }template<class q_size_t>		  const result_size_t		result_size(const q_size_t &) const						{ return result_.height(); }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &vf)			{ return (os << vf.result_); }};template<> class constant_vf<float> {				float				result_;			public:		typedef constant_vf<float>	this_t;		typedef one_t				result_size_t;											constant_vf(const float &r)								: result_(r) {}									constant_vf(const this_t &k)							: result_(k.result_) {}				this_t&				operator= (const this_t &k)								{ result_ = k.result_; return *this; }			template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q & ) const		{ r(zero,zero) = a * result_; }template<class Q, class DR> 				void				derive(DR &, const scalar_t &, const Q &) const		{}template<class Q, class R, class DR>				void				apply_derive(R &r, DR &, const scalar_t &a, const Q &) const																							{ r(zero,zero) = a * result_; }template<class q_size_t>		  const result_size_t		result_size(const q_size_t &) const						{ return one; }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &vf)			{ return (os << vf.result_); }};template<> class constant_vf<double> {				double				result_;			public:		typedef constant_vf<double>	this_t;		typedef one_t				result_size_t;												constant_vf(const double &r)							: result_(r) {}									constant_vf(const this_t &k)							: result_(k.result_) {}				this_t&				operator= (const this_t &k)								{ result_ = k.result_; return *this; }			template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q & ) const		{ r(zero,zero) = a * result_; }template<class Q, class DR> 				void				derive(DR &, const scalar_t &, const Q &) const		{}template<class Q, class R, class DR>				void				apply_derive(R &r, DR &, const scalar_t &a, const Q &) const																							{ r(zero,zero) = a * result_; }template<class q_size_t>		  const result_size_t		result_size(const q_size_t &) const						{ return one; }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &vf)			{ return (os << vf.result_); }};template<class Range = range_t<> > class range_vf {				Range				range_;			public:		typedef range_vf<Range>		this_t;		typedef Range				range_t;		typedef typename range_t::length_t	result_size_t;												range_vf(const range_t &r)								: range_(r) {}								template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const		{																							  AC_PRECONDITION(range_.length() == r.height()); 																							  axpy(a, q.rows(range_), scalar1, r); }template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &) const	{																							  AC_PRECONDITION(range_.length() == dfdq.height()); 																							  typename matrix_traits<DR,range_t>::cols_t dc(dfdq,range_,column_axis);																							  set_diagonal(dc, a);																							}template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const																							{																							  AC_PRECONDITION(range_.length() == r.height()); 																							  axpy(a, q.rows(range_), scalar1, r); 																							  AC_PRECONDITION(range_.length() == dfdq.height()); 																							  typename matrix_traits<DR,range_t>::cols_t dc(dfdq,range_,column_axis);																							  set_diagonal(dc, a);																							}template<class q_size_t>		  const result_size_t		result_size(const q_size_t &) const						{ return range_.length(); }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &vf)			{ return (os << vf.range_); }};template<class Reordering> class pickn_vf;template<> class pickn_vf<one_t> {public:		typedef pickn_vf<one_t>		this_t;		typedef one_t				result_size_t;									pickn_vf(index_t x)										: x_(x) {}									pickn_vf(const this_t& p)								: x_(p.x_) {}													this_t&				operator= (const this_t &p)								{ x_ = p.x_; return *this; }									template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const		{																							  AC_PRECONDITION(r.height() == one);																							  r[zero] += a * q[x_];																							}template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &) const	{																							  AC_PRECONDITION(dfdq.height() == one);																							  dfdq(zero,x_) += a;																							}template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const																							{																							  AC_PRECONDITION(r.height() == one); 																							  r[zero] += a * q[x_];																							  AC_PRECONDITION(dfdq.height() == one); 																							  dfdq(zero,x_) += a;																							}template<class q_size_t>		  const result_size_t		result_size(const q_size_t &) const						{ return one; }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &)			{ return (os << "pick1"); }private:				index_t				x_;};template<> class pickn_vf<two_t> {public:		typedef pickn_vf<two_t>		this_t;		typedef two_t				result_size_t;									pickn_vf(index_t x, index_t y)							: x_(x), y_(y) {}									pickn_vf(const this_t& p)								: x_(p.x_), y_(p.y_) {}													this_t&				operator= (const this_t &p)								{ x_ = p.x_; y_ = p.y_; return *this; }									template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const		{																							  AC_PRECONDITION(r.height() == two);																							  r[zero] += a * q[x_];																							  r[one ] += a * q[y_];																							}template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &) const	{																							  AC_PRECONDITION(dfdq.height() == two);																							  dfdq(zero,x_) += a;																							  dfdq(one ,y_) += a;																							}template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const																							{																							  AC_PRECONDITION(r.height() == two); 																							  r[zero] += a * q[x_];																							  r[one ] += a * q[y_];																							  AC_PRECONDITION(dfdq.height() == two); 																							  dfdq(zero,x_) += a;																							  dfdq(one ,y_) += a;																							}template<class q_size_t>		  const result_size_t		result_size(const q_size_t &) const						{ return two; }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &)			{ return (os << "pick2"); }private:				index_t				x_, y_;};template<> class pickn_vf<three_t> {public:		typedef pickn_vf<three_t>	this_t;		typedef three_t				result_size_t;									pickn_vf(index_t x, index_t y, index_t z)				: x_(x), y_(y), z_(z) {}									pickn_vf(const this_t& p)								: x_(p.x_), y_(p.y_), z_(p.z_) {}													this_t&				operator= (const this_t &p)								{ x_ = p.x_; y_ = p.y_; z_ = p.z_; return *this; }									template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const		{																							  AC_PRECONDITION(r.height() == three);																							  r[zero] += a * q[x_];																							  r[one ] += a * q[y_];																							  r[two ] += a * q[z_];																							}template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &) const	{																							  AC_PRECONDITION(dfdq.height() == three);																							  dfdq(zero,x_) += a;																							  dfdq(one ,y_) += a;																							  dfdq(two ,z_) += a;																							}template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const																							{																							  AC_PRECONDITION(r.height() == three); 																							  r[zero] += a * q[x_];																							  r[one ] += a * q[y_];																							  r[two ] += a * q[z_];																							  AC_PRECONDITION(dfdq.height() == three); 																							  dfdq(zero,x_) += a;																							  dfdq(one ,y_) += a;																							  dfdq(two ,z_) += a;																							}template<class q_size_t>		  const result_size_t		result_size(const q_size_t &) const						{ return three; }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &)			{ return (os << "pick3"); }private:				index_t				x_, y_, z_;};template<> class pickn_vf<four_t> {public:		typedef pickn_vf<four_t>	this_t;		typedef four_t				result_size_t;									pickn_vf(index_t x, index_t y, index_t z, index_t w)	: x_(x), y_(y), z_(z), w_(w) {}									pickn_vf(const this_t& p)								: x_(p.x_), y_(p.y_), z_(p.z_), w_(p.w_) {}													this_t&				operator= (const this_t &p)								{ x_ = p.x_; y_ = p.y_; z_ = p.z_; w_ = p.w_; return *this; }									template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const		{																							  AC_PRECONDITION(r.height() == four);																							  r[zero] += a * q[x_];																							  r[one ] += a * q[y_];																							  r[two ] += a * q[z_];																							  r[three] += a * q[w_];																							}template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &) const	{																							  AC_PRECONDITION(dfdq.height() == four);																							  dfdq(zero,x_) += a;																							  dfdq(one ,y_) += a;																							  dfdq(two ,z_) += a;																							  dfdq(three,w_) += a;																							}template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const																							{																							  AC_PRECONDITION(r.height() == four); 																							  r[zero] += a * q[x_];																							  r[one ] += a * q[y_];																							  r[two ] += a * q[z_];																							  r[three] += a * q[w_];																							  AC_PRECONDITION(dfdq.height() == four); 																							  dfdq(zero,x_) += a;																							  dfdq(one ,y_) += a;																							  dfdq(two ,z_) += a;																							  dfdq(three,w_) += a;																							}template<class q_size_t>		  const result_size_t		result_size(const q_size_t &) const						{ return four; }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &)			{ return (os << "pick4"); }private:				index_t				x_, y_, z_, w_;};template<index_t X> class pickn_vf<reordering<1,X> > {public:		typedef pickn_vf<reordering<1,X> >		this_t;		typedef one_t				result_size_t;			template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const		{																							  AC_PRECONDITION(r.height() == one);																							  r[zero] += a * q[X];																							}template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &) const	{																							  AC_PRECONDITION(dfdq.height() == one);																							  dfdq(zero,X) += a;																							}template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const																							{																							  AC_PRECONDITION(r.height() == one); 																							  r[zero] += a * q[X];																							  AC_PRECONDITION(dfdq.height() == one); 																							  dfdq(zero,X) += a;																							}template<class q_size_t>		  const result_size_t		result_size(const q_size_t &) const						{ return one; }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &)			{ return (os << "pick1"); }}; template<index_t X, index_t Y> class pickn_vf<reordering<2,X,Y> > {public:		typedef pickn_vf<reordering<2,X,Y> >		this_t;		typedef two_t				result_size_t;			template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const		{																							  AC_PRECONDITION(r.height() == two);																							  r[zero] += a * q[X];																							  r[one ] += a * q[Y];																							}template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &) const	{																							  AC_PRECONDITION(dfdq.height() == two);																							  dfdq(zero,X) += a;																							  dfdq(one ,Y) += a;																							}template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const																							{																							  AC_PRECONDITION(r.height() == two); 																							  r[zero] += a * q[X];																							  r[one ] += a * q[Y];																							  AC_PRECONDITION(dfdq.height() == two); 																							  dfdq(zero,X) += a;																							  dfdq(one ,Y) += a;																							}template<class q_size_t>		  const result_size_t		result_size(const q_size_t &) const						{ return two; }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &)			{ return (os << "pick2"); }}; template<index_t X, index_t Y, index_t Z> class pickn_vf<reordering<3,X,Y,Z> > {public:		typedef pickn_vf<reordering<3,X,Y,Z> >	this_t;		typedef three_t				result_size_t;			template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const		{																							  AC_PRECONDITION(r.height() == two);																							  r[zero] += a * q[X];																							  r[one ] += a * q[Y];																							  r[two ] += a * q[Z];																							}template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &) const	{																							  AC_PRECONDITION(dfdq.height() == two);																							  dfdq(zero,X) += a;																							  dfdq(one ,Y) += a;																							  dfdq(two ,Z) += a;																							}template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const																							{																							  AC_PRECONDITION(r.height() == two); 																							  r[zero] += a * q[X];																							  r[one ] += a * q[Y];																							  r[two ] += a * q[Z];																							  AC_PRECONDITION(dfdq.height() == two); 																							  dfdq(zero,X) += a;																							  dfdq(one ,Y) += a;																							  dfdq(two ,Z) += a;																							}template<class q_size_t>		  const result_size_t		result_size(const q_size_t &) const						{ return three; }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &vf)			{ return (os << "pick3"); }};template<class F, class G> class composite_vf {	// F o G  or  F(G(q))				F					f_;				G					g_;public:		typedef composite_vf<F,G>	this_t;		typedef typename F::result_size_t	result_size_t;											composite_vf(const F &f, const G &g)						: f_(f), g_(g) {}								composite_vf(const this_t& vf)								: f_(vf.f_), g_(vf.g_) {}												this_t&			operator= (const this_t &vf)								{ f_ = vf.f_; g_ = vf.g_; return *this; }template<class Q, class R>				void			apply(R &r, const scalar_t &a, const Q &q) const;template<class Q, class DR> 				void			derive(DR &dfdq, const scalar_t &a, const Q &q) const;template<class Q, class R, class DR>				void			apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const;template<index_t N>		  const result_size_t	result_size(const cindex<N> &n) const						{ return f_.result_size(g_.result_size(n)); }		  const result_size_t	result_size(const index_t &n) const							{ return f_.result_size(g_.result_size(n)); }			friend			std::ostream&	operator<<(std::ostream &os, const this_t &vf)				{ return (os << '(' << vf.f_ << ") o (" << vf.g_ << ')'); }};template<class F, class T, class G> class sum_vf {	// F(q) + a * G(q)				F					f_;				T					a_;				G					g_;public:		typedef sum_vf<F,T,G>		this_t;		typedef typename F::result_size_t	result_size_t;												sum_vf(const F &f, const T &a, const G &g)				: f_(f), a_(a), g_(g) {}									sum_vf(const this_t& vf)								: f_(vf.f_), a_(vf.a_), g_(vf.g_) {}				this_t&				operator= (const this_t &vf)							{ f_ = vf.f_; a_ = vf.a_; g_ = vf.g_; return *this; }template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const;		template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &q) const;template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const;template<class q_size_t>		  const result_size_t		result_size(const q_size_t &q_size) const				{ return f_.result_size(q_size); }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &vf)			{ return (os << '(' << vf.f_ << ") + " << vf.a_ << "*(" << vf.g_ << ')'); }};template<class F, class G> class dot_vf {	// F(q) dot G(q)				F					f_;				G					g_;public:		typedef dot_vf<F,G>			this_t;		typedef one_t				result_size_t;												dot_vf(const F &f, const G &g)							: f_(f), g_(g) {}									dot_vf(const this_t& vf)								: f_(vf.f_), g_(vf.g_) {}				this_t&				operator= (const this_t &vf)							{ f_ = vf.f_; g_ = vf.g_; return *this; }template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const;		template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &q) const;template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const;template<class q_size_t>		  const result_size_t		result_size(const q_size_t &) const						{ return one; }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &vf)			{ return (os << '(' << vf.f_ << ") dot (" << vf.g_ << ')'); }};template<class T, class F> class scaled_vf {				T					scale_;				F					f_;			public:		typedef scaled_vf<T,F>		this_t;		typedef index_t				result_size_t;												scaled_vf(const F &f, const T &s)						: f_(f), scale_(s) {}									scaled_vf(const this_t& vf)								: f_(vf.f_), scale_(vf.scale_) {}												this_t&				operator= (const this_t &vf)							{ scale_ = vf.scale_; f_ = vf.f_; return *this; }			template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const;template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &q) const;template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const;template<class q_size_t>		  const result_size_t		result_size(const q_size_t &q_size) const				{ return q_size; }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &vf)			{ return (os << '*' << vf.scale_); }};class normp2_vf {public:		typedef normp2_vf			this_t;		typedef one_t				result_size_t;			template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const		{																							  AC_PRECONDITION(r.height() == one);																							  r[zero] += a * norm_p2(q);																							}template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &q) const																							{                                                                                                AC_PRECONDITION(dfdq.height() == one);																							  const typename Q::height_t q_height = q.height();																							  for (int i=0; i<q_height; i++)																							  	dfdq(zero,i) += scalar2 * a * q[i];																							}template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const																							{                                                                                                AC_PRECONDITION(r.height() == one);																							  r[zero] += a * norm_p2(q);                                                                                                AC_PRECONDITION(dfdq.height() == one);																							  const typename Q::height_t q_height = q.height();																							  for (int i=0; i<q_height; i++)																							  	dfdq(zero,i) += scalar2 * a * q[i];																							}template<class q_size_t>		  const one_t				result_size(const q_size_t &) const						{ return one; }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &)			{ return (os << "norm_p2"); }};template<index_t N> class map_vf {public:		typedef map_vf<N>						this_t;		typedef cindex<N>						result_size_t;		typedef typename small_matrices<N,N>::matrixn	map_t;												map_vf(const map_t &map)								: map_(cindex<N>(),cindex<N>()) { map_ = map; }template<class E, class S>			map_vf(const matrix<E,S> &map)							: map_(cindex<N>(),cindex<N>()) { map_ = map; }									map_vf(const this_t& vf)								: map_(cindex<N>(),cindex<N>()) { map_ = vf.map_; }												this_t&				operator= (const this_t &vf)							{ map_ = vf.map_; return *this; }			template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const;template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &q) const;template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const;		  const result_size_t		result_size(const index_t &q_size) const				{ return N; }		  const result_size_t		result_size(const cindex<N> &q_size) const				{ return N; }			friend			std::ostream&		operator<<(std::ostream &os, const this_t &vf)			{ return (os << "map(" << vf.map_ << ')' ); }private:				map_t				map_;};template<class T> class wrapped_vf {		  const T					bound_, hbound_;	 public:		typedef wrapped_vf<T>		this_t;		typedef one_t				result_size_t;												wrapped_vf(const T &bound)								: bound_(bound), hbound_(bound / (T) 2) {}template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const;template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &q) const;template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const;template<class q_size_t>		  const result_size_t		result_size(const q_size_t &q_size) const;			friend			std::ostream&		operator<<(std::ostream &os, const this_t &wf)			{ return (os << "wrapped(" << wf.bound_ << ')'); }};template<class F> class stacked_vf {		typedef std::list<const F*>	functions_t;				functions_t			functions_;public:		typedef stacked_vf<F>		this_t;		typedef index_t				result_size_t;												stacked_vf(void)										: functions_() {}									stacked_vf(const F* f1)									: functions_() { this->add(f1); }									stacked_vf(const F* f1, const F* f2)					: functions_() { this->add(f1); this->add(f2); }									stacked_vf(const this_t& vf)							: functions_(vf.functions_) {}												this_t &			operator= (const this_t &vf)							{ functions_ = vf.functions_; return *this; }															void				add(const F* f);				void				remove(const F* f);				bool				find(const F* f) const									{ return (std::find(functions_.begin(),functions_.end(),f) != functions_.end()); }			template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const;template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &q) const;template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const;template<class q_size_t>		  const result_size_t		result_size(const q_size_t &q_size) const;			friend			std::ostream&		operator<<(std::ostream &os, const this_t &)			{ return (os << "stacked"); }};template<class VF> class vf_wrapper {				VF					f_;			public:		typedef VF					vf_t;		typedef vf_wrapper<vf_t>	this_t;		typedef typename vf_t::result_size_t	result_size_t;												vf_wrapper(const vf_t &f)								: f_(f) {}									vf_wrapper(const this_t& vf)							: f_(vf.f_) {}												this_t&				operator= (const this_t& vf)							{ f_ = vf.f_; return *this; }												operator const vf_t& (void) const						{ return f_; }							// Function Evaluation				template<class Q, class R>				void				apply(R &r, const scalar_t &a, const Q &q) const		{ f_.apply(r,a,q); }template<class Q, class DR> 				void				derive(DR &dfdq, const scalar_t &a, const Q &q) const																							{ f_.derive(dfdq,a,q); }template<class Q, class R, class DR>				void				apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const																							{ f_.apply_derive(r,dfdq,a,q); }			template<class q_size_t>		  const result_size_t		result_size(const q_size_t &q_size) const				{ return f_.result_size(q_size); }							// I/O				friend			std::ostream&		operator<<(std::ostream &os, const this_t &vf)			{ return (os << vf.f_); }				// Operators				template<class G>	vf_wrapper<composite_vf<vf_t,G> > operator()(const vf_wrapper<G> &g) const				{ return composite_vf<vf_t,G>(f_,(const G&)g); }vf_wrapper<composite_vf<vf_t,proxy_vf> > operator()(const vector_function *g) const; //			{ return adapt_vf(composite_vf<vf_t,proxy_vf>(f_,adapt_vfp(g))); }};// ADAPT_VFtemplate<class VF> inline vf_wrapper<VF> adapt_vf(const vf_wrapper<VF> &f){ return f; }template<class E, class S>inline vf_wrapper<constant_vf<matrix<E,S> > > adapt_vf(const matrix<E,S> &m){ return vf_wrapper<constant_vf<matrix<E,S> > >(constant_vf<matrix<E,S> >(m)); }inline vf_wrapper<constant_vf<float> > adapt_vf(const float &k) { return vf_wrapper<constant_vf<float> >(constant_vf<float>(k)); }inline vf_wrapper<constant_vf<double> > adapt_vf(const double &k) { return vf_wrapper<constant_vf<double> >(constant_vf<double>(k)); }template<class VF> inline vf_wrapper<VF> adapt_vf(const VF &f){ return vf_wrapper<VF>(f); }template<class F, class G>inline vf_wrapper<sum_vf<F,double,G> > operator+ (const vf_wrapper<F> &f, const vf_wrapper<G> &g)				{ return adapt_vf(sum_vf<F,double,G>((const F&) f, +1.0, (const G&) g)); }template<class F, class G>inline vf_wrapper<sum_vf<F,double,G> > operator- (const vf_wrapper<F> &f, const vf_wrapper<G> &g){ return adapt_vf(sum_vf<F,double,G>((const F&) f, -1.0, (const G&) g)); }template<class F>inline vf_wrapper<scaled_vf<double,F> > operator- (const vf_wrapper<F> &f){ return adapt_vf(scaled_vf<double,F>((const F&) f, -1.0)); }template<class F>inline vf_wrapper<scaled_vf<float,F> > operator* (const vf_wrapper<F> &f, const float &v){ return adapt_vf(scaled_vf<float,F>((const F&) f, v)); }template<class F>inline vf_wrapper<scaled_vf<double,F> > operator* (const vf_wrapper<F> &f, const double &v){ return adapt_vf(scaled_vf<double,F>((const F&) f, v)); }#if 0template<class F, class RS, class RL>inline vf_wrapper<composite_vf<range_vf<range_t<RS,RL> >, F> > operator[](const vf_wrapper<F> &f, const range_t<RS,RL> &r){ return adapt_vf(composite_vf<range_vf<range_t<RS,RL> >, F>(range_vf<range_t<RS,RL> >(r), (const F&) f)); }#endif    template<class R, class F>inline vf_wrapper<composite_vf<pickn_vf<R>, F> > pickn(const vf_wrapper<F> &f){ return adapt_vf(composite_vf<pickn_vf<R>, F>(pickn_vf<R>(), (const F&) f)); }template<index_t X, class F>inline vf_wrapper<composite_vf<pickn_vf<reordering<1,X> >, F> > pick1(const vf_wrapper<F> &f){ return adapt_vf(composite_vf<pickn_vf<reordering<1,X> >, F>(pickn_vf<reordering<1,X> >(), (const F&) f)); }template<index_t X, index_t Y, class F>inline vf_wrapper<composite_vf<pickn_vf<reordering<2,X,Y> >, F> > pick2(const vf_wrapper<F> &f){ return adapt_vf(composite_vf<pickn_vf<reordering<2,X,Y> >, F>(pickn_vf<reordering<2,X,Y> >(), (const F&) f)); }template<index_t X, index_t Y, index_t Z, class F>inline vf_wrapper<composite_vf<pickn_vf<reordering<3,X,Y,Z> >, F> > pick3(const vf_wrapper<F> &f){ return adapt_vf(composite_vf<pickn_vf<reordering<3,X,Y,Z> >, F>(pickn_vf<reordering<3,X,Y,Z> >(), (const F&) f)); }} // cf_algebra#endif /* __VECTOR_FUNCTION_PRIMS_H */