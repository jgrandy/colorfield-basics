/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __MATRIX_H#define __MATRIX_H#include "algebra-core.h"#include "index.h"#include "coord.h"#include "range.h"#include "block.h"namespace cf_algebra {/*1.				2.					3.									4.*/	typedef one_t row_axis_t;	typedef two_t column_axis_t;		const row_axis_t row_axis = one;	const column_axis_t column_axis = two;template<class m, class x> class matrix_traits;template<class Extent, class Structure> class matrix;template<class Extent, class Structure> class base_matrix {public:						// Base Types		typedef Extent													extent_t;		typedef typename extent_t::height_t										height_t;		typedef typename extent_t::width_t										width_t;		typedef Structure												structure_t;		typedef base_matrix<extent_t,structure_t>						this_t;								// Derived Types		typedef matrix<extent_t,structure_t>							matrix_t;		typedef matrix<typename extent_t::transpose_t,typename structure_t::transpose_t>	transpose_t;		typedef matrix<coord_t<one_t,width_t>,  typename structure_t::alias_t>	row_t;		typedef matrix<coord_t<height_t,one_t>, typename structure_t::alias_t>	col_t;		typedef matrix<coord_t<index_t, width_t >, typename structure_t::alias_t> rows_t;		typedef matrix<coord_t<height_t, index_t>, typename structure_t::alias_t> cols_t;		typedef matrix<extent_t,typename structure_factory<structure_t,extent_t>::structure_t>	copy_t;		typedef matrix_init_type										init_type_t;						// Basic Constructors									base_matrix(extent_t e, init_type_t fill = init_none)																		: extent_(e), structure_(e,fill) {}																		template<class S2>					base_matrix(extent_t e, const S2 &s)																									: extent_(e), structure_(s) {}																		template<class S2, class R2, class C2>									base_matrix(height_t h, width_t w, const S2 &s, R2 r, C2 c)		// aliasing constructor																		: extent_(h,w), structure_(s, r, c) {}																											base_matrix(extent_t e, scalar_t *data)							// aliasing constructor																									: extent_(e),																		  structure_(data,e)																		{}									base_matrix(extent_t e, const scalar_t *data)					// aliasing constructor																		: extent_(e),																		  structure_(const_cast<scalar_t*>(data),e)																		{}						// Accessors							  const extent_t			extent(void) const					{ return extent_; }		  const height_t			height(void) const					{ return extent_.row(); }		  const width_t				width(void) const					{ return extent_.column(); }				structure_t&		structure(void)						{ return structure_; }		  const structure_t&		structure(void) const				{ return structure_; }template<class R2, class C2>				scalar_t &			operator()(const R2 &r, const C2 &c) { return structure_(r,c); }template<class R2, class C2>		  const scalar_t			operator()(const R2 &r, const C2 &c) const		  																{ return structure_(r,c); }template<class R2, class C2>				scalar_t &			operator[](const coord_t<R2,C2> &c)	{ return structure_(c.row(), c.column()); }template<class R2, class C2>		  const scalar_t			operator[](const coord_t<R2,C2> &c) const		  																{ return structure_(c.row(), c.column()); }				this_t&				resize(extent_t e)					{ structure_.resize(e); extent_ = e; return *this; }								transpose_t			transpose(void) const				{ return transpose_t(extent().transpose(),typename structure_t::transpose_t(structure_)); }									row_t				row(const index_t &r)				{ return row_t(*this, r, row_axis); }		  const row_t				row(const index_t &r) const			{ return row_t(*this, r, row_axis); }template<index_t N>				row_t				row(const cindex<N> &r)				{ return row_t(*this, r, row_axis); }template<index_t N>		  const row_t				row(const cindex<N> &r) const		{ return row_t(*this, r, row_axis); }			    col_t				column(const index_t &c)			{ return col_t(*this, c, column_axis); }	 	  const col_t				column(const index_t &c) const		{ return col_t(*this, c, column_axis); }template<index_t N>				col_t				column(const cindex<N> &c)			{ return col_t(*this, c, column_axis); }template<index_t N>		  const col_t				column(const cindex<N> &c) const	{ return col_t(*this, c, column_axis); }template<class S, class L>       typename matrix_traits<matrix_t,range_t<S,L> >::rows_t       								rows(const range_t<S,L> &rr)		{      																	  typedef typename matrix_traits<matrix_t,range_t<S,L> >::rows_t rows_t;      																	  return rows_t(*this, rr, row_axis);       																	}template<class S, class L>const typename matrix_traits<matrix_t,range_t<S,L> >::rows_t 									rows(const range_t<S,L> &rr) const	{      																	  typedef typename matrix_traits<matrix_t,range_t<S,L> >::rows_t rows_t;      																	  return rows_t(*this, rr, row_axis);       																	}	template<class S, class L>       typename matrix_traits<matrix_t,range_t<S,L> >::cols_t       								columns(const range_t<S,L> &cr)		{																		  typedef typename matrix_traits<matrix_t,range_t<S,L> >::cols_t cols_t;																		  return cols_t(*this, cr, column_axis);																		}	template<class S, class L> const typename matrix_traits<matrix_t,range_t<S,L> >::cols_t									columns(const range_t<S,L> &cr) const {																		  typedef typename matrix_traits<matrix_t,range_t<S,L> >::cols_t cols_t;																		  return cols_t(*this, cr, column_axis);																		}							// Iterators							typedef typename structure_t::row_it_t	 row_it_t;		typedef typename structure_t::crow_it_t	crow_it_t;		typedef typename structure_t::col_it_t	 col_it_t;		typedef typename structure_t::ccol_it_t	ccol_it_t;					template<class R>  row_it_t			row_it(R r)							{ return structure_.row_it(r,zero); }template<class R> crow_it_t			row_it(R r) const					{ return structure_.row_it(r,zero); }template<class C2>  col_it_t		col_it(C2 c)						{ return structure_.col_it(zero,c); }template<class C2> ccol_it_t		col_it(C2 c) const					{ return structure_.col_it(zero,c); }private:									base_matrix(const this_t &m);				this_t&				operator= (const this_t &m);																						// Data Members				extent_t			extent_;				structure_t			structure_;};	// ONE-BY-ONE MATRIXtemplate<class Structure> class matrix<coord_t<one_t,one_t>, Structure> : public base_matrix<coord_t<one_t,one_t>, Structure> {	// (necessary to resolve ambiguity between two row-vector and column-vector specializations, below)public:						// Types				typedef one_t													height_t;		typedef one_t													width_t;		typedef coord_t<one_t,one_t>									extent_t;		typedef Structure												structure_t;		typedef matrix<extent_t,structure_t>							this_t;		typedef base_matrix<extent_t,structure_t>						base_t;		typedef typename base_t::transpose_t										transpose_t;		typedef typename base_t::init_type_t										init_type_t;								// Constructors												// copy constructors									matrix(const this_t &m)				: base_t(m.extent(), m.structure()) {}																									matrix(const transpose_t &mT)		: base_t(mT.extent().transpose(), mT.structure()) {}									template<class R2, class C2, class Structure2, class S, class L>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S,L> r, row_axis_t)				 														: base_t(r.length(), m.width(), m.structure(), r.start(), zero) {}template<class R2, class C2, class Structure2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, index_t i, row_axis_t)				 														: base_t(one, m.width(), m.structure(), i, zero) {}template<class R2, class C2, class Structure2, index_t K>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, cindex<K> i, row_axis_t)				 														: base_t(one, m.width(), m.structure(), i, zero) {}template<class R2, class C2, class Structure2, class S, class L>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S,L> r, column_axis_t)				 														: base_t(m.height(), r.length(), m.structure(), zero, r.start()) {}									template<class R2, class C2, class Structure2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, index_t i, column_axis_t)				 														: base_t(m.height(), one, m.structure(), zero, i) {}									template<class R2, class C2, class Structure2, index_t K>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, cindex<K> i, column_axis_t)				 														: base_t(m.height(), one, m.structure(), zero, i) {}									template<class R2, class C2, class Structure2, class S1, class L1, class S2, class L2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S1,L1> r1, range_t<S2,L2> r2)				 														: base_t(r1.length(), r2.length(), m.structure(), r1.start(), r2.start())				 														{}																			// constituent constructors									matrix(const extent_t &e, const structure_t &s)																										: base_t(e,s) {}																					// from scratch									matrix(const extent_t &e, init_type_t fill = init_none)																								: base_t(e,fill) {}									matrix(const height_t rs, const width_t cs, init_type_t fill = init_none)																			: base_t(extent_t(rs,cs), fill) {}																					// data constructors									matrix(const extent_t &e, scalar_t *data)																											: base_t(e,data) {}																											matrix(const height_t rs, const width_t cs, scalar_t *data) 																						: base_t(extent_t(rs,cs), data) {} 									matrix(const extent_t &e, const scalar_t *data)																		: base_t(e,const_cast<scalar_t*>(data)) {}									matrix(const height_t rs, const width_t cs, const scalar_t *data)																				: base_t(extent_t(rs,cs), const_cast<scalar_t*>(data)) {}																	// Predicates												// Operators				this_t&				operator= (const this_t &m)			{ return copy(*this, m); }				this_t&				operator= (const scalar_t &v)		{ return fill(*this, v); }template<class E2, class S2>				this_t&				operator= (const matrix<E2,S2> &m)	{ return copy(*this, m); }	};	// STATIC-LENGTH COLUMN VECTORtemplate<index_t R, class Structure> class matrix<coord_t<cindex<R>,one_t>, Structure> : public base_matrix<coord_t<cindex<R>,one_t>, Structure> {public:						// Types				typedef cindex<R>												height_t;		typedef one_t													width_t;		typedef coord_t<cindex<R>,one_t>								extent_t;		typedef Structure												structure_t;		typedef matrix<extent_t,structure_t>							this_t;		typedef base_matrix<extent_t,structure_t>						base_t;		typedef typename base_t::transpose_t										transpose_t;		typedef typename base_t::init_type_t										init_type_t;								// Constructors												// copy constructors									matrix(const this_t &m)				: base_t(m.extent(), m.structure()) {}																									matrix(const transpose_t &mT)		: base_t(mT.extent().transpose(), mT.structure()) {}									template<class R2, class C2, class Structure2, class S, class L>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S,L> r, row_axis_t)				 														: base_t(r.length(), m.width(), m.structure(), r.start(), zero) {}template<class R2, class C2, class Structure2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, index_t i, row_axis_t)				 														: base_t(one, m.width(), m.structure(), i, zero) {}template<class R2, class C2, class Structure2, index_t K>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, cindex<K> i, row_axis_t)				 														: base_t(one, m.width(), m.structure(), i, zero) {}template<class R2, class C2, class Structure2, class S, class L>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S,L> r, column_axis_t)				 														: base_t(m.height(), r.length(), m.structure(), zero, r.start()) {}									template<class R2, class C2, class Structure2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, index_t i, column_axis_t)				 														: base_t(m.height(), one, m.structure(), zero, i) {}									template<class R2, class C2, class Structure2, index_t K>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, cindex<K> i, column_axis_t)				 														: base_t(m.height(), one, m.structure(), zero, i) {}									template<class R2, class C2, class Structure2, class S1, class L1, class S2, class L2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S1,L1> r1, range_t<S2,L2> r2)				 														: base_t(r1.length(), r2.length(), m.structure(), r1.start(), r2.start())				 														{}																			// constituent constructors									matrix(const extent_t &e, const structure_t &s)																										: base_t(e,s) {}																					// from scratch									matrix(const extent_t &e, init_type_t fill = init_none)																								: base_t(e,fill) {}									matrix(const height_t rs, const width_t cs, init_type_t fill = init_none)																			: base_t(extent_t(rs,cs), fill) {}																					// data constructors									matrix(const extent_t &e, scalar_t *data)																											: base_t(e,data) {}																											matrix(const height_t rs, const width_t cs, scalar_t *data) 																						: base_t(extent_t(rs,cs), data) {} 									matrix(const height_t rs, scalar_t *data) 																						: base_t(extent_t(rs), data) {}									matrix(const extent_t &e, const scalar_t *data)																								: base_t(e,const_cast<scalar_t*>(data)) {}																											matrix(const height_t rs, const width_t cs, const scalar_t *data)																				: base_t(extent_t(rs,cs), const_cast<scalar_t*>(data)) {}																				matrix(const height_t rs, const scalar_t *data)																				: base_t(extent_t(rs), const_cast<scalar_t*>(data)) {}																					// specialization-specific constructors																			matrix(init_type_t fill = init_none)																								: base_t(extent_t(height_t(),one),fill) {}									matrix(scalar_t *data)				: base_t(extent_t(height_t(),one),data) {}																											matrix(const scalar_t *data)		: base_t(extent_t(height_t(),one),const_cast<scalar_t*>(data)) {}														// Predicates												// Operators				this_t&				operator= (const this_t &m)			{ return copy(*this, m); }				this_t&				operator= (const scalar_t &v)		{ return fill(*this, v); }template<class E2, class S2>				this_t&				operator= (const matrix<E2,S2> &m)	{ return copy(*this, m); }							// SPECIALIZATION-SPECIFIC OPERATORStemplate<class R2>				scalar_t &			operator[](R2 i)						{ return this->structure()(i, zero); }template<class R2>		  const scalar_t			operator[](R2 i) const				{ return this->structure()(i, zero); }template<class R2, class C2>				scalar_t &			operator()(const R2 &r, const C2 &c) { return this->structure()(r,c); }template<class R2, class C2>		  const scalar_t			operator()(const R2 &r, const C2 &c) const		  																{ return this->structure()(r,c); }template<class R2>				scalar_t &			operator()(R2 i)						{ return this->structure()(i, zero); }template<class R2>		  const scalar_t			operator()(R2 i) const				{ return this->structure()(i, zero); }};	// DYNAMIC-LENGTH COLUMN VECTORtemplate<class Structure> class matrix<coord_t<index_t,one_t>, Structure> : public base_matrix<coord_t<index_t,one_t>, Structure> {public:						// Types				typedef index_t													height_t;		typedef one_t													width_t;		typedef coord_t<index_t,one_t>									extent_t;		typedef Structure												structure_t;		typedef matrix<extent_t,structure_t>							this_t;		typedef base_matrix<extent_t,structure_t>						base_t;		typedef typename base_t::transpose_t										transpose_t;		typedef typename base_t::init_type_t										init_type_t;								// Constructors												// copy constructors									matrix(const this_t &m)				: base_t(m.extent(), m.structure()) {}																									matrix(const transpose_t &mT)		: base_t(mT.extent().transpose(), mT.structure()) {}									template<class R2, class C2, class Structure2, class S, class L>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S,L> r, row_axis_t)				 														: base_t(r.length(), m.width(), m.structure(), r.start(), zero) {}template<class R2, class C2, class Structure2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, index_t i, row_axis_t)				 														: base_t(one, m.width(), m.structure(), i, zero) {}template<class R2, class C2, class Structure2, index_t K>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, cindex<K> i, row_axis_t)				 														: base_t(one, m.width(), m.structure(), i, zero) {}template<class R2, class C2, class Structure2, class S, class L>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S,L> r, column_axis_t)				 														: base_t(m.height(), r.length(), m.structure(), zero, r.start()) {}									template<class R2, class C2, class Structure2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, index_t i, column_axis_t)				 														: base_t(m.height(), one, m.structure(), zero, i) {}									template<class R2, class C2, class Structure2, index_t K>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, cindex<K> i, column_axis_t)				 														: base_t(m.height(), one, m.structure(), zero, i) {}									template<class R2, class C2, class Structure2, class S1, class L1, class S2, class L2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S1,L1> r1, range_t<S2,L2> r2)				 														: base_t(r1.length(), r2.length(), m.structure(), r1.start(), r2.start())				 														{}																			// constituent constructors									matrix(const extent_t &e, const structure_t &s)																										: base_t(e,s) {}																					// from scratch									matrix(const extent_t &e, init_type_t fill = init_none)																								: base_t(e,fill) {}									matrix(const height_t rs, const width_t cs, init_type_t fill = init_none)																			: base_t(extent_t(rs,cs), fill) {}																					// data constructors									matrix(const extent_t &e, scalar_t *data)																											: base_t(e,data) {}																											matrix(const height_t rs, const width_t cs, scalar_t *data) 																						: base_t(extent_t(rs,cs), data) {} 									matrix(const extent_t &e, const scalar_t *data)																								: base_t(e,const_cast<scalar_t*>(data)) {}									matrix(const height_t rs, const width_t cs, const scalar_t *data)																				: base_t(extent_t(rs,cs), const_cast<scalar_t*>(data)) {}																					// specialization-specific constructors																			matrix(const height_t rs, init_type_t fill = init_none)																								: base_t(extent_t(rs,one),fill) {}									matrix(const height_t rs, scalar_t *data)																						: base_t(extent_t(rs,one),data) {}																											matrix(const height_t rs, const scalar_t *data)																			: base_t(extent_t(rs,one),const_cast<scalar_t*>(data)) {}														// Predicates												// Operators				this_t&				operator= (const this_t &m)			{ return copy(*this, m); }				this_t&				operator= (const scalar_t &v)		{ return fill(*this, v); }template<class E2, class S2>				this_t&				operator= (const matrix<E2,S2> &m)	{ return copy(*this, m); }							// SPECIALIZATION-SPECIFIC OPERATORStemplate<class R>				scalar_t &			operator[](R i)						{ return this->structure()(i, zero); }template<class R>		  const scalar_t			operator[](R i) const				{ return this->structure()(i, zero); }template<class R>				scalar_t &			operator()(R i)						{ return this->structure()(i, zero); }template<class R>		  const scalar_t			operator()(R i) const				{ return this->structure()(i, zero); }template<class R2, class C2>				scalar_t &			operator()(const R2 &r, const C2 &c) { return this->structure()(r,c); }template<class R2, class C2>		  const scalar_t			operator()(const R2 &r, const C2 &c) const		  																{ return this->structure()(r,c); }};	// STATIC-LENGTH ROW VECTORtemplate<index_t C, class Structure> class matrix<coord_t<one_t,cindex<C> >, Structure> : public base_matrix<coord_t<one_t,cindex<C> >, Structure> {public:						// Types				typedef one_t													height_t;		typedef cindex<C>												width_t;		typedef coord_t<one_t,cindex<C> >								extent_t;		typedef Structure												structure_t;		typedef matrix<extent_t,structure_t>							this_t;		typedef base_matrix<extent_t,structure_t>						base_t;		typedef typename base_t::transpose_t										transpose_t;		typedef typename base_t::init_type_t										init_type_t;								// Constructors												// copy constructors									matrix(const this_t &m)				: base_t(m.extent(), m.structure()) {}																									matrix(const transpose_t &mT)		: base_t(mT.extent().transpose(), mT.structure()) {}									template<class R2, class C2, class Structure2, class S, class L>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S,L> r, row_axis_t)				 														: base_t(r.length(), m.width(), m.structure(), r.start(), zero) {}template<class R2, class C2, class Structure2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, index_t i, row_axis_t)				 														: base_t(one, m.width(), m.structure(), i, zero) {}template<class R2, class C2, class Structure2, index_t K>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, cindex<K> i, row_axis_t)				 														: base_t(one, m.width(), m.structure(), i, zero) {}template<class R2, class C2, class Structure2, class S, class L>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S,L> r, column_axis_t)				 														: base_t(m.height(), r.length(), m.structure(), zero, r.start()) {}									template<class R2, class C2, class Structure2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, index_t i, column_axis_t)				 														: base_t(m.height(), one, m.structure(), zero, i) {}									template<class R2, class C2, class Structure2, index_t K>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, cindex<K> i, column_axis_t)				 														: base_t(m.height(), one, m.structure(), zero, i) {}									template<class R2, class C2, class Structure2, class S1, class L1, class S2, class L2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S1,L1> r1, range_t<S2,L2> r2)				 														: base_t(r1.length(), r2.length(), m.structure(), r1.start(), r2.start())				 														{}																			// constituent constructors									matrix(const extent_t &e, const structure_t &s)																										: base_t(e,s) {}																					// from scratch									matrix(const extent_t &e, init_type_t fill = init_none)																								: base_t(e,fill) {}									matrix(const height_t rs, const width_t cs, init_type_t fill = init_none)																			: base_t(extent_t(rs,cs), fill) {}																					// data constructors									matrix(const extent_t &e, scalar_t *data)																											: base_t(e,data) {}																											matrix(const height_t rs, const width_t cs, scalar_t *data) 																						: base_t(extent_t(rs,cs), data) {} 									matrix(const extent_t &e, const scalar_t *data)																								: base_t(e,const_cast<scalar_t*>(data)) {}									matrix(const height_t rs, const width_t cs, const scalar_t *data)																				: base_t(extent_t(rs,cs), const_cast<scalar_t*>(data)) {}																					// specialization-specific constructors																			matrix(init_type_t fill = init_none)																								: base_t(extent_t(one,width_t()),fill) {}									matrix(scalar_t *data)				: base_t(extent_t(one,width_t()),data) {}																											matrix(const scalar_t *data)		: base_t(extent_t(one,width_t()),const_cast<scalar_t*>(data)) {}														// Predicates												// Operators				this_t&				operator= (const this_t &m)			{ return copy(*this, m); }				this_t&				operator= (const scalar_t &v)		{ return fill(*this, v); }template<class E2, class S2>				this_t&				operator= (const matrix<E2,S2> &m)	{ return copy(*this, m); }						// SPECIALIZATION-SPECIFIC OPERATORStemplate<class C2>				scalar_t &			operator[](C2 i)					{ return this->structure()(zero, i); }template<class C2>		  const scalar_t			operator[](C2 i) const				{ return this->structure()(zero, i); }template<class C2>				scalar_t &			operator()(C2 i)					{ return this->structure()(zero, i); }template<class C2>		  const scalar_t			operator()(C2 i) const				{ return this->structure()(zero, i); }template<class R2, class C2>				scalar_t &			operator()(const R2 &r, const C2 &c) { return this->structure()(r,c); }template<class R2, class C2>		  const scalar_t			operator()(const R2 &r, const C2 &c) const		  																{ return this->structure()(r,c); }};	// DYNAMIC-LENGTH ROW VECTORtemplate<class Structure> class matrix<coord_t<one_t,index_t>, Structure> : public base_matrix<coord_t<one_t,index_t>, Structure> {public:						// Types				typedef one_t													height_t;		typedef index_t													width_t;		typedef coord_t<one_t,index_t>									extent_t;		typedef Structure												structure_t;		typedef matrix<extent_t,structure_t>							this_t;		typedef base_matrix<extent_t,structure_t>						base_t;		typedef typename base_t::transpose_t										transpose_t;		typedef typename base_t::init_type_t										init_type_t;								// Constructors												// copy constructors									matrix(const this_t &m)				: base_t(m.extent(), m.structure()) {}																									matrix(const transpose_t &mT)		: base_t(mT.extent().transpose(), mT.structure()) {}									template<class R2, class C2, class Structure2, class S, class L>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S,L> r, row_axis_t)				 														: base_t(r.length(), m.width(), m.structure(), r.start(), zero) {}template<class R2, class C2, class Structure2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, index_t i, row_axis_t)				 														: base_t(one, m.width(), m.structure(), i, zero) {}template<class R2, class C2, class Structure2, index_t K>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, cindex<K> i, row_axis_t)				 														: base_t(one, m.width(), m.structure(), i, zero) {}template<class R2, class C2, class Structure2, class S, class L>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S,L> r, column_axis_t)				 														: base_t(m.height(), r.length(), m.structure(), zero, r.start()) {}									template<class R2, class C2, class Structure2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, index_t i, column_axis_t)				 														: base_t(m.height(), one, m.structure(), zero, i) {}									template<class R2, class C2, class Structure2, index_t K>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, cindex<K> i, column_axis_t)				 														: base_t(m.height(), one, m.structure(), zero, i) {}									template<class R2, class C2, class Structure2, class S1, class L1, class S2, class L2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S1,L1> r1, range_t<S2,L2> r2)				 														: base_t(r1.length(), r2.length(), m.structure(), r1.start(), r2.start())				 														{}																			// constituent constructors									matrix(const extent_t &e, const structure_t &s)																										: base_t(e,s) {}																					// from scratch									matrix(const extent_t &e, init_type_t fill = init_none)																								: base_t(e,fill) {}									matrix(const height_t rs, const width_t cs, init_type_t fill = init_none)																			: base_t(extent_t(rs,cs), fill) {}																					// data constructors									matrix(const extent_t &e, scalar_t *data)																											: base_t(e,data) {}																											matrix(const height_t rs, const width_t cs, scalar_t *data) 																						: base_t(extent_t(rs,cs), data) {} 									matrix(const extent_t &e, const scalar_t *data)																								: base_t(e,const_cast<scalar_t*>(data)) {}									matrix(const height_t rs, const width_t cs, const scalar_t *data)																				: base_t(extent_t(rs,cs), const_cast<scalar_t*>(data)) {}																					// specialization-specific constructors																			matrix(const height_t cs, init_type_t fill = init_none)																								: base_t(extent_t(one,cs),fill) {}									matrix(const height_t cs, scalar_t *data)																						: base_t(extent_t(one,cs),data) {}																											matrix(const height_t cs, const scalar_t *data)																			: base_t(extent_t(one,cs),const_cast<scalar_t*>(data)) {}														// Predicates												// Operators				this_t&				operator= (const this_t &m)			{ return copy(*this, m); }				this_t&				operator= (const scalar_t &v)		{ return fill(*this, v); }template<class E2, class S2>				this_t&				operator= (const matrix<E2,S2> &m)	{ return copy(*this, m); }							// SPECIALIZATION-SPECIFIC OPERATORStemplate<class C2>				scalar_t &			operator[](C2 i)					{ return this->structure()(zero, i); }template<class C2>		  const scalar_t			operator[](C2 i) const				{ return this->structure()(zero, i); }template<class C2>				scalar_t &			operator()(C2 i)					{ return this->structure()(zero, i); }template<class C2>		  const scalar_t			operator()(C2 i) const				{ return this->structure()(zero, i); }template<class R2, class C2>				scalar_t &			operator()(const R2 &r, const C2 &c) { return this->structure()(r,c); }template<class R2, class C2>		  const scalar_t			operator()(const R2 &r, const C2 &c) const		  																{ return this->structure()(r,c); }};	// STATIC-SIZED MATRIXtemplate<index_t R, index_t C, class Structure> class matrix<coord_t<cindex<R>,cindex<C> >, Structure> : public base_matrix<coord_t<cindex<R>,cindex<C> >, Structure> {public:						// Types				typedef cindex<R>												height_t;		typedef cindex<C>												width_t;		typedef coord_t<cindex<R>,cindex<C> >							extent_t;		typedef Structure												structure_t;		typedef matrix<extent_t,structure_t>							this_t;		typedef base_matrix<extent_t,structure_t>						base_t;		typedef typename base_t::transpose_t										transpose_t;		typedef typename base_t::init_type_t										init_type_t;								// Constructors												// copy constructors									matrix(const this_t &m)				: base_t(m.extent(), m.structure()) {}																									matrix(const transpose_t &mT)		: base_t(mT.extent().transpose(), mT.structure()) {}									template<class R2, class C2, class Structure2, class S, class L>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S,L> r, row_axis_t)				 														: base_t(r.length(), m.width(), m.structure(), r.start(), zero) {}template<class R2, class C2, class Structure2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, index_t i, row_axis_t)				 														: base_t(one, m.width(), m.structure(), i, zero) {}template<class R2, class C2, class Structure2, index_t K>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, cindex<K> i, row_axis_t)				 														: base_t(one, m.width(), m.structure(), i, zero) {}template<class R2, class C2, class Structure2, class S, class L>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S,L> r, column_axis_t)				 														: base_t(m.height(), r.length(), m.structure(), zero, r.start()) {}									template<class R2, class C2, class Structure2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, index_t i, column_axis_t)				 														: base_t(m.height(), one, m.structure(), zero, i) {}									template<class R2, class C2, class Structure2, index_t K>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, cindex<K> i, column_axis_t)				 														: base_t(m.height(), one, m.structure(), zero, i) {}									template<class R2, class C2, class Structure2, class S1, class L1, class S2, class L2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S1,L1> r1, range_t<S2,L2> r2)				 														: base_t(r1.length(), r2.length(), m.structure(), r1.start(), r2.start())				 														{}																			// constituent constructorstemplate<class Structure2>			matrix(const extent_t &e, const Structure2 &s)																										: base_t(e,s) {}																					// from scratch									matrix(const extent_t &e, init_type_t fill = init_none)																								: base_t(e,fill) {}									matrix(const height_t rs, const width_t cs, init_type_t fill = init_none)																			: base_t(extent_t(rs,cs), fill) {}																					// data constructors									matrix(const extent_t &e, scalar_t *data)																											: base_t(e,data) {}																											matrix(const height_t rs, const width_t cs, scalar_t *data) 																						: base_t(extent_t(rs,cs), data) {} 									matrix(const extent_t &e, const scalar_t *data)																								: base_t(e,const_cast<scalar_t*>(data)) {}									matrix(const height_t rs, const width_t cs, const scalar_t *data)																				: base_t(extent_t(rs,cs), const_cast<scalar_t*>(data)) {}																												// specialization-specific constructors																			matrix(init_type_t fill = init_none)																								: base_t(extent_t(height_t(),width_t()),fill) {}									matrix(scalar_t *data)				: base_t(extent_t(height_t(),width_t()),data) {}																											matrix(const scalar_t *data)		: base_t(extent_t(height_t(),width_t()),const_cast<scalar_t*>(data)) {}																									// Predicates												// Operators				this_t&				operator= (const this_t &m)			{ return copy(*this, m); }				this_t&				operator= (const scalar_t &v)		{ return fill(*this, v); }template<class E2, class S2>				this_t&				operator= (const matrix<E2,S2> &m)	{ return copy(*this, m); }	};	// DYNAMIC-SIZED MATRIXtemplate<class R, class C, class Structure> class matrix<coord_t<R,C>, Structure> : public base_matrix<coord_t<R,C>, Structure> {public:						// Types				typedef R													height_t;		typedef C													width_t;		typedef coord_t<R,C>								extent_t;		typedef Structure												structure_t;		typedef matrix<extent_t,structure_t>							this_t;		typedef base_matrix<extent_t,structure_t>						base_t;		typedef typename base_t::transpose_t										transpose_t;		typedef typename base_t::init_type_t										init_type_t;								// Constructors												// copy constructors									matrix(const this_t &m)				: base_t(m.extent(), m.structure()) {}																									matrix(const transpose_t &mT)		: base_t(mT.extent().transpose(), mT.structure()) {}									template<class R2, class C2, class Structure2, class S, class L>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S,L> r, row_axis_t)				 														: base_t(r.length(), m.width(), m.structure(), r.start(), zero) {}template<class R2, class C2, class Structure2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, index_t i, row_axis_t)				 														: base_t(one, m.width(), m.structure(), i, zero) {}template<class R2, class C2, class Structure2, index_t K>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, cindex<K> i, row_axis_t)				 														: base_t(one, m.width(), m.structure(), i, zero) {}template<class R2, class C2, class Structure2, class S, class L>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S,L> r, column_axis_t)				 														: base_t(m.height(), r.length(), m.structure(), zero, r.start()) {}									template<class R2, class C2, class Structure2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, index_t i, column_axis_t)				 														: base_t(m.height(), one, m.structure(), zero, i) {}									template<class R2, class C2, class Structure2, index_t K>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, cindex<K> i, column_axis_t)				 														: base_t(m.height(), one, m.structure(), zero, i) {}									template<class R2, class C2, class Structure2, class S1, class L1, class S2, class L2>				 					matrix(const base_matrix<coord_t<R2,C2>,Structure2> &m, range_t<S1,L1> r1, range_t<S2,L2> r2)				 														: base_t(r1.length(), r2.length(), m.structure(), r1.start(), r2.start())				 														{}																			// constituent constructorstemplate<class Structure2>			matrix(const extent_t &e, const Structure2 &s)																										: base_t(e,s) {}																					// from scratch									matrix(const extent_t &e, init_type_t fill = init_none)																								: base_t(e,fill) {}									matrix(const height_t rs, const width_t cs, init_type_t fill = init_none)																			: base_t(extent_t(rs,cs), fill) {}																					// data constructors									matrix(const extent_t &e, scalar_t *data)																											: base_t(e,data) {}																											matrix(const height_t rs, const width_t cs, scalar_t *data) 																						: base_t(extent_t(rs,cs), data) {} 									matrix(const extent_t &e, const scalar_t *data)																								: base_t(e,const_cast<scalar_t*>(data)) {}									matrix(const height_t rs, const width_t cs, const scalar_t *data)																				: base_t(extent_t(rs,cs), const_cast<scalar_t*>(data)) {}																	// Predicates												// Operators				this_t&				operator= (const this_t &m)			{ return copy(*this, m); }				this_t&				operator= (const scalar_t &v)		{ return fill(*this, v); }template<class E2, class S2>				this_t&				operator= (const matrix<E2,S2> &m)	{ return copy(*this, m); }	};template<class E, class S, class RS, class RL>class matrix_traits<matrix<E,S>,range_t<RS,RL> > {public:					typedef matrix<coord_t<RL, typename E::width_t >, typename S::alias_t> rows_t;					typedef matrix<coord_t<typename E::height_t, RL>, typename S::alias_t> cols_t;};template<class E, class S, class RR, class CR>class matrix_traits<matrix<E,S>,block_t<RR,CR> > {public:	// submatrix_t	typedef coord_t<typename RR::length_t,typename CR::length_t>								submatrix_extent_t;	typedef typename structure_factory<typename S::alias_t, submatrix_extent_t>::structure_t	submatrix_structure_t;	typedef matrix<submatrix_extent_t,submatrix_structure_t>				submatrix_t;	};template<class E, class S, class E2, class S2>class matrix_traits<matrix<E,S>, matrix<E2,S2> > {public:	// multiply_t	typedef coord_t<typename E::row_t,typename E2::col_t>										multiply_extent_t;	typedef typename structure_factory<typename S::alias_t, multiply_extent_t>::structure_t	multiply_structure_t;	typedef matrix<multiply_extent_t,multiply_structure_t>					multiply_t;		// deriv_t -- dM1/dM2	typedef coord_t<typename E::row_t,typename E2::row_t> 									deriv_extent_t;	typedef typename structure_factory<typename S::alias_t, deriv_extent_t>::structure_t		deriv_structure_t;	typedef matrix<deriv_extent_t,deriv_structure_t>						deriv_t;	};template<class E, class S, class E2, class S2>matrix<E,S>& copy(matrix<E,S>&, const matrix<E2,S2>&);template<class E, class S>matrix<E,S>& fill(matrix<E,S>&, const scalar_t&);} // namespace cf_algebra#endif /* __MATRIX_H */