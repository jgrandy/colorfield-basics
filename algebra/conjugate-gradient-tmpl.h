/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __CONJUGATE_GRADIENT_TMPL_H#define __CONJUGATE_GRADIENT_TMPL_H#include "conjugate-gradient.h"#include "matrix-ops.h"#include "cf-debug.h"namespace cf_algebra {template<class A, class X, class B> void conjugate_gradient_solver<A,X,B>::solve(const A_t &a, x_t &x, const b_t &b){	const size_t n = a.height();		AC_PRECONDITION(a.width() == n);	AC_PRECONDITION(x.height() == n);	AC_PRECONDITION(b.height() == n);		// precompute some stopping criteria	const double b_norm = norm_maxabs(b),				 A_norm = norm_maxabs(a);		// compute preconditioner Minv.	// We'll just use a's diagonal; crude, but apparently effective		for (int i=0; i<n; i++) {		Minv_(zero,(index_t) i) = (scalar_t) 1 / a(i,i);	}	// guess an x0				x = (scalar_t) 0.0;			// compute 0th residual		residual_ = b;		// set up the iteration state		index_t	i = 1;	bool	done = false;	scalar_t  rho_p1, rho_p2;		// -- uncomment gaxpy if initial x != 0.0	//gaxpy(r_p1, -1.0, a, x);	rho_p1 = (scalar_t) 0.0;		typename b_t::transpose_t p_T = p_.transpose();	typename b_t::transpose_t residual_T = residual_.transpose();		while (true) {				// z(i-1) <- Minv * r(i-1)		z_ = Minv_;		z_ *= residual_;				// rho(i-2) <- rho(i-1)		rho_p2 = rho_p1;				// rho(i-1) <- r(i-1) dot z(i-1)		matrix_multiply(rho_p1, residual_T, z_);				if (i == 1)			// p(1) <- z(0)			p_ = z_;		else {			// beta(i) <- rho(i-1) / rho(i-2)			const scalar_t beta = rho_p1 / rho_p2;			// p(i) <- beta*p(i-1) + z(i-1)			//¥¥¥optimize with sort of backwards saxpy			p_ *= beta;			p_ += z_;		}		// q(i) <- a * p(i)		matrix_multiply(q_, a, p_);				// alpha(i) <- rho(i-1) / (p(i) dot q(i))		scalar_t pdotq;		matrix_multiply(pdotq, p_T, q_);		const scalar_t alpha = rho_p1 / pdotq;		// x(i) <- alpha(i) * p(i) + x(i-1)		axpy(alpha, p_, (scalar_t) 1.0, x);				// r(i) <- - alpha(i) * q(i) + r(i-1)		axpy(- alpha, q_, (scalar_t) 1.0, residual_);		// stop if within our error tolerance		// (as best we can determine)		const scalar_t r_norm = norm_maxabs(residual_),					   x_norm = norm_maxabs(x);		if (r_norm <= stop_tol_ * (A_norm * x_norm + b_norm))			break;				// we're not stopping, so iterate.		i++;		// stop now if too many iterations		if (i > max_it_)			break;			}	iterations_ = i;}template<class A, class X, class B> void conjugate_gradient_solver<A,X,B>::invert(A_t &, A_t &){	FAIL("Conjugate Gradient Invert not yet implemented")}} /* namespace colorfield_AC */#endif /* __CONJUGATE_GRADIENT_TMPL_H */