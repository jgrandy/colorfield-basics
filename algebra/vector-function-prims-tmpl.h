/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __VECTOR_FUNCTION_TMPL_H#define __VECTOR_FUNCTION_TMPL_H#include "vector-function.h"#include "matrix-io.h"#include <sstream>namespace cf_algebra {template<class F, class G>template<class Q, class R>void composite_vf<F,G>::apply(R &r, const scalar_t &a, const Q &q) const{	const typename Q::height_t q_size = q.height();	const typename G::result_size_t g_result_size = g_.result_size(q_size);		matrixn1 g_result(g_result_size, one, init_zero);		g_.apply(g_result, 1, q);	f_.apply(r, a, g_result);}template<class F, class G>template<class Q, class R, class DR>void composite_vf<F,G>::apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const{	const typename Q::height_t q_size = q.height();	const typename G::result_size_t g_result_size = g_.result_size(q_size);	const typename F::result_size_t f_result_size = f_.result_size(g_result_size);		typedef matrixn1 g_t;	g_t g_result(g_result_size, one, init_zero);	typename matrix_traits<g_t,Q>::deriv_t dgdq(g_result_size, q_size, init_zero);	typename matrix_traits<R,g_t>::deriv_t dfdg(f_result_size, g_result_size, init_zero);		try {		g_.apply_derive(g_result, dgdq, 1, q);	} catch (std::logic_error &exc) {		std::ostringstream os;		os << "error while evaluating g " << g_ << '(' << q << "): " << exc.what() << std::endl;		throw(std::logic_error(os.str()));	}		try {		f_.apply_derive(r, dfdg, a, g_result);	} catch (std::logic_error &exc) {		std::ostringstream os;		os << "error while evaluating f " << f_ << '(' << g_result << "): " << exc.what() << std::endl;		throw(std::logic_error(os.str()));	}		axpy(scalar1, dfdg, dgdq, scalar1, dfdq);}template<class F, class G>template<class Q, class DR>void composite_vf<F,G>::derive(DR &dfdq, const scalar_t &a, const Q &q) const{	const typename Q::height_t q_size = q.height();	const typename G::result_size_t g_result_size = g_.result_size(q_size);	const typename F::result_size_t f_result_size = f_.result_size(g_result_size);		typedef matrixn1 g_t;	g_t g_result(g_result_size, one, init_zero);	typename matrix_traits<g_t,Q>::deriv_t  dgdq(g_result_size, q_size, init_zero);	typename matrix_traits<DR,g_t>::deriv_t dfdg(f_result_size, g_result_size, init_zero);	// this works because dfdq_t has the same height_t as result_t would		g_.apply_derive(g_result, dgdq, 1, q);	f_.derive(dfdg, a, g_result);		axpy(scalar1, dfdg, dgdq, scalar1, dfdq);}template<class F, class T, class G>template<class Q, class R>void sum_vf<F,T,G>::apply(R &r, const scalar_t &a, const Q &q) const{	g_.apply(r, a*((scalar_t) a_), q);	f_.apply(r, a,    q);}template<class F, class T, class G>template<class Q, class R, class DR>void sum_vf<F,T,G>::apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const{	g_.apply_derive(r, dfdq, a*((scalar_t) a_), q);	f_.apply_derive(r, dfdq, a,    q);}template<class F, class T, class G>template<class Q, class DR>void sum_vf<F,T,G>::derive(DR &dfdq, const scalar_t &a, const Q &q) const{	g_.derive(dfdq, a* ((scalar_t) a_), q);	f_.derive(dfdq, a,    q);}template<class F, class G>template<class Q, class R>void dot_vf<F,G>::apply(R &r, const scalar_t &a, const Q &q) const{	const typename Q::height_t q_height = q.height();	const typename F::result_size_t f_height = f_.result_size(q_height);	const typename G::result_size_t g_height = g_.result_size(q_height);		AC_PRECONDITION(f_height == g_height);		typedef matrixn1 vector_t;	vector_t fv(f_height, one),			 gv(g_height, one);	f_.apply(fv, a, q);	g_.apply(gv, a, q);		matrix_multiply(r(zero,zero), fv.transpose(), gv);}template<class F, class G>template<class Q, class R, class DR>void dot_vf<F,G>::apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const{	const typename Q::height_t q_height = q.height();	const typename F::result_size_t f_height = f_.result_size(q_height);	const typename G::result_size_t g_height = g_.result_size(q_height);		AC_PRECONDITION(f_height == g_height);		typedef matrixn1 vector_t;	typedef matrixn  matrix_t;	vector_t fv(f_height, one, init_zero),			 gv(g_height, one, init_zero);	matrix_t df(f_height, q_height, init_zero),			 dg(g_height, q_height, init_zero);	f_.apply_derive(fv, df, a, q);	g_.apply_derive(gv, dg, a, q);		matrix_multiply(r(zero,zero), fv.transpose(), gv);		for (int i=0; i<f_height; i++) {		const typename matrix_t::row_t dfi(df, i, row_axis),                                       dgi(dg, i, row_axis);		axpy(gv(i, zero), dfi,			 fv(i, zero), dgi,			 scalar1, dfdq);	}}template<class F, class G>template<class Q, class DR>void dot_vf<F,G>::derive(DR &dfdq, const scalar_t &a, const Q &q) const{	const typename Q::height_t q_height = q.height();	const typename F::result_size_t f_height = f_.result_size(q_height);	const typename G::result_size_t g_height = g_.result_size(q_height);		AC_PRECONDITION(f_height == g_height);		typedef matrixn1 vector_t;	typedef matrixn  matrix_t;	vector_t fv(f_height, one, init_zero),			 gv(g_height, one, init_zero);	matrix_t df(f_height, q_height, init_zero),			 dg(g_height, q_height, init_zero);	f_.apply_derive(fv, df, a, q);	g_.apply_derive(gv, dg, a, q);		for (int i=0; i<f_height; i++) {		const typename matrix_t::row_t dfi(df, i, row_axis),							  dgi(dg, i, row_axis);		axpy(gv(i, zero), dfi,			 fv(i, zero), dgi,			 scalar1, dfdq);	}}template<class T, class F>template<class Q, class R>void scaled_vf<T,F>::apply(R &r, const scalar_t &a, const Q &q) const{	f_.apply(r, a*scale_, q);}template<class T, class F>template<class Q, class R, class DR>void scaled_vf<T,F>::apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const{	f_.apply_derive(r, dfdq, a*scale_, q);}template<class T, class F>template<class Q, class DR>void scaled_vf<T,F>::derive(DR &dfdq, const scalar_t &a, const Q &q) const{	f_.derive(dfdq, a*scale_, q);}template<index_t N>template<class Q, class R>void map_vf<N>::apply(R &r, const scalar_t &a, const Q &q) const{	axpy(a, map_, q, scalar1, r);}template<index_t N>template<class Q, class R, class DR>void map_vf<N>::apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const{	axpy(a, map_, q, (scalar_t) 1, r);	axpy((scalar_t) 1, map_, a, dfdq);}template<index_t N>template<class Q, class DR>void map_vf<N>::derive(DR &dfdq, const scalar_t &a, const Q &) const{	axpy((scalar_t) 1, map_, a, dfdq);}template<class T>template<class Q, class R>void wrapped_vf<T>::apply(R &r, const scalar_t &a, const Q &q) const{	AC_PRECONDITION(q.height() == one);		const scalar_t delta = fmod(q(0,0), bound_);//clog << "delta(" << q(0,0) << "): " << delta << endl;	r(0,0) += delta * a;	}template<class T>template<class Q, class R, class DR>void wrapped_vf<T>::apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const{	AC_PRECONDITION(q.height() == one);		const scalar_t delta = fmod(q(0,0), bound_);//clog << "delta(" << q(0,0) << "): " << delta << endl;	r(0,0) += delta * a;		dfdq(0,0) += a;}template<class T>template<class Q, class DR>void wrapped_vf<T>::derive(DR &dfdq, const scalar_t &a, const Q &q) const{	AC_PRECONDITION(q.height() == one);		dfdq(0,0) += a;}template<class T>template<class q_size_t>const typename wrapped_vf<T>::result_size_t wrapped_vf<T>::result_size(const q_size_t &) const{	return one;}template<class F>template<class Q, class R>void stacked_vf<F>::apply(R &r, const scalar_t &a, const Q &q) const{	const typename Q::height_t q_size = q.height();		typename functions_t::const_iterator fit = functions_.begin(),								fstop = functions_.end();	index_t i = 0;	while (fit != fstop) {		const F *cnt = *fit;		const index_t n = cnt->result_size(q_size);		typename matrix_traits<R,range_t<> >::rows_t Cin(r,range(i,n),row_axis);//		typename matrix_traits<R,range_t<> >::rows_t Cin = r.rows(range(i,n));		cnt->apply(Cin,a,q);				i += n;		++fit;	}}template<class F>template<class Q, class R, class DR>void stacked_vf<F>::apply_derive(R &r, DR &dfdq, const scalar_t &a, const Q &q) const{	const typename Q::height_t q_size = q.height();	//		clog << "C: " << r << endl;//		clog << "J: " << dfdq << endl;			typename functions_t::const_iterator fit = functions_.begin(),								fstop = functions_.end();	index_t i = 0;	while (fit != fstop) {		const F *cnt = *fit;		const index_t n = cnt->result_size(q_size);//			clog << "row " << i << ", " << n << endl;					typename matrix_traits< R,range_t<> >::rows_t Cin(r   ,range(i,n),row_axis);		typename matrix_traits<DR,range_t<> >::rows_t Jin(dfdq,range(i,n),row_axis);//		typename matrix_traits<R,range_t<> >::rows_t Cin = r.rows(range(i,n));//		typename matrix_traits<DR,range_t<> >::rows_t Jin = dfdq.rows(range(i,n));		cnt->apply_derive(Cin,Jin,a,q);//			clog << "Cin: " << Cin << endl;//			clog << "Jin: " << Jin << endl;//			clog << "J: " << dfdq << endl;							i += n;		++fit;	}}template<class F>template<class Q, class DR>void stacked_vf<F>::derive(DR &dfdq, const scalar_t &a, const Q &q) const{	const typename Q::height_t q_size = q.height();		typename functions_t::const_iterator fit = functions_.begin(),								fstop = functions_.end();	index_t i = 0;	while (fit != fstop) {		const F *cnt = *fit;		const index_t n = cnt->result_size(q_size);		typename matrix_traits<DR, range_t<> >::rows_t Jin(dfdq,range(i,n),row_axis);//		matrix_traits<DR,range_t<> >::rows_t Jin = dfdq.rows(range(i,n));		cnt->derive(Jin,a,q);				i += n;		++fit;	}}template<class F>template<class q_size_t>const typename stacked_vf<F>::result_size_t stacked_vf<F>::result_size(const q_size_t &q_size) const{	typename functions_t::const_iterator fit = functions_.begin(),								fstop = functions_.end();	index_t i = 0;	while (fit != fstop) {		const F *cnt = *fit;		i += cnt->result_size(q_size);		++fit;	}	return i;}template<class F>void stacked_vf<F>::add(const F* const f){	functions_.push_front(f);}template<class F>void stacked_vf<F>::remove(const F* const f){	functions_.remove(f);}} // namespace cf_algebra#endif /* __VECTOR_FUNCTION_TMPL_H */