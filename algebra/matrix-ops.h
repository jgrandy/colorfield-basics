/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __MATRIX_OPS_H#define __MATRIX_OPS_H#include "matrix.h"#include "matrix-exceptions.h"namespace cf_algebra {	// Predicates	template<class Extent, class Structure>				bool							has_nan		(const matrix<Extent,Structure>&);template<class Extent1, class Structure1, class Extent2, class Structure2>				bool							operator==  (const matrix<Extent1,Structure1>&, 															 const matrix<Extent2,Structure2>&);template<class Extent1, class Structure1, class Extent2, class Structure2>				bool							operator!=  (const matrix<Extent1,Structure1>&, 															 const matrix<Extent2,Structure2>&);template<class Extent, class Structure>				bool							operator==  (const matrix<Extent,Structure>&, 															 const scalar_t&);template<class Extent, class Structure>				bool							operator!=  (const matrix<Extent,Structure>&, 															 const scalar_t&);	// Operators	template<class Extent, class Structure>	 			scalar_t						norm_p2		(const matrix<Extent,Structure>&);template<class Extent, class Structure>				scalar_t						norm_maxabs (const matrix<Extent,Structure>&);template<class R1, class Structure1, class R2, class Structure2>				scalar_t						distance    (const matrix<coord_t<R1,one_t>,Structure1> &p1,	   														 const matrix<coord_t<R2,one_t>,Structure2> &p2);	   														 template<class R1, class Structure1, class R2, class Structure2>				scalar_t						ray_angle   (const matrix<coord_t<R1,one_t>,Structure1> &c,	   														 const matrix<coord_t<R2,one_t>,Structure2> &p);	   														 	// Updaters	template<class Extent1, class Structure1, class Extent2, class Structure2>				matrix<Extent1,Structure1>&		operator+=  (      matrix<Extent1,Structure1>&,															 const matrix<Extent2,Structure2>&);template<class Extent1, class Structure1, class Extent2, class Structure2>				matrix<Extent1,Structure1>&		operator-=  (      matrix<Extent1,Structure1>&,															 const matrix<Extent2,Structure2>&);template<class Extent1, class Structure1, class Extent2, class Structure2>				matrix<Extent1,Structure1>&		operator*=  (      matrix<Extent1,Structure1>&,															 const matrix<Extent2,Structure2>&);template<class Extent1, class Structure1, class Extent2, class Structure2>				matrix<Extent1,Structure1>&		operator/=  (      matrix<Extent1,Structure1>&,															 const matrix<Extent2,Structure2>&);template<class Extent, class Structure>				matrix<Extent,Structure>&		operator+=  (      matrix<Extent,Structure>&,															 const scalar_t&);template<class Extent, class Structure>				matrix<Extent,Structure>&		operator-=  (      matrix<Extent,Structure>&,															 const scalar_t&);template<class Extent, class Structure>				matrix<Extent,Structure>&		operator*=  (      matrix<Extent,Structure>&,															 const scalar_t&);template<class Extent, class Structure>				matrix<Extent,Structure>&		operator/=  (      matrix<Extent,Structure>&,															 const scalar_t&);template<class Extent1, class Structure1, class Extent2, class Structure2>				matrix<Extent1,Structure1>&		set_diagonal(      matrix<Extent1,Structure1> &x,															 const matrix<Extent2,Structure2> &y);															 template<class Extent, class Structure>				matrix<Extent,Structure>&		set_diagonal(      matrix<Extent,Structure> &x,															 const scalar_t &a);template<class Extent, class Structure>				matrix<Extent,Structure>&		add_diagonal(      matrix<Extent,Structure> &x,															 const scalar_t &a);															 	// Multiply	// y <- A xtemplate<class R1, class Structure1, class Extent2, class Structure2, class R3, class Structure3>		matrix<coord_t<R1,one_t>,Structure1>&	matrix_multiply															(      matrix<coord_t<R1,one_t>,Structure1> &y,															 const matrix<Extent2,          Structure2> &a,															 const matrix<coord_t<R3,one_t>,Structure3> &x);// C <- x y'template<class Extent1, class Structure1, class R2, class Structure2, class C3, class Structure3>				matrix<Extent1,Structure1>&		matrix_multiply															(      matrix<Extent1,          Structure1> &c,															 const matrix<coord_t<R2,one_t>,Structure2> &x,															 const matrix<coord_t<one_t,C3>,Structure3> &y);// a <- x' ytemplate<class R1, class Structure1, class R2, class Structure2>				scalar_t&						matrix_multiply															(      scalar_t &a,															 const matrix<coord_t<one_t,R1>,Structure1> &x,															 const matrix<coord_t<R2,one_t>,Structure2> &y);// C <- A Btemplate<class Extent1, class Structure1, 				  class Extent2, class Structure2, 				  class Extent3, class Structure3>				matrix<Extent1,Structure1>&		matrix_multiply															(      matrix<Extent1,Structure1> &C,															 const matrix<Extent2,Structure2> &A,															 const matrix<Extent3,Structure3> &B);// C <- A Btemplate<class Extent1, class Structure1, 				  class Extent2, class Structure2, 				  class Extent3, class Structure3>				matrix<Extent1,Structure1>&		matrix_multiply_upper_lower															(      matrix<Extent1,Structure1> &c,															 const matrix<Extent2,Structure2> &a,															 const matrix<Extent3,Structure3> &b);	// AXPY// y <- a x + b ytemplate<class Extent1, class Structure1, class Extent2, class Structure2>			matrix<Extent1,Structure1>&	axpy	  	(const scalar_t &a,													 const matrix<Extent2,Structure2> &x,													 const scalar_t &b,														   matrix<Extent1,Structure1> &y);// z <- a x + b y + c ztemplate<class Extent1, class Structure1, class Extent2, class Structure2, class Extent3, class Structure3>			matrix<Extent1,Structure1>&			axpy		(const scalar_t &a,															 const matrix<Extent2,Structure2> &x,															 const scalar_t &b,															 const matrix<Extent3,Structure3> &y,															 const scalar_t &c,															       matrix<Extent1,Structure1> &z);// C <- a A B + C ytemplate<class Extent1, class Structure1, class Extent2, class Structure2, class Extent3, class Structure3>			matrix<Extent1,Structure1>&			axpy		(const scalar_t &a,															 const matrix<Extent2,Structure2> &A,															 const matrix<Extent3,Structure3> &x,															 const scalar_t &b,															       matrix<Extent1,Structure1> &y);// A <- a x y' + Atemplate<class Extent1, class Structure1, 				  class Extent2, class Structure2, 				  class Extent3, class Structure3>				matrix<Extent1,Structure1>&		axpy		(const scalar_t &a,															 const matrix<Extent2,Structure2> &x,															 const matrix<Extent3,Structure3> &y,															       matrix<Extent1,Structure1> &A);} /* namespace cf_algebra */#endif /* __MATRIX_OPS_H */