/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 2000 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __LU_DECOMP_TMPL_H#define __LU_DECOMP_TMPL_H#include "lu-decomp.h"#include "matrix-ops.h"#include "cf-debug.h"#include <limits>namespace cf_algebra {template<class A, class X, class B> scalar_t lu_decomp_solver<A,X,B>::decompose(index_t n, A_t &a, index_t perm[]){	cvector vv(n,one);		scalar_t det = (scalar_t) 1.0;		scalar_t big = scalar0;	index_t imax;	for (int i=0; i<n; i++) {			for (int j=0; j<n; j++) {			const scalar_t tmp = std::abs(a(i,j));			if (tmp > big)				big = tmp;		}		AC_POSTCONDITION(big != scalar0);		vv[i] = scalar1 / big;	}		for (int j=0; j<n; j++) {		for (int i=0; i<j; i++) {			scalar_t sum = a(i,j);			for (int k=0; k<i; k++)				sum -= a(i,k) * a(k,j);			a(i,j) = sum;		}				scalar_t big = scalar0;		for (int i=j; i<n; i++) {			scalar_t sum = a(i,j);			for (int k=0; k<j; k++)				sum -= a(i,k) * a(k,j);			a(i,j) = sum;			const scalar_t dum = vv[i] * std::abs(sum);			if (dum >= big) {				big = dum;				imax = (index_t) i;			}		}				if (j != imax) {			for (int k=0; k<n; k++) {				const scalar_t dum = a(imax,k);				a(imax,k) = a(j,k);				a(j,k) = dum;			}			det = - det;			vv[imax] = vv[j];		}				perm[j] = imax;				if (a(j,j) == scalar0)			a(j,j) = 1.0e-20;				if (j != n-1) {			const scalar_t dum = 1.0 / a(j,j);			for (int i=j+1; i<n; i++)				a(i,j) *= dum;		}				if (j % 25 == 0) {			clog << '.'; clog.flush();		}	}		return det;	}template<class A, class X, class B> void lu_decomp_solver<A,X,B>::back_substitute(index_t n, const A_t &a, const index_t perm[], b_t &b){	bool nonzero_found = false;	index_t ii = 0;		for (int i=0; i<n; i++) {		index_t ip = perm[i];		scalar_t sum = b[ip];		b[ip] = b[i];		if (nonzero_found) {			for (int j=ii; j<i; j++) 				sum -= a(i,j) * b[j];		} else if (sum != scalar0) {				ii = (index_t) i;				nonzero_found = true;		}		b[i] = sum;	}		for (int i=n-1; i>=0; i--) {		scalar_t sum = b[i];		for (int j=i+1; j<n; j++)			sum -= a(i,j) * b[j];		b[i] = sum / a(i,i);	}}template<class A, class X, class B> void lu_decomp_solver<A,X,B>::solve(const A_t &a, x_t &x, const b_t &b){	const index_t n = a.height();	index_t *perm = new index_t[n];	A_t LU(n,n);	LU = a;	clog << "A: " << a << endl;	const scalar_t det = decompose(n, LU, perm);	clog << "LU: " << LU << endl;	clog << "perm: "; for (int i=0; i<n; i++) clog << perm[i] << " "; clog << endl;	x = b;	clog << "x: " << b << endl;	back_substitute(n, LU, perm, x);	clog << "x: " << x << endl;}template<class A, class X, class B> void lu_decomp_solver<A,X,B>::invert(A_t &Ainv, A_t &a){	const index_t n = a.height();	index_t *perm = new index_t[n];	const scalar_t det = decompose(n, a, perm);		clog << "decomposed. assembling inverse matrix." << endl;		for (int j=0; j<n; j++) {		cvector col(n,init_zero);		col[j] = 1.0;		back_substitute(n, a, perm, col);		for (int i=0; i<n; i++)			Ainv(i,j) = col[i];		if (j % 25 == 0) {			clog << '.'; clog.flush();		}	}	clog << endl;}} /* namespace colorfield_AC */#endif /* __LU_DECOMP_TMPL_H */