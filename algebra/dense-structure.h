/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __DENSE_STRUCTURE_H#define __DENSE_STRUCTURE_H#include "algebra-core.h"#include "coord.h"#include "index.h"#include "generic-iterators.h"#include <cstring>#include <cassert>namespace cf_algebra {/*1.				2.					3.									4.*/template<class Stride> class dense_structure;template<class Stride> class dense_transpose_structure;template<index_t R, index_t C>    class small_structure;template<class Stride = index_t> class dense_structure {	// Notes:	//	public:					// Types		typedef Stride										stride_t;		typedef dense_structure<stride_t>					this_t;		typedef this_t										alias_t;		typedef dense_transpose_structure<stride_t>			transpose_t;friend class dense_transpose_structure<stride_t>;				typedef       ptr_iterator  <scalar_t>				 row_it_t;		typedef const_ptr_iterator  <scalar_t>				crow_it_t;		typedef       slice_iterator<scalar_t,stride_t>		 col_it_t;		typedef const_slice_iterator<scalar_t,stride_t>		ccol_it_t;			typedef matrix_init_type							init_type_t;									// Constructors											// allocating constructortemplate<class R>					dense_structure(coord_t<R,stride_t> e, init_type_t fill = init_none)	// STANDARD																		: data_(new scalar_t[e.area()]), 																		  owns_data_(true), 																		  stride_(e.width()) 																		{																		  if (fill == init_zero) 																			std::memset(data_,0,e.area()*sizeof(scalar_t));																		}																					// *** copy constructors																				dense_structure(const this_t &ds)	: data_(ds.data_),				// STANDARD																		  owns_data_(false),																		  stride_(ds.stride_)																		{}									dense_structure(const transpose_t &ds)								// STANDARD																		: data_(const_cast<scalar_t*>(ds.ref(zero,zero))),																		  owns_data_(false),																		  stride_(ds.stride())																		{}template<index_t R, index_t C>		dense_structure(const small_structure<R,C> &ss)																		: data_(const_cast<scalar_t*>(ss.ref(zero,zero))),																		  owns_data_(false),																		  stride_(ss.stride())																		{}											// offset aliasing constructors											template<class R, class C>			dense_structure(const this_t &ds, R r, C c)																			: data_(const_cast<scalar_t*>(ds.ref(r,c))),																		  owns_data_(false),																		  stride_(ds.stride_)																		{}template<class R, class C>			dense_structure(const transpose_t &ds, R r, C c)																		: data_(const_cast<scalar_t*>(ds.ref(r,c))),																		  owns_data_(false),																		  stride_(ds.stride())																		{}template<index_t R, index_t C, class R2, class C2>											dense_structure(const small_structure<R,C> &ss, R2 r, C2 c)																		: data_(const_cast<scalar_t*>(ss.ref(r,c))),																		  owns_data_(false),																		  stride_(ss.stride())																		{}											// aliasing data constructors										template<class R>					dense_structure(      scalar_t *data, coord_t<R,stride_t> e)																		: data_(data), 																		  owns_data_(false), 																		  stride_(e.width()) 																		{}template<class R>					dense_structure(const scalar_t *data, coord_t<R,stride_t> e)																		: data_(const_cast<scalar_t*>(data)), 																		  owns_data_(false), 																		  stride_(e.width()) 																		{}									dense_structure(      scalar_t *data, stride_t s)																		: data_(data), 																		  owns_data_(false), 																		  stride_(s) 																		{}									dense_structure(const scalar_t *data, stride_t s)																		: data_(const_cast<scalar_t*>(data)), 																		  owns_data_(false), 																		  stride_(s) 																		{}									~dense_structure(void)				{ if (owns_data_) delete[] data_; data_ = NULL; }										// Operators									this_t&				operator= (const this_t &ds)		{																		  if (owns_data_) delete[] data_;																		  data_ = ds.data_;																		  owns_data_ = false; 																		  stride_ = ds.stride_; 																		  return *this;																		}template<class R> this_t&			resize(coord_t<R,stride_t> e)		{ 																		  if (owns_data_) {																		  	delete[] data_;																		  }																		  data_ = new scalar_t[e.area()];																		  stride_ = e.width();																		}								transpose_t			transpose(void) const				{ return transpose_t(data_, stride_); }template<class R, class C>				transpose_t			transpose(R r, C c) const			{ return transpose_t(ref(r,c), stride_); }									// Accessors								stride_t			stride(void) const					{ return stride_; }template<class R, class C>				scalar_t&			operator()(R r, C c)				{ return *(data_ + (r*stride_) + c); }template<class R, class C>		  const scalar_t&			operator()(R r, C c) const			{ return *(data_ + (r*stride_) + c); }																// Iterators					template<class R, class C>				 row_it_t			row_it(R r, C c)					{ return  row_it_t(ref(r,c)); }template<class R, class C>				crow_it_t			row_it(R r, C c) const				{ return crow_it_t(ref(r,c)); }template<class R, class C>				 col_it_t			col_it(R r, C c)					{ return  col_it_t(ref(r,c), stride_); }template<class R, class C>				ccol_it_t			col_it(R r, C c) const				{ return ccol_it_t(ref(r,c), stride_); }protected:template<class R, class C>				scalar_t*			ref(R r, C c)						{ return (data_ + (r*stride_) + c); }template<class R, class C>		  const scalar_t*			ref(R r, C c) const					{ return (data_ + (r*stride_) + c); }				private:				scalar_t*			data_;mutable			bool				owns_data_;				stride_t			stride_;};template<class S, class R, class C> class structure_factory<dense_structure<S>, coord_t<R,C> > {public:		typedef dense_structure<C> structure_t;};template<class Stride = index_t> class dense_transpose_structure {public:					// Types		typedef Stride										stride_t;		typedef dense_transpose_structure<stride_t>			this_t;		typedef this_t										alias_t;		typedef dense_structure<stride_t>					transpose_t;friend class dense_structure<stride_t>;		typedef       slice_iterator<scalar_t,stride_t>		 row_it_t;		typedef const_slice_iterator<scalar_t,stride_t>		crow_it_t;		typedef       ptr_iterator  <scalar_t>				 col_it_t;		typedef const_ptr_iterator  <scalar_t>				ccol_it_t;			typedef matrix_init_type							init_type_t;									// Constructors																// allocating constructor											template<class C>					dense_transpose_structure(coord_t<stride_t,C> e, const short fill = init_none)																		: data_(new scalar_t[e.area()]), 																		  owns_data_(true), 																		  stride_(e.height()) 																		{																		  if (fill == init_zero) 																			::memset(data_,0,e.area()*sizeof(scalar_t));																		}											// copy constructors																			dense_transpose_structure(const this_t &ds)																		: data_(ds.data_),																		  owns_data_(false),																		  stride_(ds.stride_)																		{}									dense_transpose_structure(const transpose_t &ds)																		: data_(const_cast<scalar_t*>(ds.ref(zero,zero))),																		  owns_data_(false),																		  stride_(ds.stride())																		{}template<index_t R, index_t C>		dense_transpose_structure(const small_structure<R,C> &ss)																		: data_(const_cast<scalar_t*>(ss.ref(zero,zero))),																		  owns_data_(false),																		  stride_(ss.stride())																		{}											// ref constructors											template<class R, class C>			dense_transpose_structure(const this_t &ds, R r, C c)																			: data_(const_cast<scalar_t*>(ds.ref(r,c))),																		  owns_data_(false),																		  stride_(ds.stride_)																		{}template<class R, class C>			dense_transpose_structure(const transpose_t &ds, R r, C c)																		: data_(const_cast<scalar_t*>(ds.ref(r,c))),																		  owns_data_(false),																		  stride_(ds.stride())																		{}template<index_t R, index_t C, class R2, class C2>											dense_transpose_structure(const small_structure<R,C> &ss, R2 r, C2 c)																		: data_(const_cast<scalar_t*>(ss.ref(r,c))),																		  owns_data_(false),																		  stride_(ss.stride())																		{}											// data constructorstemplate<class C>					dense_transpose_structure(      scalar_t *data, coord_t<stride_t,C> e)																		: data_(data), 																		  owns_data_(false), 																		  stride_(e.height()) 																		{}#if 0    template<class C>					dense_transpose_structure(const scalar_t *data, coord_t<stride_t,C> e)																		: data_(data), 																		  owns_data_(false), 																		  stride_(e.height()) 																		{}#endif									dense_transpose_structure(      scalar_t *data, stride_t s)																		: data_(data), 																		  owns_data_(false), 																		  stride_(s) 																		{}									dense_transpose_structure(const scalar_t *data, stride_t s)																		: data_(const_cast<scalar_t*>(data)), 																		  owns_data_(false), 																		  stride_(s) 																		{}																		~dense_transpose_structure(void)	{ if (owns_data_) delete[] data_; data_ = NULL; }															// Operators										this_t&				operator= (const this_t &ds)		{																		  data_ = ds.data_;																		  owns_data_ = false; 																		  stride_ = ds.stride_; 																		  return *this;																		}									transpose_t			transpose(void) const				{ return transpose_t(data_, stride_); }template<class R, class C>				transpose_t			transpose(R r, C c) const			{ return transpose_t(ref(r,c), stride_); }					// Accessors									stride_t			stride(void) const					{ return stride_; }template<class R, class C>				scalar_t&			operator()(R r, C c)				{ return *(data_ + (c*stride_) + r); }template<class R, class C>		  const scalar_t&			operator()(R r, C c) const			{ return *(data_ + (c*stride_) + r); }															// Iterators					template<class R, class C>				 row_it_t			row_it(R r, C c)					{ return  row_it_t(ref(r,c), stride_); }template<class R, class C>				crow_it_t			row_it(R r, C c) const				{ return crow_it_t(ref(r,c), stride_); }template<class R, class C>				 col_it_t			col_it(R r, C c)					{ return  col_it_t(ref(r,c)); }template<class R, class C>				ccol_it_t			col_it(R r, C c) const				{ return ccol_it_t(ref(r,c)); }protected:template<class R, class C>				scalar_t*			ref(R r, C c)						{ return (data_ + (c*stride_) + r); }template<class R, class C>		  const scalar_t*			ref(R r, C c) const					{ return (data_ + (c*stride_) + r); }				private:				scalar_t*			data_;mutable			bool				owns_data_;				stride_t			stride_;};template<class S, class R, class C> class structure_factory<dense_transpose_structure<S>, coord_t<R,C> > {public:		typedef dense_transpose_structure<C> structure_t;};template<index_t R, index_t C> class small_structure {	// Notes:	//	// - here, too consider specializing for C==1, using ptr_iterator for col_it_t	public:						// Types		typedef cindex<R>									height_t;		typedef cindex<C>									width_t;		typedef coord_t<cindex<R>, cindex<C> >				extent_t;		typedef typename extent_t::area_t							area_t;		typedef width_t										stride_t;		typedef small_structure<R,C>						this_t;		typedef dense_structure<stride_t>					alias_t;		typedef dense_transpose_structure<width_t>			transpose_t;		typedef       ptr_iterator  <scalar_t>				 row_it_t;		typedef const_ptr_iterator  <scalar_t>				crow_it_t;		typedef       slice_iterator<scalar_t,stride_t>		 col_it_t;		typedef const_slice_iterator<scalar_t,stride_t>		ccol_it_t;			typedef matrix_init_type							init_type_t;static	  const uint16_t				alloc_size_ = R*C;						// Constructors																	// allocating constructor																				small_structure(extent_t e, init_type_t fill = init_none)			// STANDARD																		{																		  assert(e.area() == R*C);																		  if (fill == init_zero)																		    std::memset(data_,0,e.area()*sizeof(scalar_t));																		}											// copy constructors																				small_structure(const this_t &ds)									// STANDARD																		{ std::memcpy(data_,ds.data_,alloc_size_*sizeof(scalar_t)); }									small_structure(const transpose_t &sT)								// STANDARD																		{                                                                            for (int i=0; i<R; i++)                                                                                for (int j=0; j<C; j++)																		    	   (*this)(i,j) = sT(i,j);																		}											// data constructors																				small_structure(const scalar_t *data, extent_t e)					// STANDARD																		{																		  assert(e.area() == R*C);																		  std::memcpy(data_, data, alloc_size_*sizeof(scalar_t));																		}						// Operators									this_t&				operator= (const this_t &ds)		{ std::memcpy(data_, ds.data_, alloc_size_*sizeof(scalar_t)); return *this; }				this_t&				resize(const extent_t &e)			{ return e; }					// do nothing, cause extent will be same as original								transpose_t			transpose(void) const				{ return transpose_t(data_, stride_t()); }template<class R2, class C2>				transpose_t			transpose(R2 r, C2 c) const			{ return transpose_t(ref(r,c), stride_t()); }						// Accessors									stride_t			stride(void) const					{ return stride_t(); }template<class R2, class C2>				scalar_t&			operator()(R2 r, C2 c)				{ return *(data_ + (r*C) + c); }template<class R2, class C2> 		  const scalar_t&			operator()(R2 r, C2 c) const		{ return *(data_ + (r*C) + c); }											// Iterators					template<class R2, class C2>				 row_it_t			row_it(R2 r, C2 c)					{ return  row_it_t(ref(r,c)); }template<class R2, class C2> 				crow_it_t			row_it(R2 r, C2 c) const			{ return crow_it_t(ref(r,c)); }template<class R2, class C2> 				 col_it_t			col_it(R2 r, C2 c)					{ return  col_it_t(ref(r,c), stride_t()); }template<class R2, class C2> 				ccol_it_t			col_it(R2 r, C2 c) const			{ return ccol_it_t(ref(r,c), stride_t()); }protected:        template<class Stride> friend class dense_transpose_structure;    template<class Stride> friend class dense_structure;template<class R2, class C2>				scalar_t*			ref(R2 r, C2 c)						{ return (data_ + (r*C) + c); }template<class R2, class C2>		  const scalar_t*			ref(R2 r, C2 c) const				{ return (data_ + (r*C) + c); }				private:				scalar_t			data_[R*C];};template<index_t R, index_t C, index_t R2, index_t C2> class structure_factory<small_structure<R,C>, coord_t<cindex<R2>, cindex<C2> > > {public:		typedef small_structure<R2,C2> structure_t;};} // namespace cf_algebra#endif /* __DENSE_STRUCTURE_H */