/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __VECTOR_RELATIONS_H#define __VECTOR_RELATIONS_H#include "vector-function.h"//#include "vector-function-tmpl.h"#include "cf-debug.h"namespace cf_algebra {/*1.				2.				3.*/class vector_relation {public:				typedef vector_relation			this_t;				typedef vector_function::q_t			q_t;				typedef vector_function::result_t	result_t;								vector_relation(const vector_function *r = NULL)	: relation_(r) {}								vector_relation(const this_t &r)			: relation_(r.relation_) {}virtual							~vector_relation(void)						{}				this_t&			operator= (const this_t &r)					{ relation_ = r.relation_; return *this; }								bool			operator==(const this_t& r) const			{ return (relation_ == r.relation_); }						  const vector_function* get_relation(void) const					{ return relation_; }virtual		std::ostream&		put(std::ostream &os) const					{ return (os << "vector relation"); }friend		std::ostream&		operator<<(std::ostream &os, const this_t &vr)	{ return vr.put(os); }protected:				void			set_relation(const vector_function *r)		{ AC_PRECONDITION(relation_ == NULL); relation_ = r; }		  		  const vector_function*		relation_;};class vector_position : public vector_relation {	// A unary relation relating a vector function to its initial valuepublic:				typedef vector_position				this_t;				typedef vector_relation				base_t;				typedef vector_function				vf_t;				typedef base_t::q_t					q_t;				typedef vf_t::result_t				value_t;								vector_position(const vf_t *vf,												const q_t &q)									: base_t(NULL), vector_function_(vf), original_value_(vf->result_size(q.height()), one, init_zero)									{									  vf->apply(original_value_, scalar1, q);									  const vector_function* r = this->make_relation();									  this->set_relation(r);										}virtual							~vector_position(void)						{ delete relation_; }				this_t&			operator= (const this_t &vp)				{																			  vector_function_ = vp.vector_function_; original_value_ = vp.original_value_; 																			  if (relation_) delete relation_; 																			  this->set_relation(this->make_relation());																			  return *this;																			}		  const vf_t*			get_vector_function(void) const				{ return vector_function_; }		  const value_t&		get_original_value(void) const				{ return original_value_; }		  virtual		std::ostream&		put(std::ostream &os) const					{ return (os << "vector position"); }protected:		  const vector_function* make_relation(void) const					{ return (vf_t::make_vf(adapt_vf(vector_function_) - adapt_vf(original_value_))); }		  const vf_t*			vector_function_;				value_t			original_value_;};class vector_difference : public vector_relation {	// a relation between two points and their initial difference vectorpublic:				typedef vector_difference		this_t;				typedef vector_relation			base_t;				typedef vector_function			vf_t;				typedef base_t::q_t				q_t;				typedef vf_t::result_t			value_t;								vector_difference(const vf_t* vf1,												const vf_t* vf2,												const q_t &q)									: base_t(NULL), vf1_(vf1), vf2_(vf2), original_distance_(vf1->result_size(q.height()), one, init_zero)									{									  vf1->apply(original_distance_, scalar1, q);										  vf2->apply(original_distance_, (scalar_t) -1, q);											  const vector_function* r = this->make_relation();									  this->set_relation(r);										}								vector_difference(const vf_t* vf1,												const vf_t* vf2,												const value_t &d,												const q_t &q)									: base_t(NULL), vf1_(vf1), vf2_(vf2), original_distance_(vf1->result_size(q.height()), one, init_zero)									{									  original_distance_ = d;									  const vector_function* r = this->make_relation();									  this->set_relation(r);										}virtual							~vector_difference(void)						{ delete relation_; }				this_t&			operator= (const this_t &vp)				{																			  vf1_ = vp.vf1_; vf2_ = vp.vf2_; original_distance_ = vp.original_distance_;																			  if (relation_) delete relation_; 																			  this->set_relation(this->make_relation());																			  return *this; 																			}		  const vf_t*			get_vector_function1(void) const			{ return vf1_; }		  const vf_t*			get_vector_function2(void) const			{ return vf2_; }virtual		std::ostream&		put(std::ostream &os) const					{ return (os << "vector difference"); }protected:		  const vector_function*		make_relation(void) const					{ return (vf_t::make_vf(adapt_vf(vf1_) - adapt_vf(vf2_) - adapt_vf(original_distance_))); }		  		  const vf_t*			vf1_;		  const vf_t*			vf2_;				value_t			original_distance_;};class vector_distance : public vector_relation {	// a relation between two points and their initial cartesian distancepublic:				typedef vector_distance			this_t;				typedef vector_relation			base_t;				typedef vector_function			vf_t;				typedef base_t::q_t				q_t;				typedef scalar_t				distance_t;								vector_distance(const vf_t* vf1,												const vf_t* vf2,												const q_t &q)									: base_t(NULL), vf1_(vf1), vf2_(vf2), original_distance_(scalar0)									{									  vf_t::result_size_t n = vf1->result_size(q.height());                                      AC_PRECONDITION(n == vf2->result_size(q.height()));									  vf_t::result_t diff(n, one, init_zero);									  									  vf1->apply(diff, scalar1, q);										  vf2->apply(diff, (scalar_t) -1, q);											  original_distance_ = norm_p2(diff);									  const vector_function* r = this->make_relation();									  this->set_relation(r);										}								vector_distance(const vf_t* vf1,												const vf_t* vf2,												const distance_t &d)									: base_t(NULL), vf1_(vf1), vf2_(vf2), original_distance_(d)									{									  const vector_function* r = this->make_relation();									  this->set_relation(r);										}virtual							~vector_distance(void)						{ delete relation_; }				this_t&			operator= (const this_t &vp)				{																			  vf1_ = vp.vf1_; vf2_ = vp.vf2_; original_distance_ = vp.original_distance_;																			  if (relation_) delete relation_; 																			  this->set_relation(this->make_relation());																			  return *this; 																			}		  const vf_t*			get_vector_function1(void) const			{ return vf1_; }		  const vf_t*			get_vector_function2(void) const			{ return vf2_; }virtual		std::ostream&		put(std::ostream &os) const					{ return (os << "vector distance"); }protected:		  const vector_function*		make_relation(void) const					{ return (vf_t::make_vf(adapt_vf(normp2_vf())(adapt_vf(vf1_) - adapt_vf(vf2_)) - adapt_vf(original_distance_))); }		  		  const vf_t*			vf1_;		  const vf_t*			vf2_;				distance_t		original_distance_;};} // namespace cf_algebra#endif /* __VECTOR_RELATIONS_H */