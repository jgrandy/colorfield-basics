/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __VECTOR_FUNCTION_H#define __VECTOR_FUNCTION_H#include "vector-function-prims.h"#include "vector-function-prims-tmpl.h"#include "matrix.h"#include "matrix-inst.h"#include "matrix-ops.h"#include <iostream>#include <list>namespace cf_algebra {// Basic Conventions//// each vector function has these three member functions://// void          apply      (result_t &r, const scalar_t &a, const q_t &q)// void          derive     (dfdq_t &dfdq, const scalar_t &a, const q_t &q)// result_size_t result_size(const q_size_t &q_size)//// The scalar value in apply() and derive() are applied to the function value, and// the result is *added* to the result or derivative argument:////   r    <-     r  +  a * f(q)//   dfdq <-  dfdq  +  a * dfdq(q)//// This scalar simplifies certain function composition code, in the same manner as do the// scalars in AXPY matrix operators.//// The function result_size() exists so that client code can pre-allocate result vectors before// invoking apply() or derive().//class vector_function;template<class VF> class generic_vf;class proxy_vf;template<class VF> class vf_wrapper;/*1.				2.					3.														4.*/class vector_function {	// The generic vector function has virtual evaluation functions, and has fully-specified input	// and output vector types.	public:		typedef vector_function		this_t;		typedef proxy_vf			proxy_t;				typedef matrixn1			q_t;		typedef matrixn1			result_t;		typedef matrixn				dfdq_t;				typedef q_t::height_t		q_size_t;		typedef result_t::height_t	result_size_t;virtual								~vector_function(void)									{}		template<class VF>static			generic_vf<VF>*		make_vf(const vf_wrapper<VF> &f)						{ return new generic_vf<VF>((const VF&) f); }			virtual			void				apply (result_t &r, const scalar_t &a, const q_t &q) const = 0;				void				apply (result_t &r, const q_t &q) const					{ this->apply(r, (scalar_t) 1, q); }virtual			void				derive(dfdq_t &dfdq, const scalar_t &a, const q_t &q) const = 0;virtual			void				apply_derive(result_t &r, dfdq_t &dfdq, const scalar_t &a, const q_t &q) const = 0;virtual	  const result_size_t		result_size(const q_size_t &q_size) const = 0;virtual			std::ostream&		put(std::ostream &os) const = 0;friend			std::ostream&		operator<<(std::ostream &os, const this_t &vf)			{ return vf.put(os); }template<class G>inline vf_wrapper<sum_vf<proxy_vf,double,G> >     operator+ (const vf_wrapper<G> &g) const;inline vf_wrapper<sum_vf<proxy_vf,double,proxy_vf> >									operator+ (const vector_function *gp) const;inline vf_wrapper<sum_vf<proxy_vf,double,proxy_vf> >									operator- (const vector_function *gp) const;			inline vf_wrapper<scaled_vf<float,proxy_vf> >									operator* (const float &v) const;inline vf_wrapper<scaled_vf<double,proxy_vf> > 									operator* (const double &v) const;template<class RS, class RL>inline vf_wrapper<composite_vf<range_vf<range_t<RS,RL> >, proxy_vf> >    operator[](const range_t<RS,RL> &r) const;inline vf_wrapper<composite_vf<proxy_vf,proxy_vf> >									operator()(const vector_function *g) const;template<class G>inline vf_wrapper<composite_vf<proxy_vf,G> >     operator()(const vf_wrapper<G> &g) const;};template<class VF> class generic_vf : public vector_function {				VF					fp_;public:		typedef generic_vf<VF>		this_t;		typedef vector_function		base_t;				typedef base_t::q_t			q_t;		typedef base_t::result_t	result_t;		typedef base_t::dfdq_t		dfdq_t;				typedef base_t::q_size_t	q_size_t;		typedef base_t::result_size_t result_size_t;												generic_vf(const VF &f)		 							: fp_(f) {}									generic_vf(const this_t &vf)							: fp_(vf.fp_) {}												this_t&				operator= (const this_t &vf)							{ fp_ = vf.fp_; return *this; }																	operator       VF&(void)								{ return fp_; }									operator const VF&(void) const							{ return fp_; }                                        operator vf_wrapper<this_t>(void)						{ return vf_wrapper<this_t>(*this); }									// these seem to work better than the type conversion operators above. why?				VF&					prim(void)												{ return fp_; }		  const VF&					prim(void) const										{ return fp_; }	  virtual			void				apply(result_t &r, const scalar_t &a, const q_t &q) const 						{ fp_.apply(r,a,q); }virtual			void				derive(dfdq_t &dfdq, const scalar_t &a, const q_t &q) const					{ fp_.derive(dfdq,a,q); }virtual			void				apply_derive(result_t &r, dfdq_t &dfdq, const scalar_t &a, const q_t &q) const	{ fp_.apply_derive(r,dfdq,a,q); }virtual	  const result_size_t		result_size(const q_size_t &q_size) const				{ return fp_.result_size(q_size); }virtual			std::ostream&		put(std::ostream &os) const								{ return (os << fp_); }};class proxy_vf : public vector_function {		  const vector_function*	fp_;public:		typedef proxy_vf			this_t;		typedef vector_function		base_t;				typedef base_t::q_t			q_t;		typedef base_t::result_t	result_t;		typedef base_t::dfdq_t		dfdq_t;				typedef base_t::q_size_t	q_size_t;		typedef base_t::result_size_t result_size_t;												proxy_vf(const vector_function* f)		 				: fp_(f) {}									proxy_vf(const this_t &vf)								: fp_(vf.fp_) {}								virtual								~proxy_vf(void)											{ fp_ = NULL; }						this_t&				operator= (const this_t &vf)							{ fp_ = vf.fp_; return *this; }												operator const vector_function*(void) const				{ return fp_; }                                        operator vf_wrapper<this_t>(void)						{ return vf_wrapper<this_t>(*this); }    virtual			void				apply(result_t &r, const scalar_t &a, const q_t &q) const						{ (*fp_).apply(r,a,q); }virtual			void				derive(dfdq_t &dfdq, const scalar_t &a, const q_t &q) const					{ (*fp_).derive(dfdq,a,q); }virtual			void				apply_derive(result_t &r, dfdq_t &dfdq, const scalar_t &a, const q_t &q) const	{ (*fp_).apply_derive(r,dfdq,a,q); }		  const result_size_t		result_size(const q_size_t &q_size) const				{ return (*fp_).result_size(q_size); }				std::ostream&		put(std::ostream &os) const								{ return (os << "proxy(" << (*fp_) << ')'); }};inline vf_wrapper<proxy_vf> adapt_vf(const vector_function *f){ return adapt_vf(proxy_vf(f)); }// OPERATOR()template<class VF>vf_wrapper<composite_vf<VF,proxy_vf> > vf_wrapper<VF>::operator()(const vector_function *g) const{ return adapt_vf(composite_vf<vf_t,proxy_vf>(f_,adapt_vf(g))); }template<class F>inline vf_wrapper<sum_vf<F,double,proxy_vf> > operator+ (const vf_wrapper<F> &f, const vector_function *gp)				{ return adapt_vf(sum_vf<F,double,proxy_vf>((const F&) f, +1.0, proxy_vf(gp))); }inline vf_wrapper<sum_vf<proxy_vf,double,proxy_vf> > vector_function::operator+ (const vector_function *gp) const{ return adapt_vf(sum_vf<proxy_vf,double,proxy_vf>(proxy_vf(this), +1.0, proxy_vf(gp))); }template<class G>inline vf_wrapper<sum_vf<proxy_vf,double,G> > operator- (const vector_function *fp, const vf_wrapper<G> &g)				{ return adapt_vf(sum_vf<proxy_vf,double,G>(adapt_vf(fp), -1.0, (const G&) g)); }template<class F>inline vf_wrapper<sum_vf<F,double,proxy_vf> > operator- (const vf_wrapper<F> &f, const vector_function *gp)				{ return adapt_vf(sum_vf<F,double,proxy_vf>((const F&) f, -1.0, adapt_vf(gp))); }template<class G>inline vf_wrapper<sum_vf<proxy_vf,double,G> >vector_function::operator+ (const vf_wrapper<G> &g) const{ return adapt_vf(sum_vf<proxy_vf,double,G>(proxy_vf(this), +1.0, (const G&) g)); }template<class RS, class RL>inline vf_wrapper<composite_vf<range_vf<range_t<RS,RL> >, proxy_vf> >vector_function::operator[](const range_t<RS,RL> &r) const{ return adapt_vf(composite_vf<range_vf<range_t<RS,RL> >, proxy_vf>(range_vf<range_t<RS,RL> >(r), proxy_vf(this))); }template<class G>inline vf_wrapper<composite_vf<proxy_vf,G> >vector_function::operator()(const vf_wrapper<G> &g) const{ return adapt_vf(composite_vf<proxy_vf,G>(proxy_vf(this),(const G&)g)); }inline vf_wrapper<sum_vf<proxy_vf,double,proxy_vf> > vector_function::operator- (const vector_function *gp) const		{ return adapt_vf(sum_vf<proxy_vf,double,proxy_vf>(adapt_vf(this), -1.0, adapt_vf(gp))); }inline vf_wrapper<scaled_vf<float,proxy_vf> > vector_function::operator* (const float &v) const{ return adapt_vf(scaled_vf<float ,proxy_vf>(proxy_vf(this), v)); }inline vf_wrapper<scaled_vf<double,proxy_vf> > vector_function::operator* (const double &v) const{ return adapt_vf(scaled_vf<double,proxy_vf>(proxy_vf(this), v)); }inline vf_wrapper<composite_vf<proxy_vf,proxy_vf> > vector_function::operator()(const vector_function *g) const{ return adapt_vf(composite_vf<proxy_vf,proxy_vf>(adapt_vf(this), adapt_vf(g))); }} // namespace cf_algebra#endif /* __VECTOR_FUNCTION_H */