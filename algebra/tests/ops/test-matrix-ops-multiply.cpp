/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1995 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#include "matrix-inst.h"#include "matrix-ops.h"#include "matrix-ops-multiply-tmpl.h"using namespace cf_algebra;namespace cf_algebra {template matrixn&  matrix_multiply(matrixn&, const matrixn&, const matrixn&);template matrixn1& matrix_multiply(matrixn1&, const matrixn&, const matrixn1&);template scalar_t&    matrix_multiply(scalar_t&, const matrix1n&, const matrixn1&);template matrix33& matrix_multiply(matrix33&, const matrix34&, const matrix43&);template matrix31& matrix_multiply(matrix31&, const matrix33&, const matrix31&);template scalar_t&    matrix_multiply(scalar_t&,    const matrix13&, const matrix31&);}void test_multiply(void);namespace {	void test_general_multiply1(void)	{		{			matrixn dm1(3,4), dm2(4,3), dm3(3,3);						dm1 = (scalar_t) 1.0;						dm2 = (scalar_t) 2.0;						matrix_multiply(dm3, dm1, dm2);						FAILFALSE(dm3(0,0) == 8.0)			FAILFALSE(dm3(1,2) == 8.0)		}	}	void test_general_multiply2(void)	{		{			matrixn dm1(2,2), dm2(2,2), dm3(2,2);			dm1(0,0) = (scalar_t)  2.0;		dm1(0,1) = (scalar_t) -2.0;			dm1(1,0) = (scalar_t) -2.0;		dm1(1,1) = (scalar_t)  5.0;						dm2(0,0) = (scalar_t) (5.0 / 6.0);	dm2(0,1) = (scalar_t) (1.0 / 3.0);			dm2(1,0) = (scalar_t) (1.0 / 3.0);	dm2(1,1) = (scalar_t) (1.0 / 3.0);						matrix_multiply(dm3, dm1, dm2);			FAILTRUE(fabs(dm3(0,0) - 1.0) > 1.0e-5)			FAILTRUE(fabs(dm3(0,1)) > 1.0e-5)			FAILTRUE(fabs(dm3(1,0)) > 1.0e-5)			FAILTRUE(fabs(dm3(1,1) - 1.0) > 1.0e-5)		}	}	void test_vector_matrix_multiply(void)	{		matrixn1 dcv(3,one);		matrixn dm(3,3);				dcv(0,0) = 2.0f;		dcv(1,0) = 3.0f;		dcv(2,0) = 5.0f;				dm = 0.0f;				dm(0,0) = 1.0f;		dm(1,1) = 1.0f;		dm(2,2) = 1.0f;				matrixn1 result(3, one);				matrix_multiply(result, dm, dcv);		FAILFALSE(result(0,0) == 2.0f)		FAILFALSE(result(1,0) == 3.0f)		FAILFALSE(result(2,0) == 5.0f)					dm = 0.0f;		dm(0,2) = 1.0f;		dm(1,1) = 1.0f;		dm(2,1) = 1.0f;				matrix_multiply(result, dm, dcv);		FAILFALSE(result(0,0) == 5.0f)		FAILFALSE(result(1,0) == 3.0f)		FAILFALSE(result(2,0) == 3.0f)					matrixn_T dm_T = dm.transpose();				matrix_multiply(result, dm_T, dcv);		FAILFALSE(result(0,0) == 0.0f)		FAILFALSE(result(1,0) == 8.0f)		FAILFALSE(result(2,0) == 2.0f)		}	void test_inner_product(void)	{		matrix1n drv(one, 3);		matrixn1 dcv(3, one);		drv(0,0) = (scalar_t) 1.;		drv(0,1) = (scalar_t) 2.;		drv(0,2) = (scalar_t) 3.;				dcv(0,0) = (scalar_t) 4.;		dcv(1,0) = (scalar_t) 5.;		dcv(2,0) = (scalar_t) 6.;				scalar_t result;		matrix_multiply(result, drv, dcv);				FAILNEQ(result, 4. + 10. + 18.)					matrixn dm(3,3);		dm = (scalar_t) 0.;				dm(1,0) = (scalar_t) 1.;		dm(1,1) = (scalar_t) 2.;		dm(1,2) = (scalar_t) 3.;				dm(0,1) = (scalar_t) 4.;		dm(2,1) = (scalar_t) 6.;				matrixn::row_t dm_r2 = dm.row(one);		matrixn::col_t dm_c2 = dm.column(one);		matrix_multiply(result, dm_r2, dm_c2);		FAILNEQ(result, 4. + 4. + 18.)				matrixn::row_t dm_r1 = dm.row(one);		matrixn::col_t dm_c1 = dm.column(one);		matrix_multiply(result, dm_r1, dm_c1);		FAILNEQ(result, 4. + 4. + 18.)		#if 0		vectorn_T dmt = dm.transpose();				matrix_multiply(result, dmt, dm);				FAILFALSE(result = (1. + 4. + 9.))#endif	}	void test_outer_product(void)	{		matrix1n drv(one_t(), 3);		matrixn1 dcv(3, one_t());				dcv(0,0) = (scalar_t) 1.0;		dcv(1,0) = (scalar_t) 2.0;		dcv(2,0) = (scalar_t) 3.0;				drv(0,0) = (scalar_t) 4.0;		drv(0,1) = (scalar_t) 5.0;		drv(0,2) = (scalar_t) 6.0;				matrixn dm(3,3);		matrix_multiply(dm, dcv, drv);		FAILFALSE(dm(0,0) == 1.0 * 4.0)		FAILFALSE(dm(0,1) == 1.0 * 5.0)		FAILFALSE(dm(0,2) == 1.0 * 6.0)		FAILFALSE(dm(1,0) == 2.0 * 4.0)		FAILFALSE(dm(1,1) == 2.0 * 5.0)		FAILFALSE(dm(1,2) == 2.0 * 6.0)		FAILFALSE(dm(2,0) == 3.0 * 4.0)		FAILFALSE(dm(2,1) == 3.0 * 5.0)		FAILFALSE(dm(2,2) == 3.0 * 6.0)	}}void test_multiply(void){	test_general_multiply1();	test_general_multiply2();	test_vector_matrix_multiply();	test_inner_product();	test_outer_product();}