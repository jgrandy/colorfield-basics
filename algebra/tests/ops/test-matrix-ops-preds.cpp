/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1995 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#include "matrix-inst.h"#include "matrix-ops.h"#include "matrix-ops-preds-tmpl.h"#include "matrix-ops-update-tmpl.h"using namespace cf_algebra;#pragma inline_depth(10)void test_predicates(void);namespace cf_algebra {template bool has_nan(const matrixn &A);template scalar_t norm_p2(const matrixn &A);template scalar_t norm_maxabs(const matrixn &A);template bool operator==(const matrixn &A, const matrixn &B);template bool operator!=(const matrixn &A, const matrixn &B);template bool operator==(const matrixn &A, const scalar_t &val);template bool operator!=(const matrixn &A, const scalar_t &val);}namespace {	void test_metrics(void)	{			}			void test_equality(void)	{		matrixn dm1(2,2),				dm2(2,2);				dm1(0,0) = 0.0f; dm1(0,1) = 0.0f;		dm1(1,0) = 0.0f; dm1(1,1) = 0.0f;				FAILFALSE(dm1 == 0.0f)		FAILTRUE (dm1 != 0.0f)				dm1(0,0) = 1.0f;		dm1(1,1) = 2.0f;		FAILTRUE (dm1 == 0.0f)		FAILFALSE(dm1 != 0.0f)				dm2(0,0) = dm1(0,0); dm2(0,1) = dm1(0,1);		dm2(1,0) = dm1(1,0); dm2(1,1) = dm1(1,1);		FAILFALSE(dm2 == dm1)		FAILTRUE (dm2 != dm1)					dm2(1,1) = 3.1415f;		FAILTRUE (dm2 == dm1)		FAILFALSE(dm2 != dm1)	}}void test_predicates(void){	test_metrics();	test_equality();}