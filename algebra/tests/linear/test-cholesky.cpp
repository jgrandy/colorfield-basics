/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1995 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#include "cholesky.h"#include "cholesky.tmpl.h"#include "matrix-io.h"#include "matrix-inst.h"#include "matrix-ops.h"#include <math.h>#pragma inline_depth(12)using namespace cf_algebra;using std::clog;using std::endl;namespace cf_algebra {template class cholesky_solver<matrixn, matrixn1, matrixn1>;}void test_cholesky(void);void test_cholesky(void){		{				cholesky_solver<matrixn,matrixn1,matrixn1> ch(two);				matrixn M(two, two), Minv(two, two), tmp(two,two);				M(0,0) = (scalar_t) 2.;	M(0,1) = (scalar_t)-2.;		M(1,0) = (scalar_t)-2.;	M(1,1) = (scalar_t) 5.;				clog << "Problem 1" << endl;		clog << "original: " << M << endl;		{			tmp = M;			matrixn1 p(two,one);			ch.decompose(tmp, p);						clog << "decomposed: " << tmp << " " << p << endl;			FAILNEQ(tmp(1,0), - sqrt(2.))			FAILNEQ(  p(0,0),   sqrt(2.))			FAILNEQ(  p(1,0),   sqrt(3.))		}				tmp = M;		ch.invert(Minv, tmp);				clog << "inverted: " << Minv << endl;		matrix_multiply(tmp, M, Minv);				clog << "multiplied by inverse: " << tmp << endl;				FAILNEQ(tmp(0,0), 1.)	FAILNEQ(tmp(0,1), 0.)		FAILNEQ(tmp(1,0), 0.)	FAILNEQ(tmp(1,1), 1.)		clog << "...passed" << endl;	}	{		cholesky_solver<matrixn,matrixn1,matrixn1> ch(three);		matrixn M(three,three), W(three,three), tmp(three,three);				M(0,0) =  20.6481;  M(0,1) = -21.5834; M(0,2) =  0;		M(1,0) = -21.5834;  M(1,1) =  28.5029; M(1,2) = -5.23353 ;		M(2,0) =  0;        M(2,1) = -5.23353; M(2,2) =  8.22021 ;			clog << "Problem 2" << endl;		clog << "original: " << M << endl;				{			tmp = M;			matrixn1 p(three,one);			ch.decompose(tmp, p);						clog << "decomposed: " << tmp << " " << p << endl;		}				tmp = M;		ch.invert(W, tmp);				clog << "inverted: " << W << endl;		matrix_multiply(tmp, M, W);				clog << "multiplied by inverse: " << tmp << endl;				FAILNEQ(tmp(0,0), 1.)	FAILNEQ(tmp(0,1), 0.)  FAILNEQ(tmp(0,2), 0.)		FAILNEQ(tmp(1,0), 0.)	FAILNEQ(tmp(1,1), 1.)  FAILNEQ(tmp(1,2), 0.)		FAILNEQ(tmp(2,0), 0.)	FAILNEQ(tmp(2,1), 0.)  FAILNEQ(tmp(2,2), 1.)		clog << "...passed" << endl;	}}