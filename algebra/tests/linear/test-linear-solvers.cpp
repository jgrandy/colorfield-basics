/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1995 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#if 0/*--------------------------------------------------------------------------- Algo3-3.c   C program for implementing Algorithm 3.3 Algorithm translated to  C  by: Dr. Norman Fahrer IBM and Macintosh verification by: Daniel Mathews  NUMERICAL METHODS: C Programs, (c) John H. Mathews 1995 To accompany the text: NUMERICAL METHODS for Mathematics, Science and Engineering, 2nd Ed, 1992 Prentice Hall, Englewood Cliffs, New Jersey, 07632, U.S.A. Prentice Hall, Inc.; USA, Canada, Mexico ISBN 0-13-624990-6 Prentice Hall, International Editions:   ISBN 0-13-625047-5 This free software is compliments of the author. E-mail address:       in%"mathews@fullerton.edu"  Algorithm 3.3 (PA = LU Factorization with Pivoting). Section   3.6, Triangular Factorizaton, Page 175---------------------------------------------------------------------------*//*--------------------------------------------------------------------------- Algorithm 3.3 ( PA = LU Factorization with Pivoting). To construct the solution to the linear system  AX = B  by performing the steps : 1. Find a permutation matrix  P, lower-triangular matrix  L,    and upper-triangular matrix  U  that satisfy:           PA = LU.  2. Computer PB and form the equivalent linear system         LUX = PB. 3. Solve the lower-triangular system         LY = PB   for  Y. 4. Solve the upper-triangular system         UX = Y    for  X.  Remarks : This algorithm is an extension of Algorithm 3.2.            since the diagonal elements of  L  are all 1's, these           values do not need to be stored. The coefficients           of  L  below the main diagonal and the nonzero coefficients            of  U  overwrite the matrix  A.---------------------------------------------------------------------------*/#include<stdio.h>#include<stdlib.h>#include<math.h>/* -------------------------------------------------------- *//*  Main program for algorithm 3.2  *//*  remember : in C the fields begin with element 0  */#define Limit  20int main(void){    int K, P, C, J;                  /* Loop counters               */    double A[Limit][Limit];          /* A in  AX = B ,  INPUT       */    double B[Limit];                 /* B in  AX = B ,  INPUT       */    double Y[Limit];                 /* See description above       */      int N;                           /* Number of equations , INPUT */       int    Row[Limit];               /* Field with row-number       */    double X[Limit];                 /* Solution-vector             */    double SUM, DET = 1.0;                                                           int  T;                                       printf("Try the examples on page 157.. of the book !\n");    printf("------------------------------------------\n");    do  /* Force proper INPUT */    {      printf("Please enter number of equations [Not more than %d]\n",Limit);      scanf("%d", &N);    } while( N > Limit);    printf("You say there are %d equations.\n", N);    printf("-----------------------------------------------------\n");    printf("-----------------------------------------------------\n");    printf("From  AX = B enter elements of A row by row:\n");    printf("-----------------------------------------------------\n");    for (K = 1; K <= N; K++)    {        for (J = 1; J <= N; J++)        {             printf(" For row %d enter element %d please :\n", K, J);             scanf("%lf", &A[K-1][J-1]);              printf(" You entered : %lf \n", A[K-1][J-1] );             printf("------------------------------------------\n");        }    }    /* Initialize the pointer vector */    for (J = 1; J<= N; J++) Row[J-1] = J - 1;    /* Start LU factorization */    for (P = 1; P <= N - 1; P++)    {    /* Find pivot element */        for (K = P + 1; K <= N; K++)      {        if ( fabs(A[Row[K-1]][P-1]) > fabs(A[Row[P-1]][P-1]) )        {        /* Switch the index for the p-1 th pivot row if necessary */            T        = Row[P-1];           Row[P-1] = Row[K-1];           Row[K-1] = T;           DET      = - DET;         }      } /* End of simulated row interchange */        if (A[Row[P-1]][P-1] == 0)        {              printf("The matrix is SINGULAR !\n");           printf("Cannot use algorithm --> exit\n");           exit(1);        }     /* Multiply the diagonal elements */          DET = DET * A[Row[P-1]][P-1];     /* Form multiplier */     for (K = P + 1; K <= N; K++)     {        A[Row[K-1]][P-1]= A[Row[K-1]][P-1] / A[Row[P-1]][P-1];             /* Eliminate X_(p-1) */       for (C = P + 1; C <= N + 1; C++)       {          A[Row[K-1]][C-1] -= A[Row[K-1]][P-1] * A[Row[P-1]][C-1];       }     }   } /* End of  L*U  factorization routine */    for (P = 1; P <= N; P++)    	for( K = 1; K <= N; K++)  printf("A[%d][%d] = %lf\n", P, K, A[Row[P-1]][K-1]);     for( K = 1; K <= N; K++)  printf("perm[%d] = %d\n", K, Row[K-1]);     DET = DET * A[Row[N-1]][N-1];    /* Input the column vector now : */    printf("You say there are %d equations.\n", N);    printf("-----------------------------------------------------\n");    printf("From  AX = B enter components of vector B one by one:\n");    for (K = 1; K <= N; K++)    {        printf("Enter %d st/nd/rd component of vector B\n", K);        scanf("%lf", &B[K-1]);        printf("You entered %lf\n", B[K-1]);    }    /* Start the forward substitution */    Y[0] = B[Row[0]];     for ( K = 2; K <= N; K++)    {      SUM =0;      for ( C = 1; C <= K -1; C++) SUM += A[Row[K-1]][C-1] * Y[C-1];      printf("sum: %lf", SUM);      Y[K-1] = B[Row[K-1]] - SUM;    }      if( A[Row[N-1]][N-1] == 0)    {      printf("The matrix is SINGULAR !\n");      printf("Cannot use algorithm --> exit\n");      exit(1);    }          for( K = 1; K <= N; K++)  printf("Y[%d] = %lf\n", K, Y[K-1]);     /* Start the back substitution */       X[N-1] = Y[N-1] / A[Row[N-1]][N-1];    for (K = N - 1; K >= 1; K--)    {      SUM = 0;      for (C = K + 1; C <= N; C++)      {           SUM += A[Row[K-1]][C-1] * X[C-1];         }      X[K-1] = ( Y[K-1] - SUM) / A[Row[K-1]][K-1];    }  /* End of back substitution */    /* Output */    printf("---------------------------------------------------:\n");    printf("The components of the vector with the solutions are:\n");    for( K = 1; K <= N; K++)  printf("X[%d] = %lf\n", K, X[K-1]);     } #else#include <iostream>void test_conjugate_gradient(void);void test_lu_decomp(void);void test_cholesky(void);int test_linear_solvers(void){	try {		std::clog << std::endl << "testing Cholesky" << std::endl;		test_cholesky();	} catch(...) {		std::clog << "cholesky failed" << std::endl;	}	try {		std::clog << std::endl << "testing Conjugate Gradient" << std::endl;		test_conjugate_gradient();	} catch(...) {		std::clog << "conjugate-gradient failed" << std::endl;	}	try {		std::clog << std::endl << "testing LU decomposition" << std::endl;		test_lu_decomp();	} catch(...) {		std::clog << "LU decomposition failed" << std::endl;	}		return 0;}#endif