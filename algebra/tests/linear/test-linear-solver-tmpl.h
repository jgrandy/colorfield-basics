/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1995 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __TEST_LINEAR_SOLVER_TMPL_H#define __TEST_LINEAR_SOLVER_TMPL_H#include "linear-solver.h"#include "matrix-inst.h"#include "matrix-ops.h"#include "matrix-io.h"#include <math.h>using std::clog;using std::endl;namespace cf_algebra {template<class N, class Structure1, class Structure2>static void signal_diff(      matrix<coord_t<N,one_t>,Structure1> &result, 						const matrix<coord_t<N,one_t>,Structure2> &expected_result, 						const scalar_t &tolerance){	result -= expected_result;	if (norm_maxabs(result) > (norm_maxabs(expected_result) * tolerance)) {		clog << endl << "diff: " << result << endl;		throw 0;	}}template<class T_solver>void test1(void){	clog << endl << "test 1" << endl;		try {		T_solver s(four);				matrixn1	x1(four,one), b1(four,one);		matrixn		A(four,four);				A = 0.0;		set_diagonal(A, (scalar_t) 0.5);				b1 = 3.14159;				s.solve(A, x1, b1);				b1 = 3.14159 * 2.0;				signal_diff(x1,b1,0.00001);	} catch(...) {		clog << "...failed" << endl;	}}template<class T_solver>void test2(void){	clog << endl << "test 2" << endl;		try {		T_solver s(2);			matrixn1	x(2,one), bv(2,one), xr(2,one);		matrixn  A(2,2), Ainv(2,2), I(2,2);				const scalar_t a = 2,					b = 1,					c = 3,					div =  (a*c) - (b*b);					 		A(0,0) = a;		A(1,0) = A(0,1) = b;		A(1,1) = c;				Ainv(0,0) =   c / div;		Ainv(0,1) = - b / div;		Ainv(1,0) = - b / div;		Ainv(1,1) =   a / div;				matrix_multiply(I, A, Ainv);				bv(0,0) = 3;		bv(1,0) = 5;				s.solve(A,x,bv);				matrix_multiply(xr,Ainv,bv);		//		clog << "expected: " << xr << endl;//		clog << "actual:   " << x  << endl;				signal_diff(x,xr,0.00001);	} catch(...) {		clog << "failed 2x2 symmetric" << endl;	}}template<class T_solver>void test3(void){	clog << endl << "test 3" << endl;		try {		T_solver s(four);			scalar_t lhs_data[] =			{ 1.30,  1.14,  0.00,  0.00,			  1.14,  2.00,  0.50, -0.86,			  0.00,  0.50,  1.00,  0.00,			  0.00, -0.86,  0.00,  1.00 };		scalar_t rhs_data[] =			{  0.0203,			  -0.0123,			   0.0010,			   0.0045 };				scalar_t x_data[] = 			{ 2.204836, -2.496520, 1.249240, -2.142527 };		matrixn	 A(four, four, lhs_data);		matrixn1 x(four, one), 				 b(four, one,  rhs_data);				s.solve(A,x,b);		matrixn1 x_expected(four, one, x_data);		signal_diff(x,x_expected,0.0001);	} catch (...) {		clog << "...failed" << endl;	}}template<class T_solver>void test4(void){	clog << endl << "test 4" << endl;		try {			T_solver s(four);		scalar_t lhs_data[] =			{  0.1538,  0.0735, -0.0584,  0.0735,			   0.0735,  0.0457, -0.0361,  0.0457,			  -0.0584, -0.0361,  0.0344, -0.0361,			   0.0735,  0.0457, -0.0361,  0.0457 };		scalar_t rhs_data[] =			{ -0.000137,			   0.000636,			   0.0,			   0.0 };			   		scalar_t x_data[] = 			{ -0.0039, 6.36, -0.0002, -6.3540 };		matrixn	A(four, four, lhs_data);		matrixn1 x(four, one), 				 b(four, one,  rhs_data);				s.solve(A,x,b);		matrixn1 x_expected(four, one, x_data);				signal_diff(x,x_expected,0.0001);			} catch(...) {		clog << "...failed" << endl;	}}template<class T_solver>void test_linear_solver(void){	test1<T_solver>();		test2<T_solver>();			test3<T_solver>();			test4<T_solver>();	}} // namespace cf_algebra#endif /* __TEST_LINEAR_SOLVER_TMPL_H */