/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1995 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#include "vector-function.h"#include "matrix-inst.h"#include "matrix-ops-tmpl.h"#include "matrix-io.h"#include <iostream>using std::clog;using std::endl;using std::ostringstream;using std::exception;using std::logic_error;namespace cf_algebra {template class constant_vf<matrixn1>;template class range_vf<>;template class composite_vf<identity_vf,identity_vf>;template class sum_vf<identity_vf,scalar_t,identity_vf>;template class scaled_vf<identity_vf,scalar_t>;template class wrapped_vf<scalar_t>;//template class stacked_vf<vector_function<matrixn1> >;template class vf_wrapper<identity_vf>;template class generic_vf<identity_vf>;}using namespace cf_algebra;typedef vector_function vf_t;namespace {	// check compilation of various vector-function typesconst identity_vf q;#if 0const vf_wrapper<identity_vf> wq(identity_vf());const sum_vf<identity_vf,double,identity_vf> twice_q = wq + wq;const sum_vf<identity_vf,double,identity_vf> no_q    = wq - wq;const scaled_vf<double,identity_vf> scaled_q = wq * 0.5;const composite_vf<range_vf<range_t<> >, identity_vf> part_q = wq[range(0,1)];const composite_vf<identity_vf,identity_vf> identity = wq(wq);const generic_vf<identity_vf> gq(q);const composite_vf<generic_vf<identity_vf>,generic_vf<identity_vf> > gidentity = adapt_vf(gq)(adapt_vf(gq));#endif	// generic vector function test harnesstemplate<class VF, class q_t, class result_t, class dfdq_t> void test_function(const VF f, 				   const q_t &q, 				   const result_t &expected_result, const dfdq_t &expected_dfdq,				   const scalar_t tolerance){	result_t actual_result(expected_result.extent(), init_zero);	dfdq_t   actual_dfdq  (expected_dfdq.extent(), init_zero);		clog << "testing " << f << " over " << q << endl;	try {		actual_result = (scalar_t) 0.0;		f.apply(actual_result, 1, q);				actual_result -= expected_result;		if (norm_maxabs(actual_result) > tolerance) {			ostringstream ost;			ost << "...f.apply() failed." << endl;			ost << " expected: " << expected_result << endl;			ost << " delta: " << actual_result;			throw logic_error(ost.str());		}						actual_dfdq = (scalar_t) 0.0;		f.derive(actual_dfdq, 1, q);				actual_dfdq -= expected_dfdq;		if (norm_maxabs(actual_dfdq) > tolerance) {			ostringstream ost;			ost << "...f.derive() failed." << endl;			ost << " expected: " << expected_dfdq << endl;			ost << " delta: " << actual_dfdq;			throw logic_error(ost.str());		}						actual_result = (scalar_t) 0.0;		actual_dfdq = (scalar_t) 0.0;		f.apply_derive(actual_result, actual_dfdq, 1, q);				actual_result -= expected_result;		if (norm_maxabs(actual_result) > tolerance) {			ostringstream ost;			ost << "...f.apply() failed (result)." << endl;			ost << " expected: " << expected_result << endl;			ost << " delta: " << actual_result;			throw logic_error(ost.str());		}				actual_dfdq -= expected_dfdq;		if (norm_maxabs(actual_dfdq) > tolerance) {			ostringstream ost;			ost << "...f.apply_derive() failed (dfdq)." << endl;			ost << " expected: " << expected_dfdq << endl;			ost << " delta: " << actual_dfdq;			throw logic_error(ost.str());		}				clog << " ...ok" << endl;		} catch(exception &exc) {		clog << " ...failed: " << exc.what() << endl;	}}void test_basic_static_functions(void){	clog << "testing basic static functions" << endl;    	matrixn1 q(three, one);	matrixn1 r3(three, one),			 r2(two, one),			 r1(one, one);	matrixn dfdq3(three, three);		q(0,0) = 1.0f;	q(1,0) = 2.0f;	q(2,0) = 3.0f;		dfdq3 = 0.0f;	set_diagonal(dfdq3, 1.0f);	#if 0	const identity_vf qf;	const vf_wrapper<identity_vf> wqf(qf);		test_function(qf, q, q, dfdq3, 0.0001f);	test_function(wqf[range(1,2)], q, q.rows(range(1,2)), dfdq3.rows(range(1,2)), 0.0001f);		r3(0,0) = 2.0f;	r3(1,0) = 4.0f;	r3(2,0) = 6.0f;		set_diagonal(dfdq3, 2.0f);		test_function(wqf+wqf, q, r3, dfdq3, 0.0001f);		test_function(wqf*2.0f, q, r3, dfdq3, 0.0001f);		r3 = 0.0f;	dfdq3 = 0.0f;		test_function(wqf-wqf, q, r3, dfdq3, 0.0001f);#endif    clog << " ...ok" << endl;}void test_dynamic_composition(void){	clog << "testing dynamic composition" << endl;	    matrixn1 q(three, one);	matrixn1 r3(three, one),			 r2(two, one),			 r1(one, one);	matrixn dfdq3(three, three);		q(0,0) = 1.0f;	q(1,0) = 2.0f;	q(2,0) = 3.0f;		dfdq3 = 0.0f;	set_diagonal(dfdq3, 1.0f);	#if 0	const identity_vf qf;		const generic_vf<identity_vf> gqf(qf);		test_function(gqf, q, q, dfdq3, 0.0001f);		test_function(adapt_vf(gqf)[range(1,2)], q, q.rows(range(1,2)), dfdq3.rows(range(1,2)), 0.0001f);	proxy_vf pqf(&gqf);		test_function(pqf, q, q, dfdq3, 0.0001f);#endif    clog << " ...ok" << endl;}void test_linear_vf(void){	clog << "testing linear_vf" << endl;	typedef map_vf<3> linear_vf_t;		matrixn1 q(three, one), 	         r(three, one, init_zero);	matrixn  m(three,three, init_zero);	matrixn  dm(three, three, init_zero);		set_diagonal(m, 1.0f);		linear_vf_t lf(m);		q(zero,zero) = 1.0f; q(one,zero) = 2.0f; q(two,zero) = 3.0f;	r = q;	dm = m;		test_function(lf, q, r, dm, 0.0001f);	    clog << " ...ok" << endl;}void test_dot_vf(void){	clog << "testing dot_vf" << endl;	typedef dot_vf<identity_vf,identity_vf> id_dot_t;	matrixn1 q(three, one), 	         r(one, one);	matrixn  dd(one, three, init_zero);	q = 1.0f;	const identity_vf qf;		id_dot_t(qf, qf);    clog << " ...ok" << endl;}} // anonymous namespaceint test_vector_functions(void){	test_basic_static_functions();	test_dynamic_composition();		test_linear_vf();		test_dot_vf();        clog << endl;        return 0;}