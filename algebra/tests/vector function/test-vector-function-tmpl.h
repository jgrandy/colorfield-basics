/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1995 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __TEST_VECTOR_FUNCTION_TMPL_H#define __TEST_VECTOR_FUNCTION_TMPL_H#include "vector-function.h"namespace {template<class VF, class q_t, class result_t, class dfdq_t> void test_function(const VF f, 				   const q_t &q, 				   const result_t &expected_result, const dfdq_t &expected_dfdq,				   const result_t::elem_t tolerance){	result_t actual_result(expected_result.extent(), init_zero);	dfdq_t   actual_dfdq  (expected_dfdq.extent(), init_zero);		clog << "testing " << f << " over " << q << endl;	try {		actual_result = (result_t::elem_t) 0.0;		f.apply(actual_result, 1, q);				actual_result -= expected_result;		if (norm_maxabs(actual_result) > tolerance) {			ostringstream ost;			ost << "...f.apply() failed." << endl;			ost << " expected: " << expected_result << endl;			ost << " delta: " << actual_result;			throw logic_error(ost.str());		}						actual_dfdq = (result_t::elem_t) 0.0;		f.derive(actual_dfdq, 1, q);				actual_dfdq -= expected_dfdq;		if (norm_maxabs(actual_dfdq) > tolerance) {			ostringstream ost;			ost << "...f.derive() failed." << endl;			ost << " expected: " << expected_dfdq << endl;			ost << " delta: " << actual_dfdq;			throw logic_error(ost.str());		}						actual_result = (result_t::elem_t) 0.0;		actual_dfdq = (result_t::elem_t) 0.0;		f.apply_derive(actual_result, actual_dfdq, 1, q);				actual_result -= expected_result;		if (norm_maxabs(actual_result) > tolerance) {			ostringstream ost;			ost << "...f.apply() failed (result)." << endl;			ost << " expected: " << expected_result << endl;			ost << " delta: " << actual_result;			throw logic_error(ost.str());		}				actual_dfdq -= expected_dfdq;		if (norm_maxabs(actual_dfdq) > tolerance) {			ostringstream ost;			ost << "...f.apply_derive() failed (dfdq)." << endl;			ost << " expected: " << expected_dfdq << endl;			ost << " delta: " << actual_dfdq;			throw logic_error(ost.str());		}				clog << " ...ok" << endl;		} catch(exception &exc) {		clog << " ...failed: " << exc.what() << endl;	}}} // namespace <anonymous>#endif /* __TEST_VECTOR_FUNCTION_TMPL_H */