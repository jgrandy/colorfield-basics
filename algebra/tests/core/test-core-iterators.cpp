/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1995 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#include "matrix-inst.h"#include "cf-debug.h"using namespace cf_algebra;void test_small_iterators(void);void test_dense_iterators(void);void test_dense_transpose_iterators(void);void test_small_iterators(void){	matrix23 m23(two,three);			m23(one,zero) = 3.0f; m23(one,one) = 4.0f; m23(one,two) = 5.0f;		matrix23::row_it_t rit = m23.row_it(one);		for (int i=0; i<3; i++) {		*rit = (scalar_t) i;		++rit;	}		FAILFALSE(m23(one,zero) == 0.0f)  FAILFALSE(m23(one,one) == 1.0f)	FAILFALSE(m23(one,two) == 2.0f)		const matrix23 &cm23 = m23;		matrix23::crow_it_t crit = cm23.row_it(one);		for (int i=0; i<3; i++) {		FAILFALSE(*crit == (scalar_t) i)		++crit;	}	m23(zero,two) = 3.0f; m23(one,two) = 4.0f;		matrix23::col_it_t cit = m23.col_it(two);		for (int i=0; i<2; i++) {		*cit = (scalar_t) i;		++cit;	}		FAILFALSE(m23(zero,two) == 0.0f) FAILFALSE(m23(one,two) == 1.0f)		matrix23::ccol_it_t ccit = cm23.col_it(two);		for (int i=0; i<2; i++) {		FAILFALSE(*ccit == (scalar_t) i)		++ccit;	}}void test_dense_iterators(void){	matrixn m23(two,three);			m23(one,zero) = 3.0f; m23(one,one) = 4.0f; m23(one,two) = 5.0f;		matrixn::row_it_t rit = m23.row_it(one);		for (int i=0; i<3; i++) {		*rit = (scalar_t) i;		++rit;	}		FAILFALSE(m23(one,zero) == 0.0f)  FAILFALSE(m23(one,one) == 1.0f)	FAILFALSE(m23(one,two) == 2.0f)		const matrixn &cm23 = m23;		matrixn::crow_it_t crit = cm23.row_it(one);		for (int i=0; i<3; i++) {		FAILFALSE(*crit == (scalar_t) i)		++crit;	}	m23(zero,two) = 3.0f; m23(one,two) = 4.0f;		matrixn::col_it_t cit = m23.col_it(two);		for (int i=0; i<2; i++) {		*cit = (scalar_t) i;		++cit;	}		FAILFALSE(m23(zero,two) == 0.0f)	FAILFALSE(m23(one,two) == 1.0f)		matrixn::ccol_it_t ccit = cm23.col_it(two);		for (int i=0; i<2; i++) {		FAILFALSE(*ccit == (scalar_t) i)		++ccit;	}}void test_dense_transpose_iterators(void){	matrixn_T m23(two,three);		m23(one,zero) = 3.0f; m23(one,one) = 4.0f; m23(one,two) = 5.0f;		matrixn_T::row_it_t rit = m23.row_it(one);		for (int i=0; i<3; i++) {		*rit = (scalar_t) i;		++rit;	}		FAILFALSE(m23(one,zero) == 0.0f)  FAILFALSE(m23(one,one) == 1.0f)	FAILFALSE(m23(one,two) == 2.0f)		const matrixn_T &cm23 = m23;		matrixn_T::crow_it_t crit = cm23.row_it(one);		for (int i=0; i<3; i++) {		FAILFALSE(*crit == (scalar_t) i)		++crit;	}	m23(zero,two) = 3.0f; m23(one,two) = 4.0f;		matrixn_T::col_it_t cit = m23.col_it(two);		for (int i=0; i<2; i++) {		*cit = (scalar_t) i;		++cit;	}		FAILFALSE(m23(zero,two) == 0.0f)	FAILFALSE(m23(one,two) == 1.0f)		matrixn_T::ccol_it_t ccit = cm23.col_it(two);		for (int i=0; i<2; i++) {		FAILFALSE(*ccit == (scalar_t) i)		++ccit;	}}