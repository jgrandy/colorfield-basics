/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __NONLINEAR_SOLVER_H#define __NONLINEAR_SOLVER_H#include "matrix.h"#include "matrix-inst.h"#include "derivative-function.h"namespace cf_algebra {template<class Q = matrixn1>class nonlinear_solver {public:			// Solvers are used to compute the value of a parametric function f(t)			// for a given t when that value cannot be directly computed, but the			// derivative of the function at any t *can* be computed.			// That is, dfdt exists but f does not.			// We start with a known value q0 = f(t0), and estimate values q' = f(t'),			// where t' = t0 + delta-t, by computing derivatives at various places.			// This is of course harder to do with a nonlinear function, and various			// methods exist that estimate more accurate q' values with generally			// more cost.			//			// Often one will step through a function f, computing its value along a			// more-or-less even series of increasing values for t. The class here 			// supports this practice explicitly with its step() function.					// Types			typedef nonlinear_solver<Q>				this_t;						typedef scalar_t		 				time_t;			typedef scalar_t						scalar_t;						typedef Q								q_t;			typedef Q								qdot_t;			typedef derivative_function<q_t>		function_t;								// Exceptions						class solver_not_initialized : public std::logic_error {				public:				         solver_not_initialized(void) : std::logic_error("solver not properly initialized") {}				explicit solver_not_initialized(const std::string& what_arg) : std::logic_error(what_arg) {}			};					// Construction/Destructionexplicit						nonlinear_solver(function_t &f)				: f_(f), t_((scalar_t) 0.0), 																			  delta_t_((time_t)1.0), 																			  q_(NULL), qdot_(NULL) {}virtual							~nonlinear_solver(void)						{}					// Simulation Statevirtual		void				set_state(const time_t &t, const q_t &q, const qdot_t &qdot);			void				set_state1(const time_t &t, const q_t &q)	{ 																			  qdot_t qdot(q.height(),one,init_zero);																			  this->set_time(t);																			  f_.apply(qdot,q,t);																			  this->set_state(t,q,qdot);																			};			time_t				get_time(void) const						{ return t_; }			void				set_time(const time_t t)					{ t_ = t; }				  const function_t&			get_function(void) const					{ return f_; }						typename q_t::height_t		get_state_size(void)						{ assert_solver_initialized(); return q_->height(); }	  const q_t &				get_state(void) const						{ assert_solver_initialized(); return *q_; }	  const qdot_t &			get_deriv(void) const						{ assert_solver_initialized(); return *qdot_; }	  					// Operational Parameters					virtual		void				suggest_step_size(const time_t &dt)			{ delta_t_ = dt; };					// Steppingvirtual		time_t				step(void) = 0;protected:			void				assert_solver_initialized(void)	const		{ if (!q_) throw solver_not_initialized(); }									// Simulation State								function_t&			f_;			time_t				t_;			time_t				delta_t_;			q_t *				q_;			qdot_t *			qdot_;};template<class Q>void nonlinear_solver<Q>::set_state(const time_t &t0, const q_t &q0, const qdot_t &dqdt0){	const typename q_t::height_t n = q0.height();		if ((! q_) || (q_->height() != n)) {		if (q_) delete q_;		q_ = new q_t(n,one);		if (qdot_) delete qdot_;		qdot_ = new qdot_t(n,one);	}		set_time(t0);	*q_ = q0;	*qdot_ = dqdt0;}} /* namespace cf_algebra */#endif /* __NONLINEAR_SOLVER_H */