/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 1999 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __MATRIX_OPS_PREDS_TMPL_H#define __MATRIX_OPS_PREDS_TMPL_H#include "matrix.h"#include "matrix-ops.h"#include "matrix-exceptions.h"#include "matrix-ops-meta-tmpl.h"#include "colorfield-functionals.h"namespace cf_algebra {template<class Extent, class Structure>				bool							has_nan		(const matrix<Extent,Structure> &A){	bool result = false;	inline_reduce(result, reduction_ops<scalar_t>::is_nan, A);	return result;}template<class Extent, class Structure>    scalar_t								norm_p2		(const matrix<Extent,Structure> &A){	scalar_t result = (scalar_t) 0.0;	inline_reduce(result, reduction_ops<scalar_t>::p2, A);	return result;}template<class Extent, class Structure>    scalar_t								norm_maxabs (const matrix<Extent,Structure> &A){	scalar_t result = (scalar_t) 0.0;	inline_reduce(result, reduction_ops<scalar_t>::maxabs, A);	return result;}template<class Extent1, class Structure1, class Extent2, class Structure2>				bool							operator==  (const matrix<Extent1,Structure1> &A, 															 const matrix<Extent2,Structure2> &B){	bool result = true;	inline_reduce(result, reduction_ops<scalar_t>::equal, A, B);	return result;}template<class Extent1, class Structure1, class Extent2, class Structure2>				bool							operator!=  (const matrix<Extent1,Structure1> &A, 															 const matrix<Extent2,Structure2> &B){	bool result = false;	inline_reduce(result, reduction_ops<scalar_t>::not_equal, A, B);	return result;}template<class Extent, class Structure>				bool							operator==  (const matrix<Extent,Structure> &A, 															 const scalar_t &val){	bool result = true;	inline_reduce(result, reduction_ops<scalar_t>::equal, A, val);	return result;}template<class Extent, class Structure>				bool							operator!=  (const matrix<Extent,Structure> &A, 															 const scalar_t &val){	bool result = false;	inline_reduce(result, reduction_ops<scalar_t>::not_equal, A, val);	return result;}template<class R1, class Structure1, class R2, class Structure2>    scalar_t								distance    (const matrix<coord_t<R1,one_t>,Structure1> &p1,	   														 const matrix<coord_t<R2,one_t>,Structure2> &p2){	const R1 h = p1.height();		AC_PRECONDITION(p1.height() == p2.height());		typename matrix<coord_t<R1,one_t>,Structure1>::ccol_it_t p1_it = p1.col_it(zero);	typename matrix<coord_t<R2,one_t>,Structure2>::ccol_it_t p2_it = p2.col_it(zero);		scalar_t result = (scalar_t) 0.0;		for (int i=0; i<h; i++) {			const scalar_t v1 = *p1_it,		        v2 = *p2_it,		        d  = v2 - v1;		++p1_it;		++p2_it;				result += d * d;	}}	   														 } /* namespace cf_algebra */#endif /* __MATRIX_OPS_PREDS_TMPL_H */