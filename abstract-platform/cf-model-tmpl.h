/* *  James Grandy *  Colorfield Digital Media Inc. * *  Copyright (c) 2000 Colorfield Digital Media Inc. *  Copyright (c) 2014 James Grandy * *  Permission is hereby granted, free of charge, to any person obtaining *  a copy of this software and associated documentation files (the "Software"), *  to deal in the Software without restriction, including without limitation *  the rights to use, copy, modify, merge, publish, distribute, sublicense, *  and/or sell copies of the Software, and to permit persons to whom the Software *  is furnished to do so, subject to the following conditions: * *  The above copyright notice and this permission notice shall be included in *  all copies or substantial portions of the Software. * *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, *  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN *  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */#ifndef __CF_MODEL_TMPL_H#define __CF_MODEL_TMPL_H#include "cf-model.h"namespace cf_abstract_platform {template<typename Key>model<Key>::model(void)  : observers_(){}template<typename Key>model<Key>::model(const this_t &)  : observers_()	// copies don't get access to original observers{}template<typename Key>model<Key>::~model(void){	observers_t::iterator oit = observers_.begin(),						ostop = observers_.end();	while (oit != ostop) {		this->observer_removed(**oit);		(*oit)->not_observing_model(*this);		++oit;	}	observers_.clear();}template<typename Key>void model<Key>::add_observer(observer_t &obs) const{	std::pair<observers_t::iterator,bool> ans = observers_.insert(&obs);	if (ans.second == true) {		this->observer_added(obs);		obs.observing_model(*this);	}}template<typename Key>void model<Key>::remove_observer(observer_t &obs) const{	observers_t::size_type ans = observers_.erase(&obs);	if (ans != 0) {		this->observer_removed(obs);		obs.not_observing_model(*this);	}}template<typename Key>bool model<Key>::has_observer(observer_t &obs) const{	observers_t::iterator oit = observers_.find(&obs);	return (oit != observers_.end());}template<typename Key>void model<Key>::observer_added(observer_t &) const{}template<typename Key>void model<Key>::observer_removed(observer_t &) const{}template<typename Key>void model<Key>::signal_change(key_t key){	observers_t::iterator oit = observers_.begin(),						ostop = observers_.end();	while (oit != ostop) {		try {			(*oit)->model_changed(*this, key);		} catch (...) {#if DEBUG			::Debugger();#endif		}		++oit;	}}template<typename Key>observer<Key>::observer(void){}template<typename Key>observer<Key>::observer(const this_t &){}template<typename Key>observer<Key>::~observer(void){}template<typename Key>void observer<Key>::model_changed(const model_t &, const key_t &){	// do nothing}template<typename Key>void observer<Key>::observing_model(const model_t &){	// do nothing}template<typename Key>void observer<Key>::not_observing_model(const model_t &){	// do nothing}} // namespace cf_abstract_platform#endif /* __CF_MODEL_TMPL_H */